  编写一个程序，开启三个线程，这三个线程的 ID 分别是 A、B 和 C，每个线程把自己的 ID 在屏幕上打印 10 遍，要求输出结果必须按 ABC 的顺序显示，如 ABCABCABC

两个线程打印：

```java
public static void main(String[] args) throws InterruptedException {
    final int[] i=new int[]{0};
    Object lock =new Object();

    Runnable printTask=()->{
        synchronized (lock){
            while (i[0]<26){
                System.out.println(Thread.currentThread ().getName()+" "+(char)('a'+i[0]));
                i[0]++;
                lock.notify();
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            lock.notify();
        }
    };

    Thread thread1=new Thread(printTask,"thread1");
    Thread thread2=new Thread(printTask,"thread2");
    thread1.start();
    thread2.start();
    thread1.join();
    thread2.join();
}
```



``` java
public static void threePrint() throws InterruptedException {
    final int[] i = new int[]{0};
    final String[] threadName = new String[]{"thread1", "thread2", "thread3"};
    Object lock = new Object();
    Runnable printTask = () -> {
        String currName = Thread.currentThread().getName();
        synchronized (lock) {
            while (i[0] < 26) {
                try {
                    while (!threadName[i[0] % 3].equals(currName)){
                        lock.wait();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if (i[0]<=25){
                    System.out.println(currName +" "+ (char) ('a' + i[0]));
                }
                i[0]++;
                lock.notifyAll();
            }
            lock.notify();
        }
    };
    Thread thread1 = new Thread(printTask, "thread1");
    Thread thread2 = new Thread(printTask, "thread2");
    Thread thread3 = new Thread(printTask, "thread3");
    thread1.start();
    thread2.start();
    thread3.start();
    thread1.join();
    thread2.join();
    thread3.join();
}
```



``` java
threadA = new Thread(() -> {
    for (int i = 0; i < 10; i++) {
        // 打印当前线程名称
        System.out.print(Thread.currentThread().getName());
        // 唤醒下一个线程
        LockSupport.unpark(threadB);
        // 当前线程阻塞
        LockSupport.park();
    }
}, "A");
threadB = new Thread(() -> {
    for (int i = 0; i < 10; i++) {
        // 先阻塞等待被唤醒
        LockSupport.park();
        System.out.print(Thread.currentThread().getName());
        // 唤醒下一个线程
        LockSupport.unpark(threadC);
    }
}, "B");
threadC = new Thread(() -> {
    for (int i = 0; i < 10; i++) {
        // 先阻塞等待被唤醒
        LockSupport.park();
        System.out.println(Thread.currentThread().getName());
        // 唤醒下一个线程
        LockSupport.unpark(threadA);
    }
}, "C");
threadA.start();
threadB.start();
threadC.start();
```



``` java
ReentrantLock lock = new ReentrantLock();
// 使用ReentrantLock的newCondition()方法创建三个Condition
// 分别对应A、B、C三个线程
Condition conditionA = lock.newCondition();
Condition conditionB = lock.newCondition();
Condition conditionC = lock.newCondition();

// A线程
new Thread(() -> {
    try {
        lock.lock();
        for (int i = 0; i < 10; i++) {
            System.out.print(Thread.currentThread().getName());
            // 叫醒B线程
            conditionB.signal();
            // 本线程阻塞
            conditionA.await();
        }
        // 这里有个坑，要记得在循环之后调用signal()，否则线程可能会一直处于
        // wait状态，导致程序无法结束
        conditionB.signal();
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        // 在finally代码块调用unlock方法
        lock.unlock();
    }
}, "A").start();
// B线程
new Thread(() -> {
    try {
        lock.lock();
        for (int i = 0; i < 10; i++) {
            System.out.print(Thread.currentThread().getName());
            conditionC.signal();
            conditionB.await();
        }
        conditionC.signal();
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}, "B").start();
// C线程
new Thread(() -> {
    try {
        lock.lock();
        for (int i = 0; i < 10; i++) {
            System.out.print(Thread.currentThread().getName());
            conditionA.signal();
            conditionC.await();
        }
        conditionA.signal();
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}, "C").start();
```



手写模拟死锁

``` java
final ArrayBlockingQueue[] resources=new ArrayBlockingQueue[]{
                new ArrayBlockingQueue<String>(1),
                new ArrayBlockingQueue<String>(1),
        };
        resources[0].add("resource 1");
        resources[1].add("resource 2");

        Object lock=new Object();
        new Thread(()->{
            synchronized (lock){
                try {
                    String take = (String) resources[0].take();
                    System.out.println(take);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                lock.notify();
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                try {
                    String take = (String) resources[1].take();
                    System.out.println(take);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        },"thread1").start();
        new Thread(()->{
            synchronized (lock){
                try {
                    String take = (String) resources[1].take();
                    System.out.println(take);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                lock.notify();
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                try {
                    String take = (String) resources[0].take();
                    System.out.println(take);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"thread2").start();
```

另一个模拟死锁

``` java
public static void main(String[] args) {
    final Object a = new Object();
    final Object b = new Object();
    Thread threadA = new Thread(new Runnable() {
        public void run() {
            synchronized (a) {
                try {
                    System.out.println("now i in threadA-locka");
                    Thread.sleep(1000l);
                    synchronized (b) {
                        System.out.println("now i in threadA-lockb");
                    }
                } catch (Exception e) {
                    // ignore
                }
            }
        }
    });

    Thread threadB = new Thread(new Runnable() {
        public void run() {
            synchronized (b) {
                try {
                    System.out.println("now i in threadB-lockb");
                    Thread.sleep(1000l);
                    synchronized (a) {
                        System.out.println("now i in threadB-locka");
                    }
                } catch (Exception e) {
                    // ignore
                }
            }
        }
    });

    threadA.start();
    threadB.start();
}

```

读者写者、生产者消费者、哲学家就餐