# 策略模式

亦称： Strategy

将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。

策略模式建议找出负责用许多不同方式完成特定任务的类， 然后将其中的算法抽取到一组被称为*策略*的独立类中。

名为上下文的原始类必须包含一个成员变量来存储对于每种策略的引用。 上下文并不执行任务， 而是将工作委派给已连接的策略对象

上下文不负责选择符合任务需要的算法——客户端会将所需策略传递给上下文

将不同行为抽取到一个独立类层次结构中

函数式编程等等其他新的语言特性使得策略模式可能再某些情况下不再需要引入新的额外的类



要点：

![](E:\_data\博文临时库\博文中的图片\策略模式.png)



- 运行时改变对象行为，运行时切换算法
- 当类中使用了复杂条件运算符以在同一算法的不同变体中切换时
- 上下文类中找出修改频率较高的算法 （也可是用于在运行时选择某个算法变体的复杂条件运算符）

例子：

- 电子商务应用中的支付方法

策略模式在 Java 代码中很常见。 它经常在各种框架中使用， 能在不扩展类的情况下向用户提供改变其行为的方式。

Java 8 开始支持 lambda 方法， 它可作为一种替代策略模式的简单方式。

这里有一些核心 Java 程序库中策略模式的示例：

- 对 [`java.util.Comparator#compare()`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#compare-T-T-) 的调用来自 `Collections#sort()`.
- [`javax.servlet.http.HttpServlet`](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html)：  `service­()` 方法， 还有所有接受 `Http­Servlet­Request` 和 `Http­Servlet­Response` 对象作为参数的 `do­XXX()` 方法。
- [`javax.servlet.Filter#doFilter()`](https://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-)

**识别方式：** 策略模式可以通过允许嵌套对象完成实际工作的方法以及允许将该对象替换为不同对象的设置器来识别

