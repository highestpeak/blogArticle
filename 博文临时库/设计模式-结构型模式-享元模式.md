# 享元模式

亦称： 缓存、 Cache、 Flyweight

内在状态和外在状态：

对象的**常量数据**通常被称为**内在状态**， 其位于对象中， 其他对象只能读取但不能修改其数值。 而对象的其他状态常常能被其他对象 “从外部” 改变， 因此被称为**外在状态**

- 内在状态： 包含不变的、 可在许多对象中重复使用的数据的成员变量。
- 外在状态： 包含每个对象各自不同的情景数据的成员变量



不在对象中存储外在状态：

摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态， 使得我们能在有限的内存容量中载入更多对象。享元说白了就是**缓存大量对象中的相似部分**，生成**大量**的对象。

享元模式建议不在对象中存储外在状态， 而是将其传递给依赖于它的一个特殊方法。 程序只在对象中保存内在状态， 以方便在不同情景下重用。 这些对象的区别仅在于其内在状态 （与外在状态相比， 内在状态的变体要少很多）， 因此你所需的对象数量会大大削减



要点：

- 享元类的状态只能由构造函数的参数进行**一次性初始化**：它不能对其他对象公开其设置器或公有成员变量。由于享元对象可在不同的情景中使用， 你必须确保其状态**不能被修改**

- 对象数量几乎没有， 但是这些对象要比之前小很多。

  因为消耗内存最多的成员变量已经被移动到很少的几个享元对象中了。 一个享元大对象会被上千个情境小对象复用， 因此无需再重复存储数千个大对象的数据。

享元工厂

为了能更方便地访问各种享元， 你可以创建一个工厂方法来管理已有享元对象的缓存池。 工厂方法从客户端处接收目标享元对象的内在状态作为参数， 如果它能在缓存池中找到所需享元， 则将其返回给客户端； 如果没有找到， 它就会新建一个享元， 并将其添加到缓存池中。

你可以选择在程序的不同地方放入该函数。 最简单的选择就是将其放置在享元容器中。 除此之外， 你还可以新建一个工厂类， 或者创建一个静态的工厂方法并将其放入实际的享元类中。

![](E:\_data\博文临时库\博文中的图片\享元模式类图.png)



优缺点：

- 牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据
- 提高了复杂性： 团队中的新成员总是会问：  “为什么要像这样拆分一个实体的状态？



使用情形：

- 仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。

   应用该模式所获的收益大小取决于使用它的方式和情景。 它在下列情况中最有效：
  - 程序需要生成数量巨大的相似对象
  - 这将耗尽目标设备的所有内存
  - 对象中包含可抽取且能在多个对象间共享的重复状态

例子

- 粒子系统：一个粒子系统， 作为游戏的特色。 大量的子弹、 导弹和爆炸弹片会在整个地图上穿行。每个粒子 （一颗子弹、 一枚导弹或一块弹片） 都由包含完整数据的独立对象来表示。 当玩家在游戏中鏖战进入高潮后的某一时刻， 游戏将无法在剩余内存中载入新建粒子， 于是程序就崩溃了
- 文本编辑器：您需要为文档中的每个字符实例化一个对象。然后，您只需要26个对象（假设文档仅使用小写字母），而不是为10,000个单词的文档中的每个字符存储一个对象，一个用于字母“ a”，一个用于字母“ b”，等等。 ，并且每次您需要执行某些需要“ a”对象的功能或动作时，都会在文档中反复反复使用它们。

享元模式在核心 Java 程序库中的示例：

- [`java.lang.Integer#valueOf(int)`](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#valueOf-int-) （以及 [`Boolean`](https://docs.oracle.com/javase/8/docs/api/java/lang/Boolean.html#valueOf-boolean-)、 [`Byte`](https://docs.oracle.com/javase/8/docs/api/java/lang/Byte.html#valueOf-byte-)、 [`Character`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#valueOf-char-)、 [`Short`](https://docs.oracle.com/javase/8/docs/api/java/lang/Short.html#valueOf-short-)、 [`Long`](https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html#valueOf-long-) 和 [`Big­Decimal`](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html#valueOf-long-int-)）

**识别方式：** 享元可以通过构建方法来识别， 它会返回缓存对象而不是创建新的对象



享元模式和静态字段

模式的重点是您可以有200个共享相同的“大红色”图形表示的“大红色”士兵，300个共享相同的“小蓝色”图形表示的“小蓝色”士兵，等等。如果您进行图形表示静态的，所有士兵都是一样的。

然后，每个士兵都将引用此静态集合的图形表示之一。假设列表的大小为5，士兵人数为1,000,000，则将有5个图形表示实例，而不是1,000,000。这就是模式的重点。



享元模式和缓存区别

Flyweight设计通常是不可变对象的存储。

“缓存”不是一个明确定义的术语。它可能意味着很多事情，例如结果缓存或资源对象池。



# 参考

> 1. [refactoringguru: flyweight](https://refactoringguru.cn/design-patterns/flyweight)

