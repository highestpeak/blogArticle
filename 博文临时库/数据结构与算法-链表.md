---
title: 数据结构-链表
date: 2020-10-09 15:09:00
status: PUBLISHED
comments: true
description: 链表结构特点，以及链表的一些常见应用和面试算法题
tags: 
- 数据结构
- 双指针
categories: 
- 数据结构
- 算法
---

# 占位



- 链表的存储方式：在C语言中的指针域位置？数据域位置？在Java中？在各个框架和语言中？
  - 是 前指针域 数据域 后指针域
  - 还是 数据域 指针域（前后指针域）
- 有头节点和无头节点
- 常见问题：
  - 双指针：
    - 获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度
    - 长度和位置
- 



[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

---

https://leetcode-cn.com/problems/linked-list-cycle/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-2/

每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 恰好指向中间两个结点的靠前一个(可以考虑下如何使其指向后一个结点呢？)

``` c++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *p = head, *q = head;
        while(q != nullptr && q->next != nullptr) {
            p = p->next;
            q = q->next->next;
        }
        return p;
    } 
};
```

慢指针的特性 —— **每轮移动之后两者的距离会加一**。下面会继续用该特性解决环的问题。
当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了**追及问题**。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。

跑的快的在超过跑的慢的一圈的时候，他们将会相遇

![](https://pic.leetcode-cn.com/d1ac82780e5189d7d58406504c3b7b56c35165997bfbb4c325677af92ee2d483.gif)

---

关于快慢指针中两个指针的速度问题： 和龟兔赛跑问题不同的是，龟兔赛跑是一个连续性的问题，无论二者的速度差是多少，可以这样假设：假设赛道长度为s，v_f表示速度快的值，v_s表示速度慢的值，（假设二者初始位置相同），那么可以求出来：(v_f-v_s)t=s；这样求出来的t，是二者第一次相遇的时间； 本题不同的是：对于链表来说是一个离散的值，我们假设环内共有n个节点，同样假设快指针与慢指针分别是v_f，v_s；如果想要相遇（假设初始位置相同），同样有(v_f-v_s)k = n； ——这个时候 v_f，v_s 为正整数，k为循环次数，n为节点数目； k = n/(v_f-v_s）如果想要k为整数，那么可以看到二者的速度差是有要求的，必须能够被n整除；注意：这样求得是第一次相遇，也有可能v_f-v_s是n的整数倍；

https://leetcode-cn.com/problems/linked-list-cycle/solution/ckuai-man-zhi-zhen-dai-zhu-shi-by-xi-yu-shi-liu-gu/283004

---

[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) 的递归、迭代解法（一看就会一写就废）

凡是递归的问题，自己一定要迭代写一下？

[143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

https://leetcode-cn.com/problems/reorder-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-34/

这个答案的递归解法，递归是一种划分子问题的思路，没有这样的思路可能连动态规划都做不出来的

---

[23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

主要看一下第一次写的那个，比自己第二次写的要好

[92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

看一下这个**头插法**（比自己逐个反转高明得多）

头插法也可以用来反转链表

[109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/shou-hua-tu-jie-san-chong-jie-fa-jie-zhu-shu-zu-ku/

这个题的中序遍历的思想

[143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

https://leetcode-cn.com/problems/reorder-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-34/

这个答案的把链表分成两部分的解法

---

下面这些 值得一写，看着简单，其实不是很好写，可以锻炼一下写链表的套路

[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/) 

[83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

[82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)



[143. 重排链表](E:\_data\博文临时库\基本密码学.md)

