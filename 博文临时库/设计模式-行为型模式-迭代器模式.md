# 迭代器模式

亦称： Iterator

- 不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素

  深度优先遍历、广度优先遍历等等等等

- 访问元素的算法：无论集合的构成方式如何， 它都必须提供某种访问元素的方式。迭代器模式的主要思想是将集合的**遍历行为抽取为单独的迭代器对象**





要点：

- 所有迭代器必须实现相同的接口

  为了使用方便， 可以添加一些其他方法， 例如：

  - 获取前一个元素
  - 记录当前位置
  - 判断迭代是否已结束

- 具体迭代器是和具体容器一一对应的，所以迭代器对象是从集合接口中获取的

![](E:\_data\博文临时库\博文中的图片\迭代器模式类图.png)



一个集合可能太大了，以致元素不能一起存储在内存中。迭代器一次仅提供对一个元素的访问，因此它只需要适合一个元素

例子：

- 集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用**便利性或安全性**的考虑）

  保护集合

- 减少程序中重复的遍历代码

- 希望代码能够遍历不同的甚至是无法预知的数据结构

该模式在核心 Java 程序库中的一些示例：

- [`java.util.Iterator`](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)的所有实现 （还有 [`java.util.Scanner`](https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html)）。
- [`java.util.Enumeration`](https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html)的所有实现（其实和iterator一样）

**识别方法：** 迭代器可以通过导航方法 （例如 `next` 和 `previous` 等） 来轻松识别。 使用迭代器的客户端代码可能没有其所遍历的集合的直接访问权限





使用[迭代器模式](https://refactoringguru.cn/design-patterns/iterator)来遍历[组合模式](https://refactoringguru.cn/design-patterns/composite)树

同时使用[工厂方法模式](https://refactoringguru.cn/design-patterns/factory-method)和[迭代器](https://refactoringguru.cn/design-patterns/iterator)来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配