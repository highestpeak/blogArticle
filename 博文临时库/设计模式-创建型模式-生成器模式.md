# 生成器模式

又有人叫 构建者模式，记住英语为 builder 即可

- **分步骤**创建复杂对象。 该模式允许你使用**相同的创建代码**生成**不同类型**和形式**的对象**。

  - 该模式会将对象构造过程划分为一组步骤， 比如 `build­Walls`创建墙壁和 `build­Door`创建房门创建房门等。
  - 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可
  - 当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 
  - 很多地方说 This should be used only when you want to build different immutable objects using same object building process. 也就是仅当要使用 相同的对象构建过程 构建 不同的不可变对象 时，才应使用此方法

- 生成器解决的问题是：

  - 假设有这样一个**复杂对象**， 在对其进行构造时需要对**诸多成员变量和嵌套对象**进行繁复的初始化工作

  - 这样导致的后果是有**特别多的子类**（所有参数的任何组合都应该有一个子类）

  - 或者还可能导致的后果就是**构造函数**包含**众多**的**参数**，

    例如构造函数： `House(windows,doors,rooms,hasGarage,hasSwimPool,hasStatus,hasGarden)`

    - 通常情况下， 绝大部分的参数都没有使用， 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的

- 生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中
- 生成器不允许其他对象访问正在创建中的产品。



- 主管类：进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类
  - 严格来说， 你的程序中并不一定需要主管类。 客户端代码可直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放入各种例行构造流程， 以便在程序中反复使用
  - 对于客户端代码来说， 主管类完全隐藏了产品构造细节。客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了
- 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现

![](E:\_data\博文临时库\博文中的图片\生成器模式类图.png)



基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。

- 清晰地定义通用步骤， 确保它们可以制造所有形式的产品
- 不要忘记实现获取构造结果对象的方法。 你不能在生成器接口中声明该方法， 因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法
  - 只有在所有产品都遵循相同接口的情况下， 构造结果可以直接通过主管类获取。 否则， 客户端应当通过生成器获取构造结果
- 客户端代码会同时创建生成器和主管对象。
  -  构造开始前， 客户端必须将生成器对象传递给主管对象
  - 还有另一种方式， 那就是客户端可以将生成器对象直接传递给主管类的制造方法。





生成器适用的场景：

- 使用生成器模式可避免 “重叠构造函数 （telescopic constructor）” 的出现，避免了大量构造函数的重载
- 希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时，需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异
- 使用生成器构造组合树或其他复杂对象，生成器模式让你能分步骤构造产品。 你可以**延迟执行**某些步骤而不会影响最终产品



生成器优点：

- 分步骤创建对象、延迟创建步骤、递归创建
- 复用相同代码生成不同产品
- 单一职责原则：复杂构造代码从产品逻辑中分离

缺点：

- 新增多个类，复杂度增加



与其他模式：

- 生成器重点关注如何**分步**生成复杂对象。 抽象工厂专门用于生产**一系列**相关对象。 抽象工厂会**马上返回**产品， 生成器则允许你在获取产品前**执行一些额外构造步骤**

- 生成器和桥接



Java中的例子：

- [`java.lang.StringBuilder#append()`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html#append-boolean-) （ `非同步` ）
- [`java.lang.StringBuffer#append()`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-) （ `同步` ）
- [`java.nio.ByteBuffer#put()`](https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-) （还有 [`Char­Buffer`](https://docs.oracle.com/javase/8/docs/api/java/nio/CharBuffer.html#put-char-)、 [`Short­Buffer`](https://docs.oracle.com/javase/8/docs/api/java/nio/ShortBuffer.html#put-short-)、 [`Int­Buffer`](https://docs.oracle.com/javase/8/docs/api/java/nio/IntBuffer.html#put-int-)、 [`Long­Buffer`](https://docs.oracle.com/javase/8/docs/api/java/nio/LongBuffer.html#put-long-)、 [`Float­Buffer`](https://docs.oracle.com/javase/8/docs/api/java/nio/FloatBuffer.html#put-float-) 和 [`Double­Buffer`](https://docs.oracle.com/javase/8/docs/api/java/nio/DoubleBuffer.html#put-double-)）
- [`javax.swing.GroupLayout.Group#addComponent()`](https://docs.oracle.com/javase/8/docs/api/javax/swing/GroupLayout.Group.html#addComponent-java.awt.Component-)
- [`java.lang.Appendable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html)的所有实现

这些例子和上述的类图和标准的生成器的步骤不太一样，因为builder的每一个方法都会返回一个builder

**识别方法：** 生成器模式可以通过类来识别， 它拥有一个构建方法和多个配置结果对象的方法。 生成器方法通常支持方法链 （例如 `someBuilder->setValueA(1)->setValueB(2)->create()` ）



类似StringBuilder的另一个例子：

- 这个User和 `UserBuilder` 的例子对于模仿来说是很好的 https://howtodoinjava.com/design-patterns/creational/builder-pattern-in-java/



另类的一个例子：

- https://www.tutorialspoint.com/design_pattern/builder_pattern.htm  其中 MealBuilder 是主管？Meal是生成器？



有些人认为生成器模式和抽象工厂大体相同，但是我仍然认为他们可能是看到了有误导性的类图产生的这样的想法

生成器模式的目标是“将复杂对象的构造与其表示分开，以便同一构造过程可以创建不同的表示”。逐步构造一个复杂的对象，最后一步将返回该对象

构建器模式可以帮助我们创建具有大量状态属性的不可变类。



使用生成器模式，代码行数至少增加了一倍，但是在设计灵活性和可读性上付出是值得的

- 构造函数的参数会减少，并以高度可读的方法调用提供。
- 生成器设计模式还有助于最大程度地减少构造函数中的参数数量，因此无需将null作为可选参数传递给构造函数。
- 对象总是在完整状态下实例化
- 在对象构建过程中，无需太多复杂逻辑即可构建不可变对象



- 在构建器模式中，代码行的数量至少增加了一倍，但是在设计灵活性和可读性更高的方面，付出的努力是有回报的。
- 需要为每种不同类型的产品创建一个单独的ConcreteBuilder。



[StackOverflow: When would you use the Builder Pattern? [closed]](https://stackoverflow.com/questions/328496/when-would-you-use-the-builder-pattern)

- 当需要做很多事情来构建对象时，构建器非常有用

  例如HTML的DOM，需要创建大量的节点和属性才能获得最终的对象

  与此相比，当工厂方法模式可以在一个方法调用中轻松创建整个对象时，将使用工厂方法模式

- 使用构建器的一个示例是构建XML文档

As Joshua Bloch states in [Effective Java, 2nd Edition](http://www.amazon.co.uk/Effective-Java-Second-Joshua-Bloch/dp/0321356683):

> The builder pattern is a good choice when designing classes whose constructors or static factories would have more than a handful of parameters.

就是如上文讲的伸缩构造函数的例子：一旦构造函数具有4或5个参数，就**很难记住参数**的必需**顺序**以及在给定情况下可能需要的特定构造函数

- 一种替代方式是 **JavaBean模式**，在其中调用带有必需参数的构造器，然后在之后调用任何可选的setter

  **这里的问题是，由于对象是通过多个调用创建的，因此在其构造过程中可能处于不一致状态。**这也需要付出很多额外的努力来确保**线程安全**

- 更好的选择是使用构建器模式

  注意这样的一个基于内部类的builder的写法

  **可以将构建方法修改**为在将参数从构建器复制到Pizza对象后检查参数，**如果提供了无效的参数值**，则**抛出IllegalStateException。**这种模式很灵活，将来很容易为它添加更多参数。仅当您要为构造函数使用**4个或5个以上的参数**时，它才真正有用。就是说，**如果您怀疑将来可能会添加更多参数**，那么首先值得这样做



对于形如Java的StringBuilder的写法中，很多人这样质疑： This looks more like a [Fluent Interface](http://en.wikipedia.org/wiki/Fluent_interface) than a [builder pattern](http://en.wikipedia.org/wiki/Builder_pattern).

但是也有人认为：  Its just that often a Builder will ALSO use a fluent interface. A Builder doesnt have to have a fluent interface.

我倾向于后一种，即：生成器模式通常返回builder自身，但是并不是必须来返回自身进而达到 fluent interface 的效果



有一个有趣的例子是：

考虑一家餐厅。“今天的饭”的创建是一种工厂模式，因为您告诉厨房“给我今天的饭”，然后厨房（工厂）根据隐藏的标准决定要生成的对象。

如果您订购自定义的披萨，则会显示构建器。在这种情况下，服务员告诉厨师（建造者）：“我需要一个比萨饼；在其中添加奶酪，洋葱和培根！” 因此，构建器**公开了**生成的对象应具有的**属性**，但**隐藏了如何设置**它们。



关于生成器和工厂的对比，也有一个有趣的说法：

考虑这样一个例子：对于多线程问题，我们需要为每个线程构建一个复杂的对象。该对象表示正在处理的数据，并且可以根据用户输入进行更改。

我们可以改用工厂吗？是

我们为什么不呢？我猜Builder更有意义。

工厂用于创建具有相同基本类型（实现相同的接口或基类）的不同类型的对象。

生成器一遍又一遍地构建相同类型的对象，但是**构建是动态**的，因此可以在**运行时进行更改**。

这个例子表达的是使用工厂不能够再后续的过程中进一步的动态更改对象，他指的不能动态的更改应该是构建对象上不能动态的构建某些部分，而不是属性不能动态更改。





有人指出，生成器模式容易被滥用，仅应当再需要 **a post-initialisation step** 中的数据来组装对象时才应当被使用。在多数时间应当使用构造器来初始化类成员。如果需要 Fluent Interface 写法，可以把set返回自身，例如：

``` java
	public void setFirst(String first){
       this.first=first; 
    }

    ... 

    public Complex withFirst(String first){
       this.first=first;
       return this; 
    }
```



[StackOverflow: Why do we need to use the builder design pattern when we can do the same thing with setters?](https://stackoverflow.com/questions/55748815/why-do-we-need-to-use-the-builder-design-pattern-when-we-can-do-the-same-thing-w?noredirect=1&lq=1) 

构建器模式可用于：

- 对用于初始化对象的数据进行一些**检查**。例如，如果您需要仔细检查变量

- 创建**不可变**的对象。初始化后就无法更改对象，因此无法使用设置器setter

  与使用setter（使您的类可变）不同，可以使用构建器构造不可变的对象。在许多情况下，不可变对象优于可变对象，因为它们易于理解和维护，并且避免了在多线程环境中进行锁定的需求。

- 增加代码的可读性。

- 减少用于初始化对象的代码

- 使实例处于**有效状态**。使用设置器，在调用所有设置器之前，对象实例可能处于无效状态。

------

*关于使用构建器创建不可变对象的说明。*

在多线程环境中工作时，可以在线程之间共享不可变对象，而无需显式同步。因为对象在这段时间内无法更改，所以不可能使竞争条件同时由两个线程访问和修改。





抽象工厂模式的目的是交换一组可以一起使用的产品。构建器模式的目的是封装创建产品的抽象算法，以将其重用于产品的不同表示形式。



[StackOverflow: What is the difference between Builder Design pattern and Factory Design pattern?](https://stackoverflow.com/questions/757743/what-is-the-difference-between-builder-design-pattern-and-factory-design-pattern?noredirect=1&lq=1)

The Builder is only needed when an object cannot be produced in one step. One great an example of this would be in the de-serialization process for a complex object. Often times the parameters for the complex object must be retrieved one by one

仅当无法一步生成一个对象时才需要Builder。一个很好的例子是在复杂对象的反序列化过程中。通常，必须一一检索复杂对象的参数



**工厂**只是围绕构造函数的包装函数（可能在另一个类中）。关键区别在于，工厂方法模式要求将整个对象构建在单个方法调用中，并且所有参数都在一行中传递。最终的对象将被返回。

另一方面，**构建器模式**实质上是包装对象，它包装了您可能希望传递给构造函数调用的所有可能参数。这使您可以使用setter方法来缓慢地建立参数列表。构建器类上的另一种方法是build（）方法，该方法将构建器对象简单地传递到所需的构造函数中并返回结果。



构建器模式就像放大大对象的构造一样。大对象由其他对象组成，而其他对象则在类似递归的基础上进一步组成。而工厂只需要一个电话就可以得到。



您可能有一个`createCar`builder方法，该方法创建`Honda`具有4汽缸发动机的- `Honda`型对象或具有6汽缸的- 型对象。构建器模式允许这种更精细的粒度。



构建器设计模式描述了一个对象，该对象知道如何通过几个步骤来制作另一个特定类型的对象。在每个中间步骤中，它保留目标项目的所需状态。

工厂设计模式描述了一个对象，该对象知道如何在一个步骤中创建几种不同但相关的对象，其中根据给定的参数选择特定的类型。



- 逐步构建复杂的对象：构建器模式
- 通过使用一种方法创建一个简单的对象：工厂方法模式
- 使用多个工厂方法创建对象：抽象工厂模式





# 参考

> - [StackOverFlow: How to implement the builder pattern in Java 8?](https://stackoverflow.com/questions/31754786/how-to-implement-the-builder-pattern-in-java-8?noredirect=1&lq=1)
> - [HowToDoInJava: Builder Design Pattern in Java](https://howtodoinjava.com/design-patterns/creational/builder-pattern-in-java/)
> - [tutorialspoint: Design Patterns - Builder Pattern](https://www.tutorialspoint.com/design_pattern/builder_pattern.htm)
> - [refactoringguru: builder pattern](https://refactoringguru.cn/design-patterns/builder)

