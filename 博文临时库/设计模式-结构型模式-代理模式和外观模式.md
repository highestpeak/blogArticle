# 代理模式

Proxy

- 代理控制着对于原对象的访问，管理着被代理对象的生命周期
- 代理允许在将请求提交给对象**前后**进行一些**处理**



要点

- 新建一个与原服务对象**接口相同**的代理类

  如果没有现成的服务接口， 就需要创建一个接口来实现代理和服务对象的可交换性。 从服务类中抽取接口并非总是可行的， 因为你需要对服务的所有客户端进行修改， 让它们使用接口。

  **备选计划是将代理作为服务类的子类**， 这样代理就能继承服务的所有接口了。

- 代理类必须包含**一个存储指向服务的引用的成员变量**：代理类接收到客户端请求后创建实际的服务对象， 并将所有工作委派给它

  - 通常情况下， 代理负责创建服务并对其整个生命周期进行管理。 

  - 在一些特殊情况下， 客户端会通过构造函数将服务传递给代理。

![](E:\_data\博文临时库\博文中的图片\代理模式类图.png)



使用代理的场景：

- 延迟实例化
- 智能引用：可在没有客户端使用某个重量级对象时立即销毁该对象。
- 数据前后处理（虚拟代理）、访问控制 （保护代理）
- 本地执行远程服务 （远程代理）：服务对象位于远程服务器上的情形
- 记录日志请求 （日志记录代理）：代理可以在向服务传递请求前进行记录
- 缓存请求结果 （缓存代理）

例子

- 数据库连接：

  有这样一个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它， 并非总是需要。例如数据库连接。你会选择实现延迟初始化： 在实际有需要时再创建该对象，对象的所有客户端都要执行延迟初始代码。 不幸的是， 这很可能会带来很多重复代码。

  这样在理想情况下， 我们希望将代码直接放入对象的类中， 但这并非总是能实现： 比如类可能是第三方封闭库的一部分。

Java 标准程序库中的一些代理模式的示例：

- [`java.lang.reflect.Proxy`](http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html)
- [`java.rmi.*`](http://docs.oracle.com/javase/8/docs/api/java/rmi/package-summary.html)
- [`javax.ejb.EJB`](http://docs.oracle.com/javaee/7/api/javax/ejb/EJB.html) （[查看评论](http://stackoverflow.com/questions/25514361/when-using-ejb-does-each-managed-bean-get-its-own-ejb-instance)）
- [`javax.inject.Inject`](http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html) （[查看评论](http://stackoverflow.com/questions/29651008/field-getobj-returns-all-nulls-on-injected-cdi-managed-beans-while-manually-i/29672591#29672591)）
- [`javax.persistence.PersistenceContext`](http://docs.oracle.com/javaee/7/api/javax/persistence/PersistenceContext.html)

**识别方式：** 代理模式会将所有实际工作委派给一些其他对象。 除非代理是某个服务的子类， 否则每个代理方法最后都应该引用一个服务对象。



# 外观模式

亦称： 门面模式、 `Facade`

为什么使用外观模式

- 必须在一段代码中使用某个复杂的库或框架中的多个对象。

  当对这个库在多个地方都使用之后，就会出现紧密耦合，因此需要全部抽取到一个地方，也就是外观模式类

- 如果需要将子系统组织为**多层结构**， 可以使用外观

  - 外观模式可以让我们在复杂子系统之上，再构建一个接口，该接口相当于子系统和外部系统的**"中介"**。外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求
  - 创建外观来定义**子系统中各层次的入口**。 

- 可以要求子系统仅使用外观来进行交互



要点

- 外观模式为子系统（程序库、 框架或其他复杂类）提供一个简单的接口（额外的简单的视图）。必须确保所有客户端代码仅通过外观来与子系统进行交互
- 外观类管理的是子系统，外观类控制着子系统相关部分的初始化、后续生命周期管理。
- 如果外观变得过于臃肿， 可以考虑将其部分行为抽取为一个新的专用外观类
- 外观类大多数时可以实现为单例



![](E:\_data\博文临时库\博文中的图片\外观模式类图.png)

优缺点：

- 外观使得子系统相互独立
- 外观类可能成为和所有类都耦合的上帝对象



核心 Java 程序库中的外观示例：

- [`javax.faces.context.FacesContext`](https://docs.oracle.com/javaee/7/api/javax/faces/context/FacesContext.html) 在底层使用了 [`Life­Cycle`](https://docs.oracle.com/javaee/7/api/javax/faces/lifecycle/Lifecycle.html)、 [`View­Handler`](https://docs.oracle.com/javaee/7/api/javax/faces/application/ViewHandler.html) 和 [`Navigation­Handler`](https://docs.oracle.com/javaee/7/api/javax/faces/application/NavigationHandler.html) 这几个类， 但绝大多数客户端不知道。
- [`javax.faces.context.ExternalContext`](https://docs.oracle.com/javaee/7/api/javax/faces/context/ExternalContext.html) 在内部使用了 [`Servlet­Context`](https://docs.oracle.com/javaee/7/api/javax/servlet/ServletContext.html)、 [`Http­Session`](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSession.html)、 [`Http­Servlet­Request`](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html)、 [`Http­Servlet­Response`](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponse.html) 和其他一些类。

**识别方式：** 外观可以通过使用简单接口， 但将绝大部分工作委派给其他类的类来识别。 通常情况下， 外观管理着其所使用的对象的完整生命周期



# 模式区别

- 外观和代理都缓存了其他对象实体，并管理者初始化和生命周期

  但是代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换，外观不是这样

- 外观和中介者的区别？



# 参考

> 1. [refactoringguru: facade](https://refactoringguru.cn/design-patterns/facade)