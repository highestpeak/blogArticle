# 桥接模式

将一个大类或一系列紧密相关的类拆分为**抽象**和**实现**两个独立的层次结构（抽象？实现？听上去挺吓人？）

- 抽取维度，继承变组合：

  桥接模式通过将**继承改为组合**的方式来解决这个问题。 具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在**初始类中引用**这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。

- 抽象部分 （也被称为接口） 是一些实体的高阶控制层。 该层自身不完成任何具体的工作， 它需要将工作委派给实现部分层 （也被称为平台）
  - 这里提到的内容与编程语言中的*接口*或*抽象类*无关



![](E:\_data\博文临时库\博文中的图片\桥接模式类图.png)



如果想要**拆分或重组**一个具有多重功能的**庞杂类** （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式

如果你希望在**几个独立维度上扩展一个类**， 可使用该模式

- 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作

如果你需要在**运行时切换不同实现方法**， 可使用桥接模式

- 这一点是很多人混淆桥接模式和[策略](https://refactoringguru.cn/design-patterns/strategy)模式的主要原因。 记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题

创建与平台无关的类和程序

- **客户端**代码**仅与**高层**抽象**部分进行**互动**， 不会接触到平台的详细信息

- 桥接模式在处理跨平台应用、 支持多种类型的数据库服务器或与多个特定种类 （例如云平台和社交网络等） 的 API 供应商协作时会特别有用

  桥接可以通过一些控制实体及其所依赖的多个不同平台之间的明确区别来进行识别。

例子

- 形状shape，圆形circle，矩形square，颜色color，红色red，蓝色blue。如果一个一个组合那么就会产生类爆炸，这是因为我们在两个独立的维度——形状与颜色——上扩展形状类，所以就需要有两个层次

- 抽象部分是图形用户界面 （GUI）， 而实现部分则是底层操作系统代码 （API）， GUI 层调用 API 层来对用户的各种操作做出响应
  - 开发多个不同的 GUI （例如面向普通用户和管理员进行分别配置）
  - 支持多个不同的 API （例如， 能够在 Windows、 Linux 和 MacOS 上运行该程序）

- 设备device和遥控器
  - 遥控器基类声明了一个指向设备对象的引用成员变量

    你可以开发独立于设备类的遥控器类， 只需新建一个遥控器子类即可。





实现方式

1. **明确**类中独立的**维度**。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。

2. 了解**客户端**的**业务需求**， 并**在抽象**中定义它们。

3. 确定在所有**平台**上都可执行的业务。 并在**通用实现接口**中声明抽象部分所需的业务。

   为你域内的所有**平台创建实现**类， 但需确保它们遵循实现部分的接口。

4. 在**抽象中添加指向实现类型的引用成员变量**。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。

   如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。

5. **客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联**。 此后， **客户端只需与抽象对象进行交互， 无需和实现对象打交道**



将[抽象工厂模式](https://refactoringguru.cn/design-patterns/abstract-factory)和[桥接](https://refactoringguru.cn/design-patterns/bridge)搭配使用。 如果由*桥接*定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， *抽象工厂*可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性

使用[生成器模式](https://refactoringguru.cn/design-patterns/builder)和[桥接模式](https://refactoringguru.cn/design-patterns/bridge)： *主管*类负责抽象工作， 各种不同的*生成器*负责*实现*工作





# 参考

[refactoringguru: bridge](https://refactoringguru.cn/design-patterns/bridge)



