# 原型模式

https://stackoverflow.com/questions/2427883/clone-vs-copy-constructor-which-is-recommended-in-java

https://stackoverflow.com/questions/869033/how-do-i-copy-an-object-in-java

使你能够复制已有对象， 而又无需使代码依赖它们所属的类

原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 `克隆`方法。

所有的类对 `克隆`方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。

形似有丝分裂

此外还有原型注册表变体模式





解决的问题：

- 有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。

- 必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类

- 有时你只知道对象所实现的接口， 而不知道其所属的具体类



![](E:\_data\博文临时库\博文中的图片\原型模式类图.png)





适用于：

- 需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类

- 如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象

  在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型

  客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可

  **这对应于下面的注意的第二点**

  



注意：

- 有一种说法是：

  原型类必须另行定义一个以该类对象为参数的构造函数。 构造函数必须复制参数对象中的所有成员变量值到新建实体中。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。

  然后克隆方法通常只有一行代码： 使用 `new`运算符调用原型版本的构造函数。 

- 还可以创建一个中心化原型注册表， 用于存储常用原型。

  你可以新建一个工厂类来实现注册表， 或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。

  最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。

  **这对应于上面的适用于的第二点**



优缺点：

- 克隆对象， 而无需与它们所属的具体类相耦合  ????????

- 可以更方便地生成复杂对象：省去了初始化等等的步骤

  - 克隆预生成原型， 避免反复运行初始化代码

    当对象创建非常耗时且操作昂贵时

    初始化代码可能包括昂贵的操作，

    仅在需要时，新复制的对象才能更改相同的属性（COW）。这种方法节省了昂贵的资源和时间，尤其是在对象创建很繁重的过程中

- 你可以用继承以外的方式来处理复杂对象的不同配置：即注册表的形式

  [原型](https://refactoringguru.cn/design-patterns/prototype)并不基于继承， 因此没有继承的缺点。 另一方面， *原型*需要对被复制对象进行复杂的初始化。 [工厂方法](https://refactoringguru.cn/design-patterns/factory-method)基于继承， 但是它不需要初始化步骤。

  注册表可能是原型模式极大的价值之一

  当类的实例只能具有几种不同的状态组合之一时。安装相应数量的原型并克隆它们，而不是每次都以适当的状态手动实例化类，可能会更方便



- 克隆包含循环引用的复杂对象可能会非常麻烦
- 当内部对象包含不支持复制或具有循环引用的对象时，也很难实现clone（）
- 对于使用很少的对象和/或根本不强调原型链扩展的项目而言，矫kill过正





其他设计模式：

- 原型可用于保存命令模式的历史记录
- 大量使用**组合**模式和装饰模式的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造
- 有时候[原型](https://refactoringguru.cn/design-patterns/prototype)可以作为[备忘录模式](https://refactoringguru.cn/design-patterns/memento)的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。



java中的例子自然就是

[`java.lang.Object#clone()`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone--) （类必须实现 [`java.lang.Cloneable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html) 接口）



原型模式有一些好处，例如：

- 它消除了初始化对象的（潜在的昂贵）开销
- 它简化并可以优化用例，其中相同类型的多个对象将具有大部分相同的数据

比如使用的对象的数据是通过解析杂乱的网络数据来创建的，那么如果不需要每次都去检索数据就可以省去这样的创建的步骤的开销。

- 但是这样有一个问题，很多时候无法避免使用复杂的初始化代码



原型会导致克隆的对象与原始对象不同。克隆时，原始状态与克隆相同。之后，每个对象可以经历状态改变。您可以将其视为类似于复印原件，然后在几个地方进行修改的复印件

# 单例模式

单例模式解决三个问题：

（注意第一个问题和第二个问题是不一样的！！）

- 保证一个类只有**一个实例**
- 为该实例提供一个全局访问节点。和**全局变量**一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖
- 你不会希望**解决同一个问题的代码**分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此

因此单例模式有着更多的问题，

- 违反了单一职责原则

- 可能掩盖不良设计， 比如程序各组件之间相互了解过多等

- 在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象

  进一步的在分布式集群环境下

- 客户端代码单元测试可能会比较困难



与其他模式

- 外观模式和单例模式
- 享元模式和单例模式



java中的例子

- [`java.lang.Runtime#getRuntime()`](https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime--)
- [`java.awt.Desktop#getDesktop()`](https://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--)
- [`java.lang.System#getSecurityManager()`](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--)



单例模式是如此的简单，以至于不得不让人怀疑他是否有很多问题，事实上他确实有不少的问题

有人说，单例模式是对非OO编程的一种回顾和怀念，这其实不无道理，单例模式貌似在鼓励程序员忘记OO的设计知识，毕竟OO太难，程序太容易



- 单例模式可能造成内存泄漏，

  如果没有人一段时间使用Singleton，则基本上只是一次内存泄漏。但是您不知道何时取消分配它，因为没人会打电话给您并说“没人会使用您一段时间！”

  您无法确定谁一直引用您的Singleton实例（注意：Java的弱引用可以帮助解决此问题）

- 如果您的Singleton拥有一些有限资源的句柄，例如数据库或文件句柄，可能有不知道什么地方把这些东西给释放掉了

- 单例模式抑制了可扩展性

- 理论上：当您需要将一个对象的实例限制为一个实例时。在实践中：永远不会。



基于他解决的第三个问题，又引伸出了单例模式和静态类的区别，如何选用的问题

是什么让您说单例或静态方法不是线程安全的？通常，两者*都应*实现为线程安全的。

单例和一堆静态方法之间的最大区别在于，单例可以实现接口（或从有用的基类派生，尽管根据我的经验，这种情况不那么常见），因此您可以将单例当作“只是另一个实现。

单例允许访问单个创建的实例-该实例（或对该实例的引用）可以作为参数传递给其他方法，并被视为普通对象。

静态类仅允许使用静态方法。

单例模式应当禁止克隆对象

单例可以被延迟或异步初始化，而静态类通常在首次加载时被初始化，从而导致潜在的类加载器问题。但是，最重要的优点是，单例可以进行多态处理，而不必强迫其用户假设只有一个实例。



如果有一堆功能应该保持在一起，那`static`就是选择。需要对某些资源进行单一访问的任何其他内容都可以实现为`singleton`。

**静态类**：

静态类不能具有构造函数。

不能将静态类传递给方法。

性能更好（静态方法在编译时绑定）

具有所有静态方法的类。

**单身人士：-**

1. 当用户请求时，首次创建Singleton实例。延迟加载，（静态类也被延迟加载。）
2. Singleton类可以具有构造函数。
3. 您可以创建单例类的对象并将其传递给方法。
4. Singleton类未说明继承的任何限制。
5. 方法可以被覆盖。
6. 可以在需要时延迟加载（始终加载静态类）。
7. 我们可以实现接口（静态类不能实现接口）。



静态类是仅具有静态方法的类，对此最好的词是**“函数”**。静态类中体现的设计风格纯粹是**过程性**的。

另一方面，单例是面向对象设计的特定模式。它是一个对象的实例（具有其内在的所有可能性，例如多态性），并且创建过程可以确保该特定角色在其整个生命周期中只有一个实例。



带有静态方法的类也可以具有私有静态字段，该字段仍可以用来维护状态

单例的另一个优点是可以轻松地进行序列化，



单例解决一个（也是唯一一个）问题。

**资源争用。**

如果您有一些资源

（**1**）只能有一个实例，并且

（**2**）您需要管理该单个实例，

您需要一个**单身人士**。

例子不多。日志文件很大。您不想只放弃一个日志文件。您要正确刷新，同步并关闭它。这是必须管理的单个共享资源的示例。

您很少需要单身人士。他们之所以不好，是因为他们感觉自己像个[全球人](https://en.wikipedia.org/wiki/Global_variable)，

硬件也是一个例子吧？



需要注意的一件事是，如果您确实使用单例，请尝试将其传递给需要它们的人，而不是让他们直接访问它……否则，如果您选择采用多种方式来完成单例的事情，那将是改变非常困难，因为如果每个类都直接访问单例，则会嵌入一个依赖项。

所以基本上：

```java
public MyConstructor(Singleton singleton) {
    this.singleton = singleton;
}
```

而不是：

```java
public MyConstructor() {
    this.singleton = Singleton.getInstance();
}
```

单例模式没有写完

# 参考

> 1. [StackOverflow: Questions about the Prototype Pattern](https://stackoverflow.com/questions/5739240/questions-about-the-prototype-pattern)
> 2. [StackOverflow: What's the point of the Prototype design pattern?](https://stackoverflow.com/questions/13887704/whats-the-point-of-the-prototype-design-pattern)
> 3. [Geeksforgeeks: Prototype Design Pattern](https://www.geeksforgeeks.org/prototype-design-pattern/) 
> 4. [refactoringguru:  prototype](https://refactoringguru.cn/design-patterns/prototype)
> 5. [refactoringguru:  singleton](https://refactoringguru.cn/design-patterns/singleton)
> 6. [StackOverflow: Singleton pattern [closed]](https://stackoverflow.com/questions/3319434/singleton-pattern)
> 7. [StackOverflow: Difference between static class and singleton pattern?](https://stackoverflow.com/questions/519520/difference-between-static-class-and-singleton-pattern)
> 8. [StackOverflow: What is so bad about singletons? [closed]](https://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons)
> 9. [Difference between Singleton Pattern vs Static Class in Java](https://javarevisited.blogspot.com/2013/03/difference-between-singleton-pattern-vs-static-class-java.html)

