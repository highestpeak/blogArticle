# 责任链模式

亦称： 职责链模式、 命令链、 CoR、 Chain of Command、 Chain of Responsibility

- 将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者

- 将处理者连成一条链。 链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。 请求会在链上移动， 直至所有处理者都有机会对其进行处理。

- 处理者可以处理请求， 也可以沿着链传递请求。处理者可以决定不再沿着链传递请求， 这可高效地取消所有后续处理步骤。

  - 经典的使用方式是：如果处理者自己能够处理， 处理者就不再继续传递请求

    在这种情况下， 每个请求要么最多有一个处理者对其进行处理， 要么没有任何处理者对其进行处理。 在处理图形用户界面元素栈中的事件时， 这种方式非常常见

- 对象树中抽取出链

todo： 这样的链式调用会不会出现栈溢出现象？所以换成另一种实现？有一个调度类来调度责任链条传递？每次方法返回对下一个类的调用引用

要点：

- 所有处理者类均**实现同一接口**。 每个具体处理者**仅关心下一个**包含 `execute`执行方法的处理者
- 可以根据处理者接口创建抽象处理者基类，从而在具体处理者中消除重复的样本代码
- 链条创建可以由client自行组装，也可以由工厂类根据配置或环境来创建
- client可以触发任意处理者，而不仅仅是第一个
- 由于链的动态性， 客户端需要准备好处理以下情况：
  - 链中可能只有单个链接。
  - 部分请求可能无法到达链尾。
  - 其他请求可能直到链尾都未被处理，即请求可能未被处理

![](E:\_data\博文临时库\博文中的图片\责任链模式类图.png)



优缺点：

- 请求可能不被执行
- 性能可能会受影响，可能会产生循环调用



- 当程序需要使用**不同方式处理不同种类**请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式
- 当必须**按顺序执行多个处理**者时， 可以使用该模式
- 所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式

例子：

- 过滤访问，对系统的访问限制：

  只允许认证用户创建订单；此外， 拥有管理权限的用户也拥有所有订单的完全访问权限；额外的验证步骤来清理请求中的数据；检查步骤来过滤来自同一 IP 地址的重复错误请求；对包含同样数据的重复请求返回缓存中的结果， 从而提高系统响应速度；

- java servlet过滤器

该模式在核心 Java 程序库中的一些示例：

- [`javax.servlet.Filter#doFilter()`](https://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-)
- [`java.util.logging.Logger#log()`](https://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log-java.util.logging.Level-java.lang.String-)

**识别方法：** 该模式可通过一组对象的行为方法间接调用其他对象的相同方法来识别， 而且所有对象都会遵循相同的接口



- [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)通常和[组合模式](https://refactoringguru.cn/design-patterns/composite)结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。

- [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)和[装饰模式](https://refactoringguru.cn/design-patterns/decorator)的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。

  [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种*装饰*可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。

  可以随时中断链的事实将“责任链”模式与“装饰者”模式区分开

