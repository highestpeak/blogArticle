# 观察者模式

亦称： 事件订阅者、 监听者、 Event-Subscriber、 Listener、 Observer

发布订阅的机制，该机制包括 

1. 一个用于存储订阅者对象引用的列表成员变量；
2. 几个用于添加或删除该列表中订阅者的公有方法

无论何时发生了重要的发布者事件， 它都要遍历订阅者并调用其对象的特定通知方法

注意：

- 订阅者的通知顺序是随机的



要点：

- 所有订阅者都必须实现同样的接口， 发布者仅通过该接口与订阅者交互。
  - 接口中必须声明通知方法及其参数， 这样发布者在发出通知时还能传递一些上下文数据
- 如果你需要在现有的类层次结构中应用该模式， 则可以考虑使用组合的方式： 将订阅逻辑放入一个独立的对象， 然后让所有实际订阅者使用该对象
- 

![](E:\_data\博文临时库\博文中的图片\观察者模式.png)



- 当一个对象状态的改变需要改变其他对象
- 当应用中的一些对象必须观察其他对象时， 可使用该模式
  - 但仅能在**有限时间内**或特定情况下使用

例子：

- 报纸订阅
- 当用户按下按钮时就会触发某些代码

察者模式在 Java 代码中很常见， 特别是在 GUI 组件中。 它提供了在不与其他对象所属类耦合的情况下对其事件做出反应的方式。

这里是核心 Java 程序库中该模式的一些示例：

- [`java.util.Observer`](https://docs.oracle.com/javase/8/docs/api/java/util/Observer.html)/[ `java.util.Observable`](https://docs.oracle.com/javase/8/docs/api/java/util/Observable.html) （极少在真实世界中使用）
- [`java.util.EventListener`](https://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html)的所有实现 （几乎广泛存在于 Swing 组件中）
- [`javax.servlet.http.HttpSessionBindingListener`](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html)
- [`javax.servlet.http.HttpSessionAttributeListener`](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionAttributeListener.html)
- [`javax.faces.event.PhaseListener`](https://docs.oracle.com/javaee/7/api/javax/faces/event/PhaseListener.html)

**识别方式：** 该模式可以通过将对象存储在列表中的订阅方法， 和对于面向该列表中对象的更新方法的调用来识别



# 中介者模式

亦称： 调解人、 控制器、 Intermediary、 Controller、 Mediator

限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作，中介者对象重定向调用行为



要点：

- 声明中介者接口并描述中介者和各种组件之间所需的交流接口

  在绝大多数情况下， 一个接收组件通知的方法就足够了。 如果你希望在不同情景下复用组件类， 那么该接口将非常重要。 只要组件使用通用接口与其中介者合作， 你就能将该组件与不同实现中的中介者进行连接

- 组件必须保存对于中介者对象的引用

  通常在组件的构造函数中建立

- 可以更进一步， 让中介者负责组件对象的创建和销毁。 此后， 中介者可能会与工厂或外观类似

![](E:\_data\博文临时库\博文中的图片\中介者模式类图.png)



- 当一些对象和其他对象紧密耦合以致难以对其进行修改时

- 当组件因过于依赖其他组件而无法在不同应用中复用时

- 为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式

  由于所有组件间关系都被包含在中介者中， 因此你无需修改组件就能方便地新建中介者类以定义新的组件合作方式

例子：

- 飞机场塔台：飞行器驾驶员们在靠近或离开空中管制区域时不会直接相互交流。 但他们会与飞机跑道附近， 塔台中的空管员通话。 如果没有空管员， 驾驶员就需要留意机场附近的所有飞机， 并与数十位飞行员组成的委员会讨论降落顺序。 那恐怕会让飞机坠毁的统计数据一飞冲天吧。

  塔台无需管制飞行全程， 只需在航站区加强管控即可， 因为该区域的决策参与者数量对于飞行员来说实在太多了

Java 程序库中该模式的一些示例：

- [`java.util.Timer`](https://docs.oracle.com/javase/8/docs/api/java/util/Timer.html) （所有 `schedule­XXX()` 方法）
- [`java.util.concurrent.Executor#execute()`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-)
- [`java.util.concurrent.ExecutorService`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html) （ `invoke­XXX()` 和 `submit­()` 方法）
- [`java.util.concurrent.ScheduledExecutorService`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html) （所有 `schedule­XXX()` 方法）
- [`java.lang.reflect.Method#invoke()`](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-)



一段时间后， 中介者可能会演化成为上帝对象



中介者模式、代理模式、外观模式的区别？

- [外观模式](https://refactoringguru.cn/design-patterns/facade)和[中介者](https://refactoringguru.cn/design-patterns/mediator)的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。
  - *外观*为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。
  - *中介者*将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。





# 中介者和观察者

观察者模式：定义对象之间的一对多依赖关系，以便当一个对象改变状态时，其所有依赖关系都将得到通知并自动更新。

中介者模式：定义一个对象，该对象封装了一组对象之间的交互方式。中介者通过防止对象之间显式地相互引用来促进松散耦合，并且它使您可以独立地更改它们之间的交互。



可以通过使用观察者模式来实现中介者模式



中介者和观察者都实现相同的目标，但是，中介者可以进行双向通信，而观察者只能单向通信



中介者更为具体，它避免让类直接进行通信，而是通过中介者进行通信。通过允许将通信卸载到只处理通信的类，这有助于单一职责原则

# 参考

