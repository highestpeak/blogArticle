> 性能调优

当编译器看到 synchronized关键字时，有可能会执行特殊的优化，甚至有可能会注意到这个程序是单线程的。编译器甚至可能会识别出 counter被递增的次数是固定数量的，因此会预先计算出其结果。

但是，突然间越过门槛值之后， synchronized关键字似乎变得非常低效，而Lock和 Atomic则显得大体维持着与 BaseLine测试之间的比例关系，因此也就变得比 synchronized关键字要高效得多

也就是说，很明显，使用Lock通常会比使用 synchronized要高效许多，而且 synchronized的开销看起来变化范围太大，而Lock相对比较一致。

互斥方法的方法体是非常之小的。通常，这是一个很好的习惯一—只互斥那些你绝对必须互斥的部分。但是，在实际中，被互斥部分可能会比上面示例中的那些大许多，因此在这些方法体中花费的时间的百分比可能会明显大于进入和退出互斥的开销，这样也就湮没了提高互斥速度带来的所有好处。

可读性至关重要。因此，以 synchronized关键字入手，只有在性能调优时才替换为Lock对象这种做法，是具有实际意义的。

Atomic对象只有在非常简单的情况下才有用，这些情况通常包括你只有一个要被修改的 Atomic对象，并且这个对象独立于其他所有的对象。更安全的做法是：以更加传统的互斥方式入手，只有在性能方面的需求能够明确指示时，再替换为 Atomic。



免锁容器

这些免锁容器背后的通用策略是：对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可。修改是在容器数据结构的某个部分的一个单独的副本（有时是整个数据结构的副本）上执行的。

在 CopyOn WriteArray List中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。当修改完成时，一个原子性的操作将把新的数组换入，使得新的读取操作可以看到这个新的修改。 Copyon WriteArrayList的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModification Exception，因此你不必编写特殊的代码去防范这种异常，就像你以前必须作的那样。

ConcurrentHashMap和 ConcurrentLinkedQueue使用了类似的技术

乐观锁

只要你主要是从免锁容器中读取，那么它就会比其 synchronized对应物快许多，因为获取和释放锁的开销被省掉了。如果需要向免锁容器中执行少量写入，那么情况仍旧如此，但是什么算“少量”？

从输出中可以看到， synchronized Array list无论读取者和写入者的数量是多少，都具有大致相同的性能—读取者与其他读取者竞争锁的方式与写入者相同。但是， CoplOn WriteArrayList在没有写入者时，速度会快许多，并且在有5个写入者时，速度仍旧明显地快。

乐观加锁

“乐观加锁”。意味着当你执行某项计算时，实际上没有使用互斥，但是在这项计算完成，并且你准备更新这个 Atomic对象时，你需要使用一个称为 compareAndSe0的方法。

如果 compareAndset失败，那么就必须决定做些什么，这是一个非常重要的问题，因为如果不能执行某些恢复操作，那么你就不能使用这项技术，从而必须使用传统的互斥。你可能会重试这个操作，如果在第二次成功，那么万事大吉；或者可能会忽略这次失败，直接结束—在某些仿真中，如果数据点丢失，在重要的框架中，这就是最终需要做的事情。

Read writelock

Read writelock对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。

Read writelock是否能够提高程序的性能是完全不可确定的，它取决于诸如数据被读取的频率与被修改的频率相比较的结果，读取和写入操作的时间（锁将更复杂，因此短操作并不能带来好处），有多少线程竞争以及是否在多处理机器上运行等因素。最终，唯一可以了解Read Writelock是否能够给你的程序带来好处的方式就是用试验来证明。



活动对象

有一种可替换的方式被称为<u>*活动对象或行动者。*</u>之所以称这些对象是“活动的”，是因为每个对象都维护着它自己的工作器线程和消息队列，并且所有对这种对象的请求都将进入队列排队，任何时刻都只能运行其中的一个。因此，<u>*有了活动对象，我们就可以串行化消息而不是方法*</u>，这意味着不再需要防备一个任务在其循环的中间被中断这种问题了

<u>*当你向一个活动对象发送消息时，这条消息会转变为一个任务，该任务会被插入到这个对象的队列中，等待在以后的某个时刻运行。*</u> Java Se的 <u>*Future*</u>在实现这种模式时将派上用场。下面是一个简单的示例，它有两个方法，可以将方法调用排进队列：

用submit敢O提交一个新的 Callable对象，以响应对这些方法的调用，这样就可以把<u>*方法调用转变为消息*</u>，而 submit0的方法体包含在匿名内部类的cal0方法中。注意，每个活动对象方法的返回值都是一个具有泛型参数的 Future，而这个泛型参数就是该方法中实际的返回类型

CopyonWrite ArrayList可以移除为了防止 ConcurrentModification Exception而复制List的这种需求。

任何传递给活动对象方法调用的参数都必须是只读的其他活动对象，或者是不连接对象（我的术语），即<u>*没有连接任何其他任务的对象*</u>

由于一个活动对象系统只是经由消息来通信，所以两个对象在竞争调用另一个对象上的方法时，是不会被阻塞的，而这意味着不会发生死锁。

将同步控制在消息级别上发生。

进憾的是，如果没有直接的编译器支持，上面这种编码方式实在是太过于麻烦了。但是，这在活动对象和行动者领域，或者更有趣的被称为<u>*基于代理的编程*</u>领域，确实产生了进步。代理实际上就是活动对象，但是代理系统还支持跨网络和机器的透明性。如果代理编程最终成为面向对象编程的继任者，我一点也不会觉得惊讶，因为它把对象和相对容易的并发解决方案结