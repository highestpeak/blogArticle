# 组合模式

亦称： 对象树、 Object Tree、 Composite



- **树状结构**：将对象组合成树状结构， 并且能像使用独立对象一样使用它们
- **调用后即开始树结构传递**：你无需了解构成树状结构的对象的具体类。 你也无需了解对象是简单的产品还是复杂的盒子。 你只需调用通用接口以相同的方式对其进行处理即可。 当你调用该方法后， 对象会将请求沿着树结构传递下去

![](E:\_data\博文临时库\博文中的图片\组合模式类图.png)



要点：

- **元素和容器**实现同一个相同通用接口

  其实组合模式就是类实现了接口，按照同一个接口来操作。但是增加了一个额外要求就是一个是简单元素，一个是容器，但是二者都实现了同一个接口。容器中可以包含简单元素和其他容器。 



如果你需要实现树状对象结构（分层次的对象结构）， 可以使用组合模式

希望客户端代码以相同方式处理简单和复杂元素，忽略对象组成和单个对象之间的差异， 可以使用该模式

例子

- 文件系统：文件和文件夹
- 产品和盒子，盒子里包含产品或盒子，计算产品总价
- 图形编辑器中实现一系列的几何图形，常用于表示与图形打交道的用户界面组件或代码的层次结构

 Java 标准程序库中的组合示例：

- [`java.awt.Container#add(Component)`](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#add-java.awt.Component-) （几乎广泛存在于 Swing 组件中）
- [`javax.faces.component.UIComponent#getChildren()`](https://docs.oracle.com/javaee/7/api/javax/faces/component/UIComponent.html#getChildren--) （几乎广泛存在于 JSF UI 组件中）

**识别方法：** 组合可以通过将同一抽象或接口类型的实例放入树状结构的行为方法来轻松识别。



# 装饰模式

亦称： 装饰者模式、 装饰器模式、 Wrapper、 Decorator

- 通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为

  即：为对象**包装新的行为**

- （有点像经过一个链条的所有动作，但不会和责任链一样在某个地方停下来）（对象将形成一个栈结构）

- 封装器包含与目标对象相同的一系列方法， 它会将所有接收到的请求委派给目标对象。但是， 封装器可以在将请求委派给目标前后对其进行处理， 所以可能会改变最终结果。



要点：

- 封装器实现了与其封装对象相同的接口

  因此从客户端的角度来看， 这些对象是完全一样的。 封装器中的引用成员变量可以是遵循相同接口的任意对象。 这使得你可以将一个对象放入多个封装器中， 并在对象中添加所有这些封装器的组合行为。

![](E:\_data\博文临时库\博文中的图片\装饰模式类图.png)



- **运行时为对象新增额外的行为**：如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式

- **装饰能将业务逻辑组织为层次结构**， 你可为各层创建一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象
- **继承难以实现扩展行为**：如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式
  - **复用最终类**：许多编程语言使用 `final`最终关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装

例子：

- 消息通知示例：不同类型的消息需要使用不同的通知器组合来通知

- 穿衣服是使用装饰的一个例子：

  觉得冷时， 你可以穿一件毛衣。 如果穿毛衣还觉得冷， 你可以再套上一件夹克。 如果遇到下雨， 你还可以再穿一件雨衣。 所有这些衣物都 “扩展” 了你的基本行为， 但它们并不是你的一部分， 如果你不再需要某件衣物， 可以方便地随时脱掉

- 加密和压缩数据

  - 当数据即将被**写入磁盘**前， 装饰对数据进行加密和压缩。 在原始类对改变毫无察觉的情况下， 将加密后的受保护数据写入文件。
  - 当数据刚**从磁盘读出**后， 同样通过装饰对数据进行解压和解密。 装饰和数据源类实现同一接口， 从而能在客户端代码中相互替换

- 计时：（例子来源于[StackOverflow](https://stackoverflow.com/questions/1549743/when-to-use-the-decorator-pattern?noredirect=1&lq=1)）

  我最近在Web服务中使用了装饰器模式，该服务使用以下CommandProcessor接口：

  ```java
  public Command receive(Request request);
  public Response execute(Command command);
  public void respond(Response response);
  ```

  基本上，CommandProcessor接收请求并创建适当的命令，执行命令并创建适当的响应，然后发送响应。当我想添加计时并将其记录时，我创建了一个TimerDecorator，它使用现有的CommandProcessor作为其组件。TimerDecorator实现了CommandProcessor接口，但是只是添加了计时，然后调用了它的目标，即真正的CommandProcessor。像这样：

  ```java
  public class TimerDecorator implements CommandProcessor {
     private CommandProcessor target;
     private Timer timer;
  
     public TimerDecorator(CommandProcessor processor) {
        this.target = processor;
        this.timer = new Timer();
     }
  
     public Command receive(Request request) {
        this.timer.start();
        return this.target.receive(request);
     }
  
     public Response execute(Command command) {
        return this.target.execute(command);
     }
  
     public void respond(Response response) {
        this.target.response(response);
        this.timer.stop();
        // log timer
     }
  
  }
  ```

  因此，真正的CommandProcessor包装在TimerDecorator中，我可以像对待目标CommandProcessor一样对待TimerDecorator，但现在已添加了计时逻辑。

装饰在 Java 代码中可谓是标准配置， 尤其是在与**流式加载**相关的代码中。

Java 核心程序库中有一些关于装饰的示例：

- [`java.io.InputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html)、 [`Output­Stream`](https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html)、 [`Reader`](https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html) 和 [`Writer`](https://docs.oracle.com/javase/8/docs/api/java/io/Writer.html) 的所有代码都有以自身类型的对象作为参数的构造函数。
- [`java.util.Collections`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html)； [`checked­XXX()`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#checkedCollection-java.util.Collection-java.lang.Class-)、 [`synchronized­XXX()`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedCollection-java.util.Collection-) 和 [`unmodifiable­XXX()`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableCollection-java.util.Collection-) 方法。
- [`javax.servlet.http.HttpServletRequestWrapper`](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequestWrapper.html) 和 [`Http­Servlet­Response­Wrapper`](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponseWrapper.html)

**识别方法：** 装饰可通过以当前类或对象为参数的创建方法或构造函数来识别。



优缺点：

- 对象行为更加灵活：

  - 无需创建新子类即可扩展对象的行为
  - 可以在运行时添加或删除对象的功能
  - 可以用多个装饰封装对象来组合几种行为

- 拆分大类的不同行为：

  [单一职责原则](https://refactoringguru.cn/didp/principles/solid-principles/srp)。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类

- 使用聚合或组合，避免继承：

  - 继承是静态的，无法在运行时更改已有对象的行为
  - 子类只能有一个父类，很多语言不允许一个类同时继承 多个类，所以也就不能继承他们的行为

- **删除困难**：在封装器栈中删除特定封装器比较困难。
- **装饰顺序**：实现行为不受装饰栈顺序影响的装饰比较困难。
- **初始化丑陋**：各层的初始化配置代码看上去可能会很糟糕





# 与其他设计模式

与其他设计模式：

使用[迭代器模式](https://refactoringguru.cn/design-patterns/iterator)来遍历[组合](https://refactoringguru.cn/design-patterns/composite)树

使用[访问者模式](https://refactoringguru.cn/design-patterns/visitor)对整个[组合](https://refactoringguru.cn/design-patterns/composite)树执行操作

使用[享元模式](https://refactoringguru.cn/design-patterns/flyweight)实现[组合](https://refactoringguru.cn/design-patterns/composite)树的共享叶节点以节省内存



[装饰](https://refactoringguru.cn/design-patterns/decorator)可让你更改对象的外表， [策略模式](https://refactoringguru.cn/design-patterns/strategy)则让你能够改变其本质

[装饰](https://refactoringguru.cn/design-patterns/decorator)和[代理](https://refactoringguru.cn/design-patterns/proxy)有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于*代理*通常自行管理其服务对象的生命周期， 而*装饰*的生成则总是由客户端进行控制



组合和装饰

[组合](https://refactoringguru.cn/design-patterns/composite)和[装饰模式](https://refactoringguru.cn/design-patterns/decorator)的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象

装饰类似于组合， 但其只有一个子组件。也就是说组合有一个容器（持有很多元素），而装饰没有容器（只持有一个元素）。

好像是一个是横向的，一个是纵向递归的。

 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了“求和”，旨在将多个对象合并并表示为单个对象（相同基本类型）（即1到很多）

但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为

大量使用[组合](https://refactoringguru.cn/design-patterns/composite)和[装饰](https://refactoringguru.cn/design-patterns/decorator)的设计通常可从对于[原型模式](https://refactoringguru.cn/design-patterns/prototype)的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造



组合、装饰、责任链

[责任链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)通常和[组合模式](https://refactoringguru.cn/design-patterns/composite)结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部

[责任链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)和[装饰模式](https://refactoringguru.cn/design-patterns/decorator)的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。

[责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种*装饰*可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。



# 参考

> 1. [refactoringguru: composite](https://refactoringguru.cn/design-patterns/composite)
> 2. 

