#### Redis相关

- :white_check_mark: ❌Redis 特点，❌Redis 为什么这么高效，使用的场景是什么
- :white_check_mark:❌Redis 底层数据结构：跳表，字典，数据类型，Redis 的集合有没有限制，限制是多少。五种基本类型。List有哪些操作，Redis能存哪些类型，Redis的hash算法用的是啥
- :white_check_mark:❌数据淘汰策略
- :white_check_mark:❌IO模型，❌Redis是单线程还是多线程
- :white_check_mark:❌持久化方式：AOF，RDB，❌Redis能把内存空间交换进磁盘中吗
- :white_check_mark:❌哨兵模式 ❌高可用
- ❌集群同步方式，集群的原理❌Redis集群方案
- ❌Redis 的1w条的插入和更新有什么区别
- :white_check_mark:❌Redis 和数据库的一致性问题
- :white_check_mark:❌用HashMap实现Redis有什么问题
- ❌Redis hash算法

Redis(Remote Dictionary Server) 

- C 语言编写的
- NoSQL：非关系型的键值对数据库
- 内存中的（读写速度非常快）（缓存）
- 单线程
- 多路 I/O 复用模型，非阻塞 IO
- 底层不一样，（可以说和操作系统的交互不一样，因为使用c语言实现的）

存储键值对，键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。键有过期时间

一些基本的操作，例如crud基本上都是支持的，用的时候去查就可以了，感觉不用记

| 数据类型 | 可以存储的值           | 操作                                                         | 应用场景                   |
| -------- | ---------------------- | ------------------------------------------------------------ | -------------------------- |
| STRING   | 字符串、整数或者浮点数 | 字符串操作，数增减                                           | 做简单的键值对缓存         |
| LIST     | 列表                   | list操作，形同双端队列（从两端压入或者弹出元素），对index范围的操作（或取、修剪） | 列表型的数据结构           |
| SET      | 无序集合               | set操作，交并补运算                                          |                            |
| HASH     | 包含键值对的无序散列表 | （形如json？）                                               | 结构化的数据，比如一个对象 |
| ZSET     | 有序集合               |                                                              | 去重、排序                 |

Redis 经常用来做分布式锁。Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。

缺点：

- 容量受到内存限制，不能用作海量数据高性能读写，适用于较小数据量的高性能操作和运算上
- ？ 不具备自动容错和恢复
- ？ 难支持在线扩容

内存数据库的特点赋予了：

- 高性能：因为较少了磁盘IO，提高了访问速度
- 高并发：内存承受的请求是远大于磁盘的，很多请求可能到达不了数据库



用HashMap实现Redis有什么问题？为什么要用 Redis 而不用 map/guava 做缓存？

- 缓存分为本地缓存 map/guava和分布式缓存Redis
- 本地缓存：
  - 轻量以及快速
  - 生命周期随着 jvm 的销毁而结束
  - 多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性
- 分布式缓存：
  - 各实例共用一份缓存数据，缓存具有一致性
  - 程序架构上较为复杂，需要保持高可用



Redis为什么这么快？ 为什么这么高效？

- 基于内存
- 数据结构简单，数据操作简单，专门的数据结构优化
  - 形如map的查找和操作的时间复杂度都是O(1)
- 单线程，避免了不必要的上下文切换（线程切换耗CPU）和竞争条件（加锁和释放锁）
- 多路 I/O 复用模型
- 底层实现方式、与客户端之间通信的应用协议、系统调用等的优化和专门设计



持久化：

把内存的数据写到磁盘中去

两种持久化机制 RDB（默认） 和 AOF 机制:

- RDB（Redis DataBase）：**周期性**以快照的形式保存到硬盘中，快照的周期由配置文件指定
  - 是会启用子进程来持久化
  - 性能好
- AOF（Append Only File）：执行的**每次**写命令记录到单独的日志文件中，
  - AOF文件大，相对于`RDB`方式，`AOF`方式的持久化**更细粒度**
  - AOF又可以配置为`always`即实时将记录写到AOF文件中，`everysec`每隔一秒将记录写到AOF文件中，`no`由系统决定何时将记录写到AOF文件中。



数据淘汰策略，过期删除策略

设置Redis中缓存的key的过期时间

- 定时过期：从键被置入开始到结束有一个固定时间

- 定期过期：每隔一定的时间扫描（从系统启动开始）

- 惰性过期：只有当访问一个key时，才会判断该key是否已过期

  可调整定时扫描的时间间隔和每次扫描的限定耗时

Redis中同时使用了惰性过期和定期过期两种过期策略

需要在CPU和内存之间折衷

定时过期：对内存很友好，会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量

惰性过期：大量的过期key没有再次被访问，从而不会被清除，占用大量内存



Redis内存优化：

- 使用合适的数据结构，降低内存使用



Redis线程模型：

Redis处理网络请时候的求单线程可以抽象成这样，通向Redis的路只有一条，且这条路是个单车道，只容的下一辆车同时使用，而我们使用的Redis命令即为这些车辆，当我们执行多个命令的时候，只有等第一个命令执行完成了后面的命令才会执行，否则会一直处于等待状态。
Redis单线程的架构需要我们注意几点
a. 一次只运行一条命令
b. 拒绝长（慢）命令（keys、flushall、flushdb、slow lua script、mutil/exec、operate、big value）
至于为什么单线程还这么快，这里有个原因，Redis客户端的到Redis服务器的网络请求采用了**多路I/O复用模型（非阻塞I/O）**，利用`select`、`poll`、`epoll`可以**同时监听多个流的I/O(客户端到服务器的网络请求)事件的能力**，在空闲的时候，会把当前线程阻塞掉，当有一个或者多个流有`I/O`事件时，就从阻塞态中唤醒，**轮训一遍所有的流**并且依次处理就绪的流。这样就算出现有的流的`I/O`因为网络原因很慢，也不会影响别的流的`I/O`（非阻塞），因为是轮训所有的流的`I/O`。这里的**“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**



心跳检测（哨兵模式）：

就是心跳机制，在主服务器挂掉之后，将一个从服务器反客为主的一系列动作自动化，不用手动操作，在主服务器挂掉之后，自动选举新的主服务器，这个用于保持高可用





与数据库的一致性问题：

Redis只用作cache，写请求只交给MySQL处理，之后通知redis对应的缓存失效，去数据库缓存新数据。

（没这么简单，但是先这么答着，没时间了）



缓存异常：

缓存预热，缓存击穿，缓存穿透，

缓存雪崩：缓存同一时间大面积的失效，请求都落到数据库，引起数据库崩溃

- 缓存过期时间设置随机，防止同一时间
- 小并发量，加锁**排队**
- 失效标记，来定时更新（其实是内置的，本身的防止雪崩的机制）

缓存穿透：缓存和数据库中都没有数据，请求都落到数据库，引起数据库崩溃

- 增加校验，过滤不合理请求，不去查找数据库

- 在第一次没有的数据请求后，将key-value对写为key-null

  即从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null

- 布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，然后提前过滤

缓存击穿：缓存中没有但数据库中有数据（一般是缓存时间到期）

- 缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库
- 其实是这个所谓的同一条数据就是热点数据？，则设置热点数据永远不过期

缓存预热：

- 系统启动时预热加载
- 定时刷新

其他缓存异常：

热点数据和冷数据，缓存降级

缓存降级的最终目的是保证核心服务可用

热点数据尽量的缓存，其实这个和计算机底层的高速缓存机制类似，都是要把经常用的尽可能的放到最近的地方



其他问题，暂时不看

Redis延时队列、异步队列、值的最大所占空间、固定前缀查找类似的模式查找、性能和解决方案、分布式锁、分区、分片、多核CPU利用、集群搭建--主从架构--分布式