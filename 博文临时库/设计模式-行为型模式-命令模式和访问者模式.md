# 命令模式

亦称： 动作、 事务、 Action、 Transaction、 Command

命令模式做了这么一件事：原先当你调用一个方法a（请求）的时候，方法a（请求）中可能会使用A、B、C等多个对象或者还有其他东西。现在把调用方法a的这个请求转换成一个对象，该对象中包含了所有方法a（请求）需要的信息，所以说是把方法参数化。

需要向对象发出请求，而又不知道有关所请求的操作或请求的接收者的任何信息

这样做就带来了一系列额外的使用方法，即：

- 将方法参数化
- 延迟请求执行或将其放入队列
- 实现可撤销操作

命令的执行者根本不需要知道什么是命令，命令所需要的上下文信息或执行的操作。所有这些都封装在命令中





要点：

- 仅有一个没有任何参数的执行方法的命令接口
  - 这样不和具体命令类耦合
  - 这样也能在运行时切换连接至发送者的命令对象， 以此改变发送者的行为

- 请求的参数：使用数据对命令进行预先配置， 或者让其能够自行获取数据

  - 每个类都必须有一组成员变量来保存请求参数和对于实际接收者对象的引用。所有这些变量的数值都必须通过命令构造函数进行初始化。

- 顺序：

  - 创建接收者
  - 创建命令， 如有需要可将其关联至接收者
  - 创建发送者并将其与特定命令关联

  *客户端*调用*Invoker* => *Invoker*调用`ConcreteCommand` => `ConcreteCommand`调用*Receiver*方法，该方法实现了抽象的*Command*方法

![](E:\_data\博文临时库\博文中的图片\命令模式类图.png)







- 将方法参数化，即将命令作为方法的参数进行传递
- 延迟请求执行或将其放入队列，调度命令执行，远程执行命令，存储和序列化命令，重复命令
  - 序列化命令：即转换成字符串，使用同样的方式， 你还可以将命令放入队列、 记录命令或者通过网络发送命令
- 实现可撤销操作，操作回滚，维护命令历史
- 运行时切换已连接的命令
- 简单命令组合成复杂命令
- 回调函数
- 解耦命令的发送者和接收者

例子：

- 文字编辑器很多地方要用到button，点击不同的button会有不同操作，因此就需要把button和操作分离
- 封装异步操作，并保存参数和上下文

命令模式在 Java 代码中很常见。 大部分情况下， 它被用于代替包含行为的参数化 UI 元素的回调函数， 此外还被用于对任务进行排序和记录操作历史记录等。

以下是在核心 Java 程序库中的一些示例：

- [`java.lang.Runnable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html) 的所有实现
- [`javax.swing.Action`](https://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html) 的所有实现

**识别方式：** 命令模式可以通过抽象或接口类型 （发送者） 中的行为方法来识别， 该类型调用另一个不同的抽象或接口类型 （接收者） 实现中的方法， 该实现则是在创建时由命令模式的实现封装。 命令类通常仅限于一些特殊行为

使用多线程时：如果操作所需的所有数据都封装在命令对象中，则很容易将命令移至另一个线程并在那里执行，而不会在共享对象之间遇到通常的锁定难题线程。创建命令，将所需的所有内容传递给它（复制，不通过引用），传递给其他线程，仅在接收到结果时进行同步，完成

# 访问者模式

亦称： Visitor

将算法与其所作用的对象隔离开。访问者模式建议将新行为放入一个名为*访问者*的独立类中， 而不是试图将其整合到已有类中。

[为什么使用accept: 访问者和双分派](https://refactoringguru.cn/design-patterns/visitor-double-dispatch)



要点：

- 访问者接口中声明一组 “访问” 方法， 分别对应程序中的**每个具体元素类**
  -  每次在元素层次结构中添加或移除一个类时， 你都要更新所有的访问者
- 声明元素接口：
  - 如果程序中已有元素类层次接口， 可在层次结构基类中添加抽象的 “接收” 方法
  - “接收” 方法**必须接受访问者**对象作为参数
- 元素类只能通过访问者接口与访问者进行交互

![](E:\_data\博文临时库\博文中的图片\访问者模式.png)





- 需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式

- 使用访问者模式来清理辅助行为的业务逻辑：

  将所有非主要的行为抽取到一组访问者类中， 使得程序的主要类能更专注于主要的工作

- 当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时， 可使用该模式

  将该行为抽取到单独的访问者类中

- 要向层次结构添加一个新操作

- > What it actually does is implement [double dispatching](http://en.wikipedia.org/wiki/Double_dispatch) in languages that don't support it natively (most of them don't)

  实际上就是在不支持双分派的语言上实现双分派

- 访问者可让您定义新操作，而无需更改其所操作元素的类，即后续如果需要添加新的方法，只需要实现新的访问者

- 模式匹配

- 将数据与算法分开。您将算法卸载到访问者实现中。您可以通过创建*更多*访问者来添加功能，而不是不断修改（和膨胀）保存数据的类

例子：

- 目录树，XML结构，或文档大纲“递归”结构



与其他模式：

将[访问者模式](https://refactoringguru.cn/design-patterns/visitor)视为[命令模式](https://refactoringguru.cn/design-patterns/command)的加强版本， 其对象可对不同类的多种对象执行操作 ？？？

同时使用[访问者](https://refactoringguru.cn/design-patterns/visitor)和[迭代器模式](https://refactoringguru.cn/design-patterns/iterator)来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同



参考

1. [stackoverflow: When should I use the Visitor Design Pattern?](https://stackoverflow.com/questions/255214/when-should-i-use-the-visitor-design-pattern)
2. [StackOverflow: Visitor pattern's purpose with examples](https://stackoverflow.com/questions/2604169/visitor-patterns-purpose-with-examples)
3. [《JAVA与模式》之访问者模式](https://www.cnblogs.com/java-my-life/archive/2012/06/14/2545381.html)

