❌✔️

1. ✔️TCP UDP IP、握手、TCP流量控制、拥塞控制、快速重传
2. ✔️零碎、DNS、大小端
3. ✔️协议栈、及其常见协议、osi模型
4. ✔️https算法、http协议、ARP协议、http建立流程
5. ✔️http状态码、200、206
6. ❌从输入URL到页面加载，发生了什么； ❌游览器与server的TCP连接
7. ✔️get、post
8. ❌线程间通信和进程间通信
9. ❌socket编程(网络编程)
10. ❌跨域问题、同源策略
11. ✔️cookie和session



# TCP UDP IP

三部分：传输层和网络层关系、可靠通信、拥塞控制

> 传输层和网络层

传输层协议是在端系统中，不是在路由器中，报文段segment。因特网有两种传输层协议TCP UDP，但传输层不止这两个协议（非因特网）。

网络层IP协议，不做任何确保，不可靠服务。

网络层提供主机到主机，运输层提供进程到进程。即使网络层不可靠，运输层也能提供可靠传输，即使网络层不安全，运输层也能提供加密。

TCP UDP的**最基本责任**是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机交付扩展到进程交付被称为传输层的**多路复用和多路分解**。TCP UDP都提供进程到进程的**数据交付、差错检查**。UDP不可靠，不保证进程发送的数据完整无缺地到达目标进程，可以以任意速率发送数据。TCP额外提供了**可靠数据传输**（流量控制、序号、确认、定时器）保证正确有序的进程到进程交付；还额外提供了**拥塞控制**（调节发送端的发送流量速率）。

---

多路复用和多路分解：主机的传输层报文和套接字之间的关系。在发送端收集套接字的数据，为数据封装首部信息生成报文段，传递报文段到网络层，这是多路复用。在接收端，检查保温字段，表示出接受套接字，交付到正确的套接字，这是多路分解。（<u>*todo: 传输层报文结构图*</u> 源端口号、目的端口号、共32比特）（0~1023周知端口号）

UDP套接字由一个二元组（目的IP地址、目的端口号）组成，源主机通过bind绑定本机的UDP发送端口。如果两个UDP报文段有不同的源IP地址和/或源端口号，但有着相同的目的IP地址和目的端口号，这面哥哥报文段将通过相同的目的套接字被定向到相同的目的进程。TCP套接字是一个四元组（源IP地址、源端口号、目的IP地址、目的端口号）。

注意：<u>*套接字和传输层报文有区别。注意传输层报文（图3-3）、TCP传输层报文、UDP传输层报文（图3-7）的结构!! todo: 图*</u>

游览器和web服务器建立http连接时都是访问80目的端口，但是服务器能够根据源IP地址和源端口来区分不同客户的报文段，因此IP地址在TCP的传输层是有用的，并不是只是在网络层有用。

---

选用UDP基本上差不多就是直接与IP打交道，最低限度的提供了复用/分解服务，从网络层向应用级进程传递数据。UDP的特点和部分应用适合UDP的原因：1. 关于何时、发送什么数据的应用层控制更为精确（实时应用一般不希望过分延迟报文段发送，但TCP拥塞控制可能会阻止发送） 2. UDP无需连接建立（不会引入连接建立过程） 3. UDP无连接状态（不维护连接状态，一般能支持更多的活跃用户） 4. UDP分组首部开销小

<u>*todo: 流行的因特网应用及其应用层、传输层协议 图表 图3-6*</u>

然而出于安全原因，某些机构阻塞UDP流量。并且如果大量的UDP报文发送到同一台路由器，路由器会有大量分组溢出，乃至于没有任何分组到达目的地。但是在应用层是可以构建基于UDP的可靠数据传输，虽然需要大量调试。

udp校验和计算暂时略过，

UDP提供了差错检测，但是对差错恢复无能为力。提供差错检测的原因：（链路传输出错、内存比特出错）暂时略过。

---

可靠数据传输：rdt系列、回退N步、选择重传，暂时略过。

---

TCP

中间路由器对TCP连接完全视而不见，他们看到的只是数据报而不是连接，TCP是点对点的，不能实现多播。TCP发送数据的流程（注意发送缓存） <u>*todo:图3-28*</u>

TCP序号确认号码（累积确认）、往返时间估计与超时 暂时略过

>  TCP可靠数据传输。

IP不保证数据报的交付，不保证数据报的按序交付，也不保证数据报中数据的完整性。但是TCP提供了这些。

三种数据传输的情况，3.5.4 第一种情况：发送方A向B发送一个数据，但是B返回的确认消息丢失，超时事件导致A重传相同的报文段，B接收到重传会通过序号判断已经收到从而丢弃这些数据并返回确认。第二种情况：发送方A向B发送了两个报文段，B完好的接收了两个报文并且传回两个确认，但是两个确认都丢失，发送方A超时后重传第一个报文段，如果在第二个报文段重传之前接收到B的确认ack那么A将不会重传第二个报文段。第三种情况：与第二种情况相同，但是第一个报文段的确认丢失，第二个报文段的确认没有丢失，则主机A不会重传。

超时间隔加倍：超时事件触发。快速重传：超时时间发生之前，检测3个冗余ACK来执行快速重传。

> 流量控制

消除发送方使接收方缓存溢出的可能性，流量控制是速度匹配服务，对发送方遏制，发送方维护一个接收窗口来提供流量控制，rwnd = rcvbuffer - [ lastbytercvd-lastbyteread];

> 连接管理（建立和拆除TCP连接）

连接建立

1. SYN报文段：客户端向服务端发送报文：标志位SYN=1，seq=client_isn随机初始序号
2. SYNACK报文段：分配TCP缓存和变量，服务端向客户端发送报文：标志位SYN=1，seq=server_isn随机，ack=client_isn+1确认号
3. 连接建立：客户端分配缓存和变量，客户端向服务端发送报文，标志位SYN=0，seq=client_isn+1,ack=server_isn+1

连接终止

1. 客户端发送报文到服务端： FIN=1
2. 服务端发送报文给客户端：ACK
3. 服务端发送终止报文：FIN=1
4. 客户端发送给服务端：ACK

> 拥塞控制

慢启动：cwnd=1 MSS 开始每次进行翻倍，

拥塞避免：cwnd在到达上一次ssthresh慢启动阈值之后，每次增加1个MSS

快速恢复：cwnd=cwmd/2+3

慢启动终止：超时事件则将cwnd重置为1，3个冗余ACK执行快速重传，到达ssthresh阈值进入拥塞避免

阈值的变化只会在超时事件发生，丢包事件后置为当前cwnd的一半

---

IP

# ARP

每台主机或路由器在内存中都有一个ARP表，包含了IP地址到MAC地址的对应以及一个寿命TTL值，不必为子网内每台主机和路由器包含一个表项。

查询子网内部指定IP的MAC地址：查询方构造MAC地址为广播地址FF-FF-FF-FF-FF-FF的ARP查询分组，向子网内所有适配器广播，每个适配器进行检测，如果某一个适配器IP地址和查询的相同，那么他就返回给查询主机一个 IP地址和MAC地址映射的ARP分组。

查询子网外部MAC地址：发送方向路由器本子网的适配器发送数据（采用ARP获得该适配器的MAC地址），路由器查询本身的内部表寻找和下一个子网相连的适配器，路由器的第二个适配器向接收方发送数据（同样采用ARP获得MAC）

学习ARP应当注意链路层交换机，暂时略过

# 零碎

- dns缓存可以减少查询流量
- 网络传输采用 大端
- 五层结构：应用层（http、smtp、ftp、dns、DHCP）、传输层（tcp、udp）、网络层（ip 32位ip地址、路由选择协议）、链路层（MAC协议 6字节mac地址、ARP协议）、物理层
- osi七层结构：应用层、表示层、会话层、传输层、网络层、链路层、物理层
- 特殊网络组件：DHCP服务器、DNS服务器、邮件服务器、web服务器、web缓存器（代理服务器）（条件get方法）、

# http https

> http建立连接

开始为tcp三次握手，并在最后一次握手包含http报文

> 状态码

分为五类：信息响应(`100`–`199`)，成功响应(`200`–`299`)，重定向(`300`–`399`)，客户端错误(`400`–`499`)和服务器错误 (`500`–`599`)

常用状态码

- 200 - 请求成功
- 301 - 资源（网页等）被永久转移到其它URL
- 404 - 请求的资源（网页等）不存在
- 500 - 内部服务器错误

> https

解释的好文：

- 阮一峰 ssl/tls 解释 http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html
- 对称非对称加密解释 https://juejin.im/post/5b38dc2de51d455eff37ec5f

https就是在应用层http和网络层tcp之间多了一个步骤ssl/tls加密，就是http把信息交给ssl/tls加密，然后ssl/tls交给tcp进行传输。

握手涉及四次通信：

1. 客户端发出请求，包含：支持加密协议版本、支持的加密方法、支持的压缩方法、生成的随机数a

2. 服务器回应请求，包含：确认加密协议版本、确认的加密方法、服务器证书（包含公钥）、生成的随机数b

3. 客户端回应，包含：握手结束通知，编码改变通知，一个随机数c（使用公钥加密）（客户端此时拥有三个随机数，利用这三个随机数生成对称加密的密钥）

   客户端接收到2中服务器的回应后，首先确认证书是否可信、证书中域名和实际域名是否一致、证书是否过期，不满足则向访问者发出警告

1. 服务器最后回应，包含：编码改变通知，握手结束通知。（此过程服务器使用自己的私钥计算出第三个随机数，根据所有三个随机数计算对称加密的密钥）

> cookie和session：

Session是在**服务端保存**的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
Cookie是**客户端保存**用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。
https://www.zhihu.com/question/19786827

> get、post

get信息保存在url中、post没有在url中显示；get可以被缓存、post不可被缓存；get只能发送ascii字符、post可以发送二进制数据。

# 跨域问题、同源策略

如果没有同源策略，B网站是可以直接请求A网站的接口的，有一些比如个人信息，他就可以通过get等方法，获得到你的信息，甚至可以post等操作去修改你的信息，这样你的账户安全是受到很严重的威胁的。所以浏览器需要同源策略来保证一定的**安全**，攻击手段例如CSRF和XSS，

CORS是一个W3C标准，全称是”**跨域资源共享**”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出[`XMLHttpRequest`](http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)请求，从而克服了AJAX只能[同源](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制。CORS需要浏览器和服务器同时支持。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动**添加一些附加的头信息**，有时还会多出一次附加的请求，但用户不会有感觉。**实现CORS通信的关键是服务器**。只要服务器实现了CORS接口，就可以跨源通信。

