每向对话框中添加一个新的工厂方法，你就离抽象工厂模式更近一步

# 引入/Magic Word

有许多术语看上去相似，但是含义不同，许多人没有意识到这一点， 从而出现了混淆和误解。尽管在互联网上找的到这些术语的参考信息，但是还是有必要放在一起说一下。术语如下：

- 工厂 (Factory)
- 构建方法 (Creation method)
- 静态构建 （或工厂） 方法 (Static creation (or factory) method)
- 简单工厂 (Simple factory)
- 工厂方法 (Factory Method)
- 抽象工厂 (Abstract Factory)

> 工厂 (Factory)

这个概念很模糊，不是很明确，工厂可以为 类、函数、方法，只是它们都创建一些东西。工厂的具体概念需要从上下文来判断。

> 构建方法 (Creation method)

构建方法是“创建对象的方法”，这意味着每个工厂方法模式的结果都是 “构建方法”， 但反过来则并非如此。 

在实际中， 构建方法只是**构造函数调用的封装器**。 它可能只是一个能更好地表达意图的名称。 此外， 它可以让你的代码独立于构造函数的改动， 甚至还可以**包含一些特殊的逻辑**， 返回已有对象以而不是创建新对象。

许多人会仅仅因为这些方法创建了新对象而称之为 “工厂方法”，但当它们遇到真正的工厂方法是会就会造成很多困惑。

如下，`next`是一个构建方法

```java
class Number {
    private $value;

    public function __construct($value) {
        $this->value = $value;
    }

    public function next() {
        return new Number ($this->value + 1);
    }
}
```

> 静态构建 （或工厂） 方法 (Static creation (or factory) method)

静态构建方法只是被声明为`static`的构建方法。

不要因为某些人将这些方法称为 `静态工厂方法` 而被其迷惑。 这种称呼只是一个坏习惯。 **工厂方法是一种依赖于继承的设计模式。 如果将它设置为 `static` ， 就不能在子类中对其进行扩展， 这就破坏了该模式的目的**

> 简单工厂 (Simple factory)

简单工厂模式描述了一个函数， 它拥有一个包含**大量条件语句**（if/else或者switch）的构建方法， 可根据方法的参数来选择对何种产品进行初始化并将其返回

简单工厂**通常没有子类**， 但当从一个简单工厂中抽取出子类后， 它看上去就会更像经典的工厂方法模式了，所以可以说工厂方法模式是从简单工厂进一步抽象来的。

如果编写大量的switch case语句，当添加新的类的时候就会添加很多新的case，这改动了原来的代码，违反了开闭原则，但是工厂方法模式就没有这个顾虑，因为它使用了继承。

一个简单工厂如下：

``` java
class UserFactory {
    public static function create($type) {
        switch ($type) {
            case 'user': return new User();
            case 'customer': return new Customer();
            case 'admin': return new Admin();
            default:
                throw new Exception('传递的用户类型错误。');
        }
    }
}
```

> 其他

工厂方法和抽象工厂在下面再介绍

# 工厂设计模式

## 工厂方法

在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型

如果需要向应用中添加一种新产品，只需要开发新的创建者子类，然后在子类中重写工厂方法，并将基本方法中的相关创建代码移动到工厂方法中

乍看之下，这种更改可能毫无意义：我们只是改变了程序中调用构造函数的位置而已。但是，仔细想一下，现在你可以在子类中重写工厂方法，从而改变其创建产品的类型。

注意有几个要点：

- **更改new语句位置：**将创建对象的代码用基类工厂的一个方法进一步封装起来
- **子类工厂继承：**基类工厂、子类工厂继承基类，重写创建对象的方法以提供不同实现
- **实现同一个接口：** 创建的对象应当实现同一个接口（或具有相同基类，虽然这样写不好）

![](E:\_data\博文临时库\博文中的图片\工厂方法类图.png)

> 优点

- 避免创建者和具体产品之间的紧密**耦合**
- **单一职责原则**，产品创建代码放在程序的单一位置，从而使得代码更容易维护
- **开闭原则**，无需更改现有客户端代码，你就可以在程序中引入新的产品类型

> 问题

- 应用该模式需要引入许多新的子类，代码可能会因此变得更复杂。

  - 如果应用中的产品类型太多，那么为每个产品创建子类并无太大必要，这时你也可以在子类中复用基类中的控制参数

    `陆路邮件`可能会同时使用`卡车`和`火车`对象。可以编写新的子类（例如`火车邮件`）来处理这两种情况，但是还有其他可选的方案。

    客户端代码可以给`陆路邮件`类传递一个参数，用于控制其希望获得的产品

- 可能需要在工厂方法中添加临时参数来控制返回的产品类型，这样就会可能有大量的switch语句用于选择各种需要实例化的产品类，进而代码看上去可能非常糟糕

- 基于继承

## 抽象工厂

创建一系列相关的对象，而无需指定其具体类，（一系列接口的组合）

几个要点：

- 为所有产品声明抽象产品接口。然后让所有具体产品类实现这些接口
- 声明抽象工厂接口，并且在接口中为所有抽象产品提供一组构造方法，为每种产品系列实现一个实体工厂类
- 在应用程序中开发初始化代码。该代码根据应用程序配置或当前环境，对特定实体工厂类进行初始化。然后将该工厂对象传递给所有需要创建产品的类 <u>*todo:（是否只是特定环境下的使用？）*</u>
- 几个重要的组成：`AbstractFactory`，`ConcreteFactory`，`AbstractProduct`，`ConcreteProduct`和`Client`
  - Client创建抽象工厂的具体实现，然后使用通用接口创建属于对象系列的具体对象
  - Client**不知道**或不在乎它们从这些具体工厂中获得哪个**具体对象**，因为客户仅使用其产品的通用接口

![](E:\_data\博文临时库\博文中的图片\抽象工厂类图.png)

> 例子

> 优点

- 保同一工厂生成的产品相互**匹配**，是同一**系列**，保证产品之间的**一致性**

  这带来的另外一个优点：

  **轻松交换产品系列**：具体工厂的类在应用程序中仅出现一次，即在实例化的地方。这使得更改应用程序使用的具体工厂变得容易。只需更改抽象工厂实现，即可使用各种产品配置。由于抽象工厂创建了完整的产品系列，因此整个产品系列会立即更改

- **不需要了解具体类**的信息，只需要关注具体类最高层的接口：

  在没有抽象工厂的情况下，客户需要了解具体类的详细信息。这种紧密的耦合已由抽象工厂删除，

> 问题

- 采用该模式需要向应用中**引入众多接口和类**，代码可能会比之前更加复杂
- **难以支持新的产品**，支持新产品需要扩展工厂接口，这涉及更改`AbstractFactory`类及其所有子类

## 工厂方法和抽象工厂区别

这一节先从两者在不同方面的对比来看，然后从一个结合使用的角度来看。

---

### 对比看区别

> 从一些方面的两者对比来看区别：

- 工厂方法的工厂是**方法**；抽象工厂的工厂是**类**；

  这也是主要的区别

- 生产的产品给谁用：

  工厂方法：生产的产品可以给系统用，可以给客户端用，也**可以自己这个类使用**

  抽象工厂：生产的产品给客户端(client)使用，绝不给自己用

- 产品个数和关系：

  工厂方法：只生成**一个产品**，不关注产品间的关系，

  抽象工厂：不同的方法生产很多不同的产品（**至少两个**），不同的产品之间有耦合有关联（关系可能非常复杂）

  工厂方法模式负责创建属于一个家族的产品，而抽象工厂模式负责处理多个产品家族

- 组成元素：

  - 一种组成角度：

    工厂方法：creator、product

    抽象工厂：client、factory、product A、product B

  - 另一种组成角度：

    工厂方法：

    抽象工厂：`AbstractFactory`，`ConcreteFactory`，`AbstractProduct`，`ConcreteProduct` 和 `Client`

- 从暴露程度上来看：

  工厂方法：使得调用者可以看到具体类，而不仅仅是抽象类或者接口。

  抽象工厂：调用者看不到具体类，只需要关注抽象类或者接口。

- 做的事情：

  工厂方法：自己这个类除了这个工厂方法外，还能**有其他**功能性的**方法**

  抽象工厂：工厂类只做**一件事情**即生产产品。

  为了说明不同之处，以下是工厂方法的使用：

  ```java
  class A {
      public void doSomething() {
          Foo f = makeFoo();
          f.whatever();   
      }
  
      protected Foo makeFoo() {
          return new RegularFoo();
      }
  }
  
  class B extends A {
      protected Foo makeFoo() {
          //subclass is overriding the factory method 
          //to return something different
          return new SpecialFoo();
      }
  }
  ```

  一个抽象工厂的使用：

  ```java
  class A {
      private Factory factory;
  
      public A(Factory factory) {
          this.factory = factory;
      }
  
      public void doSomething() {
          //The concrete class of "f" depends on the concrete class
          //of the factory passed into the constructor. If you provide a
          //different factory, you get a different Foo object.
          Foo f = factory.makeFoo();
          f.whatever();
      }
  }
  
  interface Factory {
      Foo makeFoo();
      Bar makeBar();
      Aycufcn makeAmbiguousYetCommonlyUsedFakeClassName();
  }
  
  //need to make concrete factories that implement the "Factory" interface here
  ```

---

### 结合使用看区别

> 从一个结合使用的角度来看

> One difference between the two is that with the Abstract Factory pattern, a class delegates the responsibility of object instantiation to another object via composition whereas the Factory Method pattern uses inheritance and relies on a subclass to handle the desired object instantiation.
>
> 两者之间的区别是，在使用抽象工厂模式时，一个类通过组合将对象实例化的责任委托给另一个对象，而工厂方法模式使用继承，并依赖于子类来处理所需的对象实例化

因为工厂方法只是一个方法，所以可以在子类中覆盖它，因此引用的后半部分：

> ...工厂方法模式使用继承，并依赖于子类来处理所需的对象实例化。

引用假定此处对象正在调用**其自己的**工厂方法。因此，**唯一可以改变返回值的是子类**。

抽象工厂是一个具有多种工厂方法的对象。查看引用的前半部分：

> ...使用抽象工厂模式，一个类通过组合将对象实例化的责任委托给另一个对象...

引用在说的是，有一个对象A，他想制作一个Foo对象。与其创建Foo对象本身（例如，使用工厂方法），不如创建**另一个**对象（抽象工厂）来创建Foo对象。（这个例子就是上面两者在做的事情上的例子）

---

### 错误的说法：工厂的工厂

> 错误的说法：工厂的工厂（很多人用工厂的工厂来称呼抽象工厂）

这个错误的说法的原因其实是：**抽象工厂模式可以使用工厂方法模式，原型模式或单例模式来实现**。如果使用了工厂方法模式来实现抽象工厂模式，那么就会引来这个说法，也就是很多人所谓的工厂的工厂。

还有另外一个有趣的可能原因是：因为他们都学习了或者看到了**相似错误(或者说误导人)的UML图**，这种UML图如下：

![](E:\_data\博文临时库\博文中的图片\抽象工厂迷惑人的类图.png)

可以发现在这张图种，`ShapeFactory`、`ColorFactory`继承了`AbstractFactory`，这确实让人迷惑，想到工厂方法其实就是一个方法后，让人觉得这样的图好像是对的。但是想到抽象工厂的类图之后又让人一口咬定他就是错的。

其实抽象工厂的继承图种就隐藏了这样的子图，系列A、系列B实现了系列抽象工厂，该抽象工厂种含有shape和color两个工厂方法，那么在A和B的继承种就分别含有了上面这张图。

所以这个问题是否应该归因于：

工厂方法只是一个方法，可以在子类中重写来覆盖它，而抽象工厂是一个对象，上面有多个工厂方法

# 常见实例

## 工厂方法

- 假设你正在开发一款物流管理应用。最初版本只能处理卡车运输。一段时间后，应用希望能够支持海上物流功能。那么处理[`物流、海上物流、路上物流、卡车、轮船`](https://refactoringguru.cn/design-patterns/factory-method)的关系

- 一个UI的例子：[`Dialog、WindowsDialog、WebDialog、Button、WindowsButton、HTMLButton`](https://refactoringguru.cn/design-patterns/factory-method)

使用情况

- 希望用户能**扩展**你软件库或框架的内部组件
- 希望**复用现有对象**来节省系统资源，而不是每次都重新创建对象（**对象池**）

- 当需要使客户端与其使用的特定产品脱钩时，请使用“工厂方法”模式。使用工厂方法可以减轻客户创建和配置产品实例的责任

## 抽象工厂

1. 资本家无耻的用户分级体验

   现在，我可以很容易地看到自己正在考虑一家在线商店，该商店向众多客户提供一系列服务。每个客户都属于三个组之一。当高级用户打开网站时，他会获得出色的用户界面，高度自定义的广告窗格，菜单中的更多选项等。向金牌用户呈现这些相同的功能集，但菜单中的功能却较少，广告大多是相关的，以及更少的经济用户界面。最后是我的用户，一个“免费组”用户。我刚刚受够了，所以我不会被冒犯。UI几乎是最低限度的，广告太偏离轨道了，以至于我不知道其中包含什么，最后菜单只注销了。

   如果有机会建立这样的网站，我一定会考虑使用“抽象工厂模式”。

   抽象产品：广告窗格，菜单，UI画家。
   抽象工厂：Web商店用户体验
   Concreate工厂：高级用户体验，金牌用户体验，一般用户体验

2. 一款家具商店模拟器，产品：`椅子`、`沙发`和`咖啡桌`，系列产品。例如，可以使用`现代`、`维多利亚`，`装饰风艺术`等风格生成`椅子`、`沙发`和`咖啡桌`
3. 跨平台UI：`WinFactory`、`MacFactory`、`WinButton`、`MacButton`、`WinCheckBox`、`MacCheckBox`、
   
- 进一步的，支持多平台的各种场景
   
4. 供对两个不同数据源的数据访问（例如，SQL数据库和XML文件）
5. HTTP服务器中的问题是，对于每个请求，我们总是需要一个响应，并且这两个响应是相关联的

## Java中的例子

> 工厂方法

- [`java.util.Calendar#getInstance()`](https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--)
- [`java.util.ResourceBundle#getBundle()`](https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-)
- [`java.text.NumberFormat#getInstance()`](https://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--)
- [`java.nio.charset.Charset#forName()`](https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-)
- [`java.net.URLStreamHandlerFactory#createURLStreamHandler(String)`](https://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html) （根据协议返回不同的单例对象）
- [`java.util.EnumSet#of()`](https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of(E))
- [`javax.xml.bind.JAXBContext#createMarshaller()`](https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--) 及其他类似的方法。

**识别方法：** 工厂方法可通过构建方法来识别， 它会**创建具体类**的对象， 但**以抽象类**型或接口的形式**返回**这些对象。

> 抽象工厂

- [`javax.xml.parsers.DocumentBuilderFactory#newInstance()`](https://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html#newInstance--)
- [`javax.xml.transform.TransformerFactory#newInstance()`](https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--)
- [`javax.xml.xpath.XPathFactory#newInstance()`](https://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--)

**识别方法：** 我们可以通过方法来识别该模式——其会返回一个工厂对象。 接下来， 工厂将被用于创建特定的子组件

# 进一步深入

许多设计工作的初期都会使用工厂方法，随后演化为使用抽象工厂、原型或生成器

- 工厂方法和原型
  - 工厂方法基于继承，但是原型并不基于继承，因此原型没有继承的缺点。
  - 原型需要对被复制对象进行复杂的初始化，但是工厂方法不需要初始化步骤

- 抽象工厂和生成器

  - 生成器重点关注如何分步生成复杂对象。抽象工厂专门用于生产一系列相关对象。

  - 抽象工厂会马上返回产品，生成器则允许你在获取产品前执行一些额外构造步骤

> 对于工厂模式：

- 工厂方法是模版方法的一种特殊形式。同时，工厂方法可以作为一个大型模版方法中的一个步骤

- <u>*todo: 不能理解？*</u>可以同时使用工厂方法和迭代器来让子类集合返回不同类型的迭代器，并使得迭代器与集合相匹配

> 对于抽象工厂：

- 抽象工厂和工厂模式：抽象工厂模式通常基于一组工厂方法，但也可以使用原型模式来实现
- 抽象工厂和外观模式：当只需对客户端代码隐藏子系统创建对象的方式时，你可以使用抽象工厂来代替外观
- 抽象工厂和桥接模式：将抽象工厂和桥接搭配使用。如果由桥接定义的抽象只能与特定实现合作，这一模式搭配就非常有用。在这种情况下，抽象工厂可以对这些关系进行封装，并且对客户端代码隐藏其复杂性

# 参考

> 1. [StackOverflow: What are the differences between Abstract Factory and Factory design patterns?](https://stackoverflow.com/questions/5739611/what-are-the-differences-between-abstract-factory-and-factory-design-patterns?noredirect=1&lq=1)
> 2. [知乎：抽象工厂模式和工厂模式的区别？](https://www.zhihu.com/question/20367734)
> 3. [Factory Comparison](https://refactoringguru.cn/design-patterns/factory-comparison)、[factory-method](https://refactoringguru.cn/design-patterns/factory-method)、[abstract-factory](https://refactoringguru.cn/design-patterns/abstract-factory)
> 4. 

