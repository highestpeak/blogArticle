数据库对于隔离级别的实现就是使用**并发控制机制**对在同一时间执行的事务进行控制，限制不同的事务对于同一资源的访问和更新，锁、时间戳、多版本和快照隔离MVCC



多版本并发控制和基于锁的并发控制



产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。

并发控制有隔离级别，提供可串行化的级别需要封锁实现，封锁相当复杂。



产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

隔离级别：

- 未提交读(对应丢失修改)

  事务中的修改，即使没有提交，对其它事务也是可见的。

- 提交读(对应读出脏数据)

  一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

- 可重复读(对应不可重复读)

  保证在同一个事务中多次读取同一数据的结果是一样的。

  （MySQL默认是可重复读级别）

- 可串行化

  强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

  该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。
  
  可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。

<img src="E:\_data\博文临时库\博文中的图片\数据库事务-隔离性-隔离级别.png" style="zoom:50%;" />

---

封锁：

分清几个锁名词的属于的概念，即封锁粒度、封锁类型、封锁类型封锁协议、封锁算法、



- 封锁粒度

  行级和表级

  应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

  但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。

  在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。

- 封锁类型

  读写锁：X和S锁，意向锁（未写）

  - 互斥锁（Exclusive），简写为 X 锁，又称写锁。
  - 共享锁（Shared），简写为 S 锁，又称读锁。

  读写锁的兼容性：

  |      | X    | S                  |
  | ---- | ---- | ------------------ |
  | X    | ❌    | ❌                  |
  | S    | ❌    | :heavy_check_mark: |

- 封锁协议

  - 三级封锁协议

    - 一级封锁协议：修改数据 A 时必须加 X 锁，直到结束才释放锁。解决丢失修改
    - 二级封锁协议：一级协议+读取数据 A 时必须加 S 锁，**读取完**马上释放 S 锁。解决读出脏数据
    - 三级封锁协议：二级协议+读取数据 A 时必须加 S 锁，直到**事务结束**才能释放 S 锁。解决不可重复读

    二级封锁协议中因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

    三级级封锁协议中因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

  - 两段锁协议

    加锁和解锁分为两个阶段进行。先加完所有的锁再释放所有的锁。

    ``` sql
    lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
    ```

    而不是

    ``` sql
    lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
    ```
    
    事务遵循两段锁协议是保证可串行化调度的充分条件。



https://juejin.im/entry/6844903549168517127

InnoDB行锁是通过给索引上的索引项加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁

InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁

表锁虽然开销小，锁表快，但高并发下性能低。行锁虽然开销大，锁表慢，但高并发下相比之下性能更高。

当你需要更新一张较大表的大部分甚至全表的数据时。而你又傻乎乎地用索引作为检索条件。一不小心开启了行锁(没毛病啊！保证数据的一致性！)。可MySQL却认为大量对一张表使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突问题，性能严重下降。所以MySQL会将行锁升级为表锁，即实际上并没有使用索引。
我们仔细想想也能理解，既然整张表的大部分数据都要更新数据，在一行一行地加锁效率则更低

行锁的劣势：开销大；加锁慢；会出现死锁
行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强

表锁的优势：开销小；加锁快；无死锁
表锁的劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低

表锁，读锁会阻塞写，不会阻塞读。而写锁则会把读写都阻塞。

**什么场景下用表锁**

第一种情况：**全表更新**。事务需要更新大部分或全部数据，且表又比较大。若使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突。

第二种情况：**多表查询**。事务涉及多个表，比较复杂的关联查询，很可能引起死锁，造成大量事务回滚。这种情况若能一次性锁定事务涉及的表，从而可以避免死锁、减少数据库因事务回滚带来的开销。

**行锁优化**

1 尽可能让所有数据检索都通过索引来完成，避免无索引行或索引失效导致行锁升级为表锁。
2 尽可能避免间隙锁带来的性能下降，减少或使用合理的检索范围。
3 尽可能减少事务的粒度，比如控制事务大小，而从减少锁定资源量和时间长度，从而减少锁的竞争等，提供性能。
4 尽可能低级别事务隔离，隔离级别越高，并发的处理能力越低。

**其他**

1 InnoDB 支持表锁和行锁，使用索引作为检索条件修改数据时采用行锁，否则采用表锁。
2 InnoDB 自动给修改操作加锁，给查询操作不自动加锁

3 行锁可能因为未使用索引而升级为表锁，所以除了检查索引是否创建的同时，也需要通过explain执行计划查询索引是否被实际使用。
4 行锁相对于表锁来说，优势在于高并发场景下表现更突出，毕竟锁的粒度小。
5 当表的大部分数据需要被修改，或者是多表复杂关联查询时，建议使用表锁优于行锁。
6 为了保证数据的一致完整性，任何一个数据库都存在锁定机制。锁定机制的优劣直接影响到一个数据库的并发处理能力和性能。

**分析sql**

通过检查InnoDB_row_lock 状态变量分析系统上的行锁的争夺情况 show status like 'innodb_row_lock%'

查看加锁情况

show open tables; 1表示加锁，0表示未加锁。

可以通过检查table_locks_waited 和 table_locks_immediate 状态变量分析系统上的表锁定：show status like 'table_locks%'



总体上可以分为乐观锁和悲观锁。

InnoDB 支持多种粒度的锁，也就是行锁和表锁；标准的行级锁，也就是共享锁（Shared Lock）和互斥锁（Exclusive Lock）；为了支持多粒度锁定（其实就是为了支持行锁），InnoDB 存储引擎引入了意向锁（Intention Lock），意向锁就是一种表级锁。

InnoDB存储引擎的行锁是通过锁住索引实现的，而不是记录。InnoDB的行锁算法都是基于索引实现的，锁定的也是索引或者索引区间。

意向锁也分为两种：

- 意向共享锁（IS锁）：事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁；
- 意向互斥锁（IX锁）：事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁；

意向锁其实不会阻塞全表扫描之外的任何请求，它们的主要目的是为了表示是否有人请求锁定表中的某一行数据。有了意向锁之后就避免了全表扫描来判断有无行锁。举例如：

- 如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。



锁有这样不同的粒度，但是锁是如何添加到对应的数据行上的？这就需要加锁的算法，下面介绍三种锁的算法：Record Lock、Gap Lock 和 Next-Key Lock。

- Record Lock（记录锁）：是加到索引记录上的锁

- Gap Lock（间隙锁）：

  当使用类似 `SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE;` 的 SQL 语句时，就会阻止其他事务向表中插入 `id = 15` 的记录，因为整个范围都被间隙锁锁定了

  - 虽然间隙锁中也分为共享锁和互斥锁，不过它们之间并不是互斥的，也就是不同的事务可以同时持有一段相同范围的共享锁和互斥锁，它**唯一阻止的就是其他事务向这个范围中添加新的记录**。
  - 只用于某些事务隔离级别

- Next-Key Lock：

  当我们更新一条记录，比如 SELECT * FROM users WHERE age = 30 FOR UPDATE;，InnoDB 不仅会在范围 (21, 30] 上加 Next-Key 锁，还会在这条记录后面的范围 (30, 40] 加间隙锁，所以插入 (21, 40] 范围内的记录都会被锁定。

  Next-Key 锁的作用其实是为了解决幻读的问题，幻读被解决的原因就是当使用select进行范围查询的时候锁住了这个范围。但是插入非这个范围内的值都正常。

![](E:\_data\博文临时库\博文中的图片\MySQL封锁算法.png)



---

MySQL多版本并发控制MVCC

（<u>*todo：感觉这个就是MySQL对于一种方案的一种实现，因为我在数据库课本上看到过*</u>）

要了解MVCC就需要先了解几个名词：快照读、当前读（其实主要是快照和当前）



MVCC是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

在实际场景中读操作往往多于写操作，因此引入了读写锁来避免不必要的加锁操作。更进一步的：MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 `CopyOnWrite` 类似。

在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。

脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。

都说是用"版本"来并发控制了，那肯定有个版本号：

- 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号 TRX_ID ：事务开始时的系统版本号。



MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。

MVCC 维护了一个 `ReadView` 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。



快照读：MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。

当前读：MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。

 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。（我认为其中加锁指的是对快照更新时的加锁，但是加锁时仍能读）

---

MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

---







https://juejin.im/post/6844903735500472333

https://draveness.me/mysql-innodb/