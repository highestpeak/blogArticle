操作系统、系统级编程、计算机组成和体系结构这几门课感觉起来内容在一个框内。

- 操作系统

  最为重要的内容是：内存管理、进程管理、文件管理、设备管理。
  - 内存管理中重要的内容有：虚拟内存、分级存储系统即高速缓存。
  - 进程管理中重要的内容有：进程和线程、进程调度、并发。
  - 文件管理中重要的内容有：Linux的文件系统。

  操作系统的重要内容还有：系统调用、内核、中断、其他调度管理

- 系统级编程

  重要内容有：编译和链接、C++/C编程

- 计算机组成和体系结构

  重要内容有：CPU

---

操作系统核心问题是进程和线程的管理，不同情形有**单处理**系统、**多处理器**系统、**分布式**计算机系统等的进程处理。并发问题涉及到的资源的问题不仅体现在内存、文件、I/O访问上，在对集合的处理和进程通信上也会涉及到并发。 

并发提高了对处理器资源的利用率，理解并发有助于写出更好更快的程序。如果想要更好的进行**网络编程、GUI编程、事件驱动编程**、**函数式编程**以及理解一些**常见的软件架构（基于消息机制的架构）、分布式系统**，都需要完整的了解并发问题，想更好的利用语言中的集合框架也需要理解并发问题。现在有专门的并发语言（例如Go，erlang这样的语言本身就支持并发）。此外并发也能帮助我们创建更为松散耦合的设计。

但是需要注意的是并发并不是完美和易用的（事实上是艰难的）。并发需要额外代价（包括**复杂性代价、资源开销代价**）来维护；并发环境下程序的封闭性被打破。并发数也不是越多越好，并发数需要合理并且CPU需要拥有足够的处理能力。如果没有任务会**堵塞**使用并发反而会引入**上下文切换**等一系列不必要的代价。

---

系统调用（英语：system call），指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态运行。如设备IO操作或者进程间通信。

用户程序使用系统调用是怎么做的，能否直接进行系统调用？

---

为什么要划分用户态和内核态：

- 指令的危险性：在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃

  比如：清内存、设置时钟等。CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用

- 需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络,

用户态切换到内核态的3种方式

- 系统调用
- 中断
- 异常

---

调度算法和放置算法：

页面放置算法：

- 最佳适配
- 首次适配
- 下次适配

页面置换策略：

- 最佳
- 最近最少使用
- 先进先出
- 时钟

进程调度算法：（不太会）

- FCFS先来先服务
- 轮转
- SPN最短进程优先
- SRT最短剩余时间
- HRRN最高相应比优先
- 反馈法

---

零拷贝（Zero-copy）技术：

据白白从kernel模式到user模式走了一圈，浪费了2次copy

DMA

![](E:\_data\博文临时库\博文中的图片\数据拷贝.webp)

https://www.jianshu.com/p/fad3339e3448

零拷贝相当于去掉了上面这个图的用户空间缓存的两次拷贝

---

大小端

以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value
Big-Endian: 低地址存放高位，如下：
高地址

　　buf[3] (0x78) -- 低位
　　buf[2] (0x56)
　　buf[1] (0x34)
　　buf[0] (0x12) -- 高位

　　低地址
Little-Endian: 低地址存放低位，如下：
高地址

　　buf[3] (0x12) -- 高位
　　buf[2] (0x34)
　　buf[1] (0x56)
　　buf[0] (0x78) -- 低位

低地址

https://www.ruanyifeng.com/blog/2016/11/byte-order.html





**什么是调度程序？**
分派器模块将CPU的控制权交给了短期调度程序选择的进程。这涉及：切换上下文，切换到用户模式，跳转到用户程序中的适当位置以重新启动该程序，调度延迟-调度程序停止一个进程并启动另一个进程所花费的时间



引导程序和BIOS（感觉面试不会考）



什么是缓存一致性？
在多处理器系统中，存在多个缓存，每个缓存可能包含相同变量A的副本。然后，应在所有其他缓存中立即反映一个缓存中的更改，这种在所有缓存中保持数据值相同的过程称为缓存-连贯性。



为了保护操作系统和系统程序免受故障程序的影响，开发了两种模式操作：
1.系统模式。
2.用户模式。
在这里，用户程序无法直接与系统资源进行交互，而是请求操作系统检查该请求并为用户程序执行所需的任务-DOS是为/ intel 8088编写的，



20.什么是操作系统组件？
1.进程管理
2.主内存管理
3.文件管理
\4. I / O系统管理
5.辅助存储管理
6.网络
7.保护系统
8.命令解释器系统

21.什么是操作系统服务？
1.程序执行
\2. I / O操作
3.文件系统操作
4.通信
5.错误检测
6.资源分配
7.记帐
8.保护



什么是系统调用？
系统调用提供了进程与操作系统之间的接口



期调度程序和短期调度程序



什么是上下文切换？
将控件从一个流程转移到另一流程需要保存旧流程的状态并为新流程加载保存的状态。此任务称为上下文切换

下文切换的缺点是什么？
从一种过程切换到另一种过程所花费的时间是纯开销。因为切换时系统没有做任何有用的工作。因此，解决方案之一是尽可能使用线程。



What are the deadlock avoidance algorithms?
A dead lock avoidance algorithm dynamically examines the resource-allocation state to ensure that a circular wait condition can never exist. The resource allocation state is defined by the number of available and allocated resources, and the maximum demand of the process.There are two algorithms:
\1. Resource allocation graph algorithm
\2. Banker’s algorithm
a. Safety algorithm
b. Resource request algorithm



Explain briefly about, processor, assembler, compiler, loader, linker and the functions executed by them.
Processor:–A processor is the part a computer system that executes instructions .It is also called a CPU
Assembler: — An assembler is a program that takes basic computer instructions and converts them into a pattern of bits that the computer’s processor can use to perform its basic operations. Some people call these instructions assembler language and others use the term assembly language.
Compiler: — A compiler is a special program that processes statements written in a particular programming language and turns them into machine language or “code” that a computer’s processor uses. Typically, a programmer writes language statements in a language such as Pascal or C one line at a time using an editor. The file that is created contains what are called the source statements. The programmer then runs the appropriate language compiler, specifying the name of the file that contains the source statements.
Loader:–In a computer operating system, a loader is a component that locates a given program (which can be an application or, in some cases, part of the operating system itself) in offline storage (such as a hard disk), loads it into main storage (in a personal computer, it’s called random access memory), and gives that program control of the compute
Linker: — Linker performs the linking of libraries with the object code to make the object code into an executable machine code.



什么是虚拟内存？
虚拟内存是一种硬件技术，它可以使系统拥有比实际更多的内存。这是通过分时完成的，将一个磁盘的物理内存和存储部分不活跃使用



为什么使用分页？
分页是解决外部碎片问题的方法，该问题使进程的逻辑地址空间不连续，从而使进程可以在物理内存可用的任何地方分配物理内存。



吞吐量，周转时间，等待时间和响应时间？



逻辑地址空间和物理地址空间之间的区别？
->绑定到单独的物理地址空间的逻辑地址空间的概念对于正确的内存管理至关重要。
逻辑地址–由CPU生成；也称为虚拟地址。
物理地址–存储单元看到的地址。
->逻辑地址和物理地址在编译时和加载时地址绑定方案中相同；逻辑（虚拟）和物理地址在执行时地址绑定方案上有所不同



系统抖动



.解释流行的多处理器线程调度策略。
=>负载共享：进程未分配给特定处理器。维护线程的全局队列。每个处理器在空闲时都从该队列中选择一个线程。请注意，负载平衡是指一种方案，其中将工作更持久地分配给处理器。
=>帮派调度：一组相关线程被安排为在一对一的基础上同时在一组处理器上运行。可以通过这种方式调度紧密相关的线程/进程，以减少同步阻塞，并最大程度地减少进程切换。小组调度早于该策略。
=>专用处理器分配：提供通过将线程分配给处理器来定义的隐式调度。在程序执行期间，为每个程序分配了一组处理器，该处理器的数量与程序中的线程数相等。从可用池中选择处理器。
=>动态调度：在执行过程中可以更改程序中的线程数。







进程区域：栈、堆、上下文、数据区



PCB在整个生命周期中都会得到维护，并且在过程终止后将其删除。



操作系统将所有PCB维护在进程调度队列中。操作系统为每个进程状态维护一个单独的队列，并且处于相同执行状态的所有进程的PCB都放置在同一队列中。当进程的状态更改时，其PCB从当前队列取消链接，并移至新的状态队列。

操作系统维护以下重要的流程调度队列-

- **作业队列** -此队列将所有进程保留在系统中。
- **就绪队列** -此队列将一组驻留在主内存中的所有进程保留为一组，准备就绪并等待执行。一个新的进程总是放在这个队列中。
- **设备队列** -由于I / O设备不可用而被阻塞的进程构成此队列。

操作系统可以使用不同的策略来管理每个队列（FIFO，循环，优先级等）。OS调度程序确定如何在就绪队列和运行队列之间移动进程，该队列在系统上每个处理器内核只能有一个条目。在上图中，它已与CPU合并。



上下文切换

上下文切换是一种在进程控制块中存储和恢复CPU的状态或上下文的机制，以便以后可以从同一点恢复进程执行。使用此技术，上下文切换器使多个进程可以共享一个CPU。上下文切换是多任务操作系统功能的重要组成部分。

当调度程序将CPU从执行一个进程切换为执行另一个进程时，当前运行进程的状态将存储到进程控制块中。此后，将从其自己的PCB加载下一个要运行的进程的状态，并用于设置PC，寄存器等。这时，第二个进程可以开始执行。

由于必须保存和恢复寄存器和内存状态，因此上下文切换需要大量的计算。为了避免上下文切换时间，某些硬件系统会使用两组或更多组处理器寄存器。切换过程后，将存储以下信息供以后使用。

- 程序计数器
- 安排信息
- 基本和极限寄存器值
- 当前使用的寄存器
- 改变状态
- I / O状态信息
- 会计信息



操作系统的调度就是说进程的调度：抢占、非抢占；还有几个FCFS、SJN等的课本上那几个算法



线程的优点

- 线程可最大程度地减少上下文切换时间。
- 线程的使用提供了进程内的并发性。
- 高效的沟通。
- 创建和上下文切换线程更经济。
- 线程允许更大范围和更高效率地利用多处理器体系结构。



线程可以有两个方式实现：用户级和内核级

（和用户态和内核态的区别？）



内存管理这个地方总结的还是很好的：

https://www.tutorialspoint.com/operating_system/os_memory_management.htm

内存管理做了的事情：

内存空间的分配与回收：操作系统完成主存储器的空间的分配，无需程序员操作

内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存

地址转换：程序的完整周期：编译、连接、装入、装入时将逻辑地址转换城物理地址

存储保护：需要保护操作系统不受用户进程影响，保护用户进程不受其他用户进程的影响，防止地址越界



分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段、数据段、能够更好满足用户的需要

页大小是由操作系统决定的，而段大小是由程序决定的。



虚拟内存应用了局部性原理

虚拟内存的特征：

- 多次性：作业无需一次性装入内存，而是允许被分成多次调入
- 对换性：做因无需一直常驻内存，可以被换入换出
- 虚拟性：逻辑上扩充了内存的容量



内存的驻留集如何选定？



虚拟内存有两个目的。首先，它允许我们通过使用磁盘来扩展物理内存的使用。其次，它使我们能够进行内存保护，因为每个虚拟地址都转换为物理地址。

https://www.tutorialspoint.com/operating_system/os_virtual_memory.htm



IO很重要，因为一些问文件处理流程、数据库和磁盘的交流、socket的网络连接流程的都会用到IO的一系列操作

https://www.tutorialspoint.com/operating_system/os_io_hardware.htm

https://www.tutorialspoint.com/operating_system/os_io_software.htm

考socket实际上考的就是IO，考网络实际上也考了IO：

https://www.jianshu.com/p/5cf67fab6d61

https://juejin.im/post/6844903824180641805

https://segmentfault.com/a/1190000021587865 这里面有个socket的讲解

https://liuyehcf.github.io/2017/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-IO%E7%B3%BB%E7%BB%9F/

https://jasonkayzk.github.io/2019/09/26/NIO%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FI-O%E6%A8%A1%E5%9E%8B/

五种IO模型也是IO的内容



线程和协程的区别？



文件系统



各个进程拥有独立的内存地址空间，为了保证安全，一个进程不能直接访问其他进程的地址空间



关键在虚拟内存、进程线程



大小端



进程控制块的所有信息必须常驻内存？？

逻辑地址通过MMU转换成物理地址，但是ARM编程是直接给出物理地址？

扇区和簇



页面置换算法有哪些？



linux：

- 简单bash脚本

- 15.linux用过的命令

  16.cat。grep还有怎么看文件前五行

- Linux线程 进程模型、内存模型



操作系统的资源包括了：处理器、内存、IO、定时器、磁盘、网络接口、文件系统

----

# 异常控制流

这个词我是最先从《深入理解计算机系统》上看到的，它认为异常控制流是实现进程、IO和虚拟内存等一系列重要机制的基础，我认为这是有道理的。正因为如此，我把这部分放到第一节综述来讲述。

---

（控制流==>程序指令突变和事件导致突变==>异常控制流）

我们知道处理器的程序计数器不同时刻有不同的值，即不同指令的地址。从一条指令到另一条指令的过渡成为**控制转移**，由于程序计数器会有很多次这样的控制转移，这些控制转移组成的序列就叫做**控制流**。

简单的控制流是一个**平滑**的序列，即指令是相邻的。但是这样的平滑序列不会持续下去，即出现平滑流的突变，这样的变化通常是由**跳转、调用、返回**等程序指令造成的。

即使是这样的突变，也是由程序指令控制的，它们尚且还算正常。但是现在考虑这样一种情况：系统状态突然发生了变化，而这样的变化是不可能由程序预测到的。例如硬件定时器产生一个定期信号需要处理、数据到达了网络适配器，需要取出并放到内存中、磁盘数据已经就绪、子进程需要通知父进程自己已经终止。这样的事件如何处理呢？

类似上面这样的一个发生、然后需要处理的事件是需要操作系统做出反应的。而操作系统对这些事件的反应就是使得当前控制流发生突变，也就是**异常控制流**（Exceptional Control Flow，ECF）。ECF发生在各个层次：

- 硬件层次：硬件检测到事件会触发控制转移到异常处理程序
- 操作系统层次：内核上下文切换将控制从进程转移到另一个进程
- 应用层：进程发信号给另一个进程

理解ECF极其重要：

- ECF是实现了IO、进程和虚拟内存的基本机制⭐⭐⭐
- ECF是应用户程序和操作系统交互的方式：陷阱和系统调用
- ECF可以帮助理解事件这样的机制
- ECF是并发的基本机制
- ECF可以帮助理解Java中通过try、catch、throw提供的软件异常

我们将讨论有关ECF的几个内容：异常、进程、信号，其中进程不在这个部分讨论，进程有单独的文章论述。请自行查阅。<u>*todo： 链接到进程的文章*</u>

## 异常

（这个异常和Java中的这样的异常不是一个概念，但是能够根据上下文很容易的区分开来，这里的异常更像是事件）

异常是异常控制流的一种形势，它一部分由硬件实现，一部分由操作系统实现。异常是控制流的突变，用来响应处理器状态的某些变化。

在处理器中，状态被编码成不同的位和信号，状态变化称为事件。

- 事件可能与当前指令直接相关，例如：缺页、算术溢出、指令除零。
- 事件也可能与当前指令无关，例如：定时器产生一个信号、一个IO请求完成

当处理器检测到事件发生时，他会通过一张叫做异常表的跳转表，来进行一个间接过程调用（异常），这个调用会到一个专门的操作系统子程序即异常处理程序。

当异常处理程序完成后，根据事件类型会有几种不同的后继行为：

- 控制返回当前指令
- 控制返回下一条指令
- 终止被中断的程序

---

**异常处理：**

处理异常通常需要硬件和软件紧密合作。每种异常都有自己唯一的异常号：

- 一些异常号是由处理器分配的：除零、缺页、内存访问违规、断电、算术溢出
- 其他号码是OS内核分配的：系统调用、IO信号

在系统启动时，即计算机启动时，操作系统会初始化一张异常表。每个条目包含了对应它的处理程序的地址。

- 异常表的起始地址放在了一个叫做异常表基址寄存器的CPU寄存器里

异常处理程序的特点：

- 异常处理类似过程调用，但是不同的是异常处理的返回地址可以是下一条指令或者当前指令，这和过程调用不同。
- 异常处理程序运行在内核下，拥有对系统资源的完全访问权限。
- 异常处理会把一些额外的处理器状态压栈，事后进行恢复

---

**异常类型：**

异常可分为四类：中断、陷阱、故障、终止。

- 注意中断和其他三种异常是不同的。对于同步发生的异常类型，也就是后三种异常。它们都是执行当前指令的结果，这样的指令也成为故障指令。

| 类别 | 原因               | 同步/异步 | 返回行为         |
| ---- | ------------------ | --------- | ---------------- |
| 中断 | 来自IO设备的信号   | 异步      | 下一条指令       |
| 陷阱 | 有意的异常         | 同步      | 下一条指令       |
| 故障 | 潜在的可恢复的错误 | 同步      | 可能返回当前指令 |
| 终止 | 不可恢复的错误     | 同步      | 不会返回         |

- ⭐⭐⭐中断是异步发生的，硬件中断不是由任何一条专门的指令造成的。硬件通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上。在当前指令完成后，处理器注意到中断引脚电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序。

- 陷阱和系统调用：系统调用是陷阱的最重要的用途，陷阱在用户程序和内核之间提供一个像过程调用一样的接口，这就是**系统调用**。

  从程序员角度看，系统调用和普通函数调用是一样的，但是他们的实现是不一样的。因为系统调用会访问到与调用函数不同的栈，即内核的栈。而普通函数调用访问的是与调用函数相同的栈。这样的转换也涉及到了用户模式和内核模式的转换。

  系统调用的实现方式是：把系统调用的标识符和参数放到一个预定义的区域，然后执行一个特殊指令中断用户模式的程序，将控制权转交给内核。

- 故障：可能会返回，也可能终止程序。经典示例是缺页异常。

- 终止：通常是硬件错误









像磁盘写数据、从网络读取数据、创建一个新进程、终止当前进程都是系统调用

系统调用是为应用程序提供到操作系统入口点的异常



Java的软件异常是非本地跳转，即违反通常的调用/返回规则的跳转











学习操作系统的这些知识有利于我们学习更为高层的东西，例如一些库、一个编程语言它们的进程和线程模型。因为它们同样具有自己的生命周期模型和描述模型，同样具有类似的标识信息。

操作系统核心问题是进程和线程的管理，

<u>*todo：如何有效的处理多核系统*</u>