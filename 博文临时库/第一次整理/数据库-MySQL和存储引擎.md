- 引擎和索引

# MySQL

## SQL语句执行过程

<img src="E:\_data\博文临时库\博文中的图片\MySQL架构图.png" style="zoom:50%;" />

从图中看到MySQL主要分为Server层和存储引擎层：

- Server层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 `binlog`日志模块。
- 存储引擎： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持InnoDB、MyISAM、Memory等多个存储引擎，其中InnoDB引擎有自有的日志模块 `redolog` 模块。

Server层中的各个组件：

- 连接器：负责用户登录、身份认证、读取用户权限并保存在连接上下文中
  - 后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的
- 查询缓存：执行查询语句的时候，会先查询缓存，MySQL会先校验这个SQL是否执行过
  - MySQL8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了
- 分析器：分析SQL是来干什么的，包括词法分析和语法分析
  - 词法分析：提取关键字，比如select、查询的表、字段名、查询条件等
  - 语法分析：分析SQL是否正确
- 优化器：例如多个索引的时候如何选择索引，join顺序，但他认为的最优可能不是最优
- 执行器：校验用户有无权限，有权限则调用存储引擎的接口

https://juejin.im/post/6844903801694978061

## explain

对 https://segmentfault.com/a/1190000008131735 的照抄照搬

与explain对应的是慢查询优化

可以再看一下https://juejin.im/post/6844904035900719111 这里面有很多例子

---

EXPLAIN 命令可以对 `SELECT` 语句进行分析, 并输出 `SELECT` 执行的详细信息, 以供开发人员针对性优化。（只针对`SELECT`）

EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:

```sql
EXPLAIN SELECT * from user_info WHERE id < 300;
```

EXPLAIN 执行结果有哪些字段：

- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.
- select_type: SELECT 查询的类型.
- table: 查询的是哪个表（查询涉及的表或衍生表）
- partitions: 匹配的分区
- type: join 类型
- possible_keys: 此次查询中可能选用的索引
- key: 此次查询中确切使用到的索引.
- ref: 哪个字段或常数与 key 一起被使用
- rows: 显示此查询一共扫描了多少行. 这个是一个估计值.
- filtered: 表示此查询条件所过滤的数据的百分比
- extra: 额外的信息

EXPLAIN的注意事项：

- EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况
- EXPLAIN不考虑各种Cache
- EXPLAIN不能显示MySQL在执行查询时所作的优化工作
- 部分统计信息是估算的，并非精确值
- EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划

---

**详细的字段分析：**

**select_type：**

`select_type` 表示了查询的类型, 它的常用取值有:

- SIMPLE, 表示此查询不包含 UNION 查询或子查询
- PRIMARY, 表示此查询是最外层的查询
- UNION, 表示此查询是 UNION 的第二或随后的查询
- DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询
- UNION RESULT, UNION 的结果
- SUBQUERY, 子查询中的第一个 SELECT
- DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.

**type：**

`type` 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 `type` 字段, 我们判断此次查询是 `全表扫描` 还是 `索引扫描` 等。type 常用的取值有:

- `system`: 表中只有一条数据。这个类型是特殊的 `const` 类型。

- `const`: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据。

  const 查询速度非常快, 因为它仅仅读取一次即可。例如 

  ``` sql
  explain select * from user_info where id = 2
  ```

- `eq_ref`: 通常出现在多表的 join 查询。

  表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 `=`, 查询效率较高. 

  ``` sql
  EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id
  ```

- `ref`: 通常出现在多表的 join 查询。

  针对于非唯一或非主键索引, 或者是使用了 `最左前缀` 规则索引的查询.

- `range`: 表示使用索引范围查询。

  通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中。

  - 当 `type` 是 `range` 时, 那么 EXPLAIN 输出的 `ref` 字段为 NULL, 并且 `key_len` 字段是此次查询中使用到的索引的最长的那个.

- `index`: 表示全索引扫描(full index scan),。

  和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据。

  - `index` 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 

- `ALL`: 表示全表扫描, 这个类型的查询是性能最差的查询之一

  如果一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免

通常来说, 不同的 type 类型的性能关系如下:
`ALL < index < range ~ index_merge < ref < eq_ref < const < system`

**possible_keys、key 和 key_len字段：**

- `possible_keys` 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 `possible_keys` 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 `key` 字段决定.
- key字段是 MySQL 在当前查询时所真正使用到的索引
- key_len表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.
  <u>*key_len 的计算规则在这里不表</u>*

**rows：** 

rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.
这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.

**Extra：**

EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:

- Using filesort
  当 Extra 中有 `Using filesort` 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 `Using filesort`, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.
- Using index
  "覆盖索引扫描", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错
- Using temporary
  查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.

### 优化方法

1. 减少数据访问量

   - 只返回必要的列：最好不要使用 SELECT * 语句。

     在select后写上具体字段可以增加使用覆盖索引的概率

   - 只返回必要的行：使用 LIMIT 语句来限制返回的数据。

   - 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。

2. 减少服务器端扫描的行数

3. 使用索引

4. 切分大查询

   一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

5. 分解大连接查询

   将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：

   - 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
   - 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
   - 减少锁竞争；
   - 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
   - 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。



## 其他

<u>*todo：*</u>

https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE

主从复制、读写分离、

MySQL怎么提高主从一致的效率

分库分表、切分策略

# 存储引擎

数据库引擎简单来说就是一个"数据库发动机"。当访问数据库时，不管是手工访问，还是程序访问，都不是直接读写数据库文件，而是通过数据库引擎去访问数据库文件。

以关系型数据库为例，SQL语句交给数据库引擎，数据库引擎解释SQL语句，提取出需要的数据返回。对访问者来说，数据库引擎就是SQL语句的解释器。

数据库引擎负责存储、处理和保护数据的核心服务。利用数据库引擎可以控制访问权限并快速处理事务，从而满足大多数需要处理大量数据的应用程序的要求，这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象(如索引、视图和存储过程)

对于常见的数据库MySQL来说，它提供了很多不同的引擎，例如MYISAM、INNODB、HEAP\Merge引擎等。在同一台服务器上也不需要都使用同一种引擎，可以对每个表使用不同的存储引擎。MySQL默认为INNODB存储引擎。

- SQL查询：`SHOW ENGINES;`

  ![](E:\_data\博文临时库\博文中的图片\数据库引擎-本机MySQL支持查看.png)

## InnoDB

### 数据存储

绝大多数存储引擎都以二进制的形式存储数据。InnoDB 存储表时，表的定义和数据索引等信息分开存储，其中表的定义存储在 `.frm` 文件中，数据索引存储在 `.ibd` 文件中。

如下图所示，InnoDB存储数据需要一个B+树，而这颗B+树是根据聚集索引来建立的。B+树叶节点存储页（看后续描述）。

![](E:\_data\博文临时库\博文中的图片\InnoDB如何存储记录-B树.jpg)

在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）。

![](E:\_data\博文临时库\博文中的图片\InnoDB数据存储.jpg)

InnoDB 使用页作为磁盘管理的最小单位；数据在 InnoDB 存储引擎中都是按行存储的，每个 16KB 大小的页中可以存放 2-200 行的记录。（页中有行）

- <u>*todo：主要有两种行记录格式，但是它们的区别和用处暂且不在这里写*</u>
- <u>*todo：行溢出数据使用指针指向溢出页*</u>

页是 InnoDB 存储引擎管理数据的最小磁盘单位，B+树 节点实际存放的就是页。

![](E:\_data\博文临时库\博文中的图片\InnoDB页结构.jpg)

- 每一个页中包含了两对 header/trailer：内部的 Page Header/Page Directory 关心的是页的状态信息，而 Fil Header/Fil Trailer 关心的是记录页的头信息

- 在页的头部和尾部之间就是用户记录和空闲空间了

- User Records 是页中真正用于存放行记录的部分

- 每一个数据页中都包含 Infimum 和 Supremum 这两个虚拟的记录（可以理解为占位符），Infimum 记录是比该页中任何主键值都要小的值，Supremum 是该页中的最大值

  ![](E:\_data\博文临时库\博文中的图片\InnoDB页记录.jpg)

在每个B+树节点进行二分查找

B+ 树在查找对应的记录时，并不会直接从树中找出对应的行记录，它只能获取记录所在的页，将整个页加载到内存中，再通过 Page Directory 中存储的稀疏索引和 `n_owned`、`next_record` 属性取出对应的记录，不过因为这一操作是在内存中进行的，所以通常会忽略这部分查找的耗时。

---

Page的头部保存了两个指针，分别指向前一个Page和后一个Page，头部还有Page的类型信息和用来唯一标识Page的编号。根据这两个指针我们很容易想象出Page链接起来就是一个双向链表的结构。

![数据库引擎-存储底层结构的示意5](E:\_data\博文临时库\博文中的图片\数据库引擎-存储底层结构的示意5.png)

User Record在Page内以单链表的形式存在，最初数据是按照插入的先后顺序排列的，但是随着新数据的插入和旧数据的删除，数据物理顺序会变得混乱，但他们依然保持着逻辑上的先后顺序。

![数据库引擎-存储底层结构的示意7](E:\_data\博文临时库\博文中的图片\数据库引擎-存储底层结构的示意7.png)

 把User Record的组织形式和若干Page组合起来，就看到了稍微完整的形式。

![数据库引擎-存储底层结构的示意8](E:\_data\博文临时库\博文中的图片\数据库引擎-存储底层结构的示意8.png)

现在看下如何定位一个Record：

- 通过根节点开始遍历一个索引的B+树，通过各层非叶子节点最终到达一个Page，这个Page里存放的都是叶子节点。
- 在Page内从"Infimum"节点开始遍历单链表（这种遍历往往会被优化），如果找到该键则成功返回。如果记录到达了"supremum"，说明当前Page里没有合适的键，这时要借助Page的Next Page指针，跳转到下一个Page继续从"Infimum"开始逐个查找。

![数据库引擎-存储底层结构的示意9](E:\_data\博文临时库\博文中的图片\数据库引擎-存储底层结构的示意9.png)

---

上面说的B+树是根据聚集索引来建立的，而除了聚集索引就是辅助索引，即：

辅助索引也是通过 B+ 树实现的，但是它的叶节点并不包含行记录的全部数据，仅包含索引中的所有键和一个用于查找对应行记录的『书签』，在 InnoDB 中这个书签就是当前记录的主键。

使用辅助索引查找一条表记录的过程：通过辅助索引查找到对应的主键，最后在聚集索引中使用主键获取对应的行记录，这也是通常情况下行记录的查找方式。

![](E:\_data\博文临时库\博文中的图片\InnoDB辅助索引查找数据.jpg)

---

> 为什么存储默认使用B+Tree，而不是B+树，二叉树，红黑树

B+ 树和B树相对于红黑树有更低的树高。红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁（因为同一个节点B+树可以相对于红黑树有更多的子节点，从而降低了树高度减少了磁盘IO）

B树内部节点存数据会增大IO，B+树数据全在叶子节点，局部性更好。B+树这样可以支持范围查询。B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题

数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

用预读特性，相邻的节点也能够被预先载入。数据库系统将索引的一个节点的大小设置为磁盘页的大小，使得一次 I/O 就能完全载入一个节点。B+树高较低也降低了磁盘IO

## InnoDB & MyISAM

它们的主要区别是

- InnoDB
  - 支持事务
  - 支持行级锁
  - 支持外键约束
  - 不支持全文搜索
- MyISAM
  - 支持表级锁
  - 支持全文索引
  - 不支持事务、行级锁、外键约束

其他方面的区别：

- InnoDB不会保存表的行数、为高并发场景设计（行级锁）、为大数据量设计、启动慢、要求表必须有主键否则会自动选择某一列作为主键
- MyISAM保存了表的行数、写入和读互斥
- 两者存储索引都是使用的B+树
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。
- MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。

如何选用（除去上面的区别外的选用标准）：

- 几乎所有的情况下采用InnoDB
- 并发量修改大（行锁）、要求高可靠性（事务）用InnoDB
- 经常读几乎没有写则用MyISAM
- 在MySQL <= 5.5中进行全文搜索，使用MyISAM
- 做很多count的计算，保存表的具体行数，使用MyISAM

# 参考

> 1. https://draveness.me/mysql-innodb/