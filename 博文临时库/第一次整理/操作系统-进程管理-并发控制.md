基于进程的并发编程、基于IO多路复用的并发编程、基于线程的并发编程

# 综述

> 并发是很多问题的基础，是对进程和线程管理的核心问题，并发是编程中相当重要的问题。但与此同时理解并发编程和理解面向对象的难度差不多，如果要理解他，则注定是一条艰辛的道路。

所有事物在任意时刻都只能执行一个步骤，即顺序编程，这是简单且基本的。但是对于某些复杂问题，并行的执行是方便的且必要的。

现代处理器多为多个核心，为了最大程度利用CPU的多核性能，我们的程序就更需要并行运算的能力。在这种情况下并发提高了对处理器资源的利用率，理解并发有助于写出更好更快的程序。

如果想要更好的进行网络编程、GUI编程、事件驱动编程、函数式编程以及理解一些常见的软件架构（基于消息机制的架构）、分布式系统，都需要完整的了解并发问题，想更好的利用语言中的集合框架也需要理解并发问题。现在有专门的并发语言（例如Go，erlang这样的语言本身就支持并发）。此外并发也能帮助我们创建更为松散耦合的设计。

但是需要注意的是并发并不是完美和易用的（事实上是艰难的）：

- 并发需要额外代价（包括复杂性代价、资源开销代价）来维护；

- 并发环境下程序的封闭性被打破。

- 并发数也不是越多越好，并发数需要合理并且CPU需要拥有足够的处理能力。

  如果没有任务会堵塞使用并发反而会引入上下文切换等一系列不必要的代价。

并发主要由交替和重叠的执行模式来实现，这样的实现也会带来一系列的问题。

并发问题最主要的就是对资源的处理，这些资源包括：内存、文件、其他I/O、处理器、缓冲区等。为了处理这样的那样的资源问题，出现了一系列的解决方案。包括进程间通信等。

---

**并发（Concurrency）和并行（Parallelism）：**

- 并发：

  指某个时间段内，多任务交替处理的能力。每个进程执行一段时间后，记录工作状态，释放资源进入等待状态，让其他进程抢占CPU资源。

  - 一个逻辑流的执行在时间上与另一个流重叠，成为并发流
  - 流X与Y互相并发，当且仅当X在Y开始之后和Y结束之前开始，或者Y在X开始之后和X结束之前开始
  - 并发流和处理器的核数和计算机数无关，如果两个流在时间上是重叠的，他们就是并发的

- 并行：

  指同时处理多任务的能力，CPU发展到了多核，可以同时执行多个互不依赖的指令和执行块。
  
  - 如果两个流并发地运行在不同的处理器核或者计算机上，那么我们就称他们为并行流

并发和并行的核心区别为进程是否同时执行，他们都是为了尽可能快的执行外所有任务。**”并行”概念是“并发”概念的一个真子集**。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。

为了理解并发和并行给出以下的例子：

- 参考1：某个科室两个专家同时坐诊，这是两个并行任务；其中一个医生时而问诊，时而查看化验单，然后继续问诊，突然又中断去处理病人的咨询，这是并发。

- 参考2：Erlang 之父 Joe Armstrong 用一张5岁小孩都能看懂的图解释了并发与并行的区别。在下图中并发是两个队列交替使用一台咖啡机，并行是两个队列同时使用两台咖啡机。

  <img src="E:\_data\博文临时库\博文中的图片\操作系统-咖啡并行图.jpg" style="zoom:50%;" />

---

**进程并发和线程并发：**

在某些系统中并发实体是线程而非进程（JAVA的并发实体是线程Thread）。

- 使用线程的好处是代码不需要关注他是运行在一个还是多个CPU机器上，这样增加一个CPU就能很容易加快程序运行速度。

- 进程共享复杂，线程共享高效：

  进程之间可以共享数据的方式大多需要复杂的实现（IPC）， 而线程之间代码、地址空间是共享的，共享数据的方式更加高效。

  即换一种说法：进程要考虑隔离，一个进程没有办法直接访问另一个进程；线程不用隔离，线程之间共享内存

正是因为进程的隔离特性，才使得线程并发更为高效。

<u>*todo: 信号量是在进程上的还是在线程上的？？应该都有吧？进程并发和线程并发的实现不同??*</u>

# 并发问题

学习原理之前需要先了解一些术语：

**并发术语：**

- 原子操作

  一个函数或动作由一个或多个指令的序列实现，对外部不可见。即其他进程不能看到中间状态也不能中断操作。指令序列<u>*要么全部执行要么都不执行*</u>。保证了并发进程的隔离。

- 临界区

  进程访问共享资源的<u>*一段代码*</u>，如果一个进程正在临界区，那么其他进程不能在这段代码执行。

- 竞争条件

  多个线程或进程在读写一个共享数据时，结果依赖于他们执行的相对时间的情形。发生在多个进程或线程读写数据时，竞争失败者决定竞争的变量的最终值。

- 互斥

  一个进程在临界区访问共享资源，其他进程不能进入临界区访问任何共享资源的情形。

- 死锁

  两个或两个以上的进程因为每个进程都在等待其他进程而不能继续执行的情形。

- 活锁

  两个或两个以上的进程为响应其他进程的变化而持续改变自己状态但不做有用工作的情形。

- 饥饿

  一个可运行的进程尽管能继续执行，但被调度程序无限期忽视，从而不被调度执行的情形。

---

**并发问题：**

并发执行会带来很多问题，这些问题由执行模式、进程和线程的合作竞争、进程和线程的通信带来。

- **交替和重叠的执行模式：**

  单处理器多道程序系统中进程交替执行，多处理器中进程交替执行和重叠执行。其中进程的相对执行速度不可预测（执行速度取决于其他进程的活动、操作系统的中断处理方式、操作系统调度策略），引来了很多问题：

  1. 全局资源共享的危险（全局变量的不同的读写执行顺序） 
  2. 操作系统很难对资源进行最优化分配
  3. 定位程序设计错误非常困难，调试困难
  4. 进程同时执行的情形（并行问题，只在多处理器出现）

  考虑下面一段代码和分析举例:

  ![](E:\_data\博文临时库\博文中的图片\操作系统-单处理器多处理器执行同一段代码.png)在单处理器上，进程可在任何地方停止指令的执行，而多处理器还会两个进程同时执行并且都试图访问同一全局变量。解决这个问题就需要**控制共享资源的访问**，一次只允许一个进程进入。

- 竞争：

   当每个进程竞争使用同一资源时，会发生冲突。这样的资源又可以分为只读和可写资源。

- 合作：

  - 访问资源的合作：

    可能访问同一个共享变量、共享文件或数据库。进程可能访问或修改共享变量（读和写）而不涉及其他进程，但却知道其他进程也可能访问同一个数据。

  - 通信合作：

    由于未共享对象，因此不需要互斥，但仍然存在死锁和饥饿，两个进程都在接收对方通信的语句上堵塞，发生死锁

竞争和合作都需要访问或操作共享对象，这样的操作需要保证互斥。互斥就会带来另外的问题：死锁和饥饿。如果不需要访问共享对象，也就没必要保证互斥，如上面的通信合作，但是这样的情况仍会出现死锁和饥饿。尽管通信合作没必要使用互斥，但是仍然由通过互斥来实现通信合作的方法。

解决了互斥不保证解决了死锁和饥饿，但应该首先保证互斥，然后逐步解决死锁和饥饿。

<img src="E:\_data\博文临时库\博文中的图片\操作系统-并发控制问题.png" style="zoom:48%;" />

## 互斥

互斥技术可用于解决注入资源争用之类的冲突，也可以用于进程的同步。并发核心问题是对资源的互斥需求，互斥的实现有多种方法（如下），但大致可划分为硬件方法和软件方法：

1. 专用机器指令，较少开销但不通用。（硬件支持）
2. 操作系统或程序设计语言提供某种级别的支持。（软件方法：操作系统和程序设计语言的支持）
3. 进程承当实现互斥的责任，这是软件方法，增加了开销并存在缺陷。（软件方法：进程承担责任）（加锁）
   - 加锁可能会对某种资源加锁，但也可能对一组资源对一组操作加锁，这样的过程在数据库种称为事务。

其中方法1的几种实现有：中断禁用、专用机器指令；2的几种方法有：信号量、管程、消息传递等；方法3的几种实现有Dekker算法、Peterson算法、竞争条件和信号量等。这几种方法的详细说明将在下一篇文章总结。

> 互斥的要求

- 强制实施互斥：

  在与共享资源或共享对象的临界区有关的所有进程中，一次只允许一个进程进入临界区

- 在非临界区停止的进程不能干涉其他进程

- 访问临界区的进程不能被无限延迟，即不会发生死锁或饥饿

- 进程驻留在临界区的时间是有限的

- 没有进程在临界区时，应当可以立即进入临界区

- 相关进程的执行速度和处理器的数量没有任何要求和限制

### 硬件支持

硬件实现的几种方法有：中断禁用，专用机器指令

- 中断禁用：

  只需要保证一个进程不被中断即可，通过内核提供启用中断和禁用中断的原语来支持，但是代价很高，执行的效率会明显降低，另外不适用于多处理器

- 专用机器指令（**CAS过程**）：

  compare and swap指令，用一个测试值（`testval`）检查一个内存单元（*word）。如果这个内存单元的当前值是测试值（`testval`），就用新的值（`newval`）替换该值，否则保持不变。(当word为0可以进入临界区，出临界区把word重置为0，如果当前有一个进程在访问临界区，其他进程的`testval`是1，compare and swap返回的是1，如果没有任何进程在临界区，`testval`为0，compare and swap返回的是0，如果检查到返回的值和传入的`testval`不相等，说明word的值在上一次循环被更改)，当有进程处于临界区时，其他进程处于忙等待（自旋等待）

  机器指令只解决了互斥，可能饥饿（选择进入临界区的进程是任意的）和死锁（如果P1在临界区被中断、并且P1在临界区正在持有一个资源R的访问，那么如果P2此时被调度执行并且试图访问R时就会失败，如果P2比P1的优先级高，P1永远不会被执行，P2永远处于忙等待，陷入死锁）

### 软件方法

(软件方法：操作系统/程序语言支持)

主要方法有：信号量、管程、消息传递

<u>*todo: 表5.3 一般常用的并发机制截图*</u>

**信号量 semaphore：**

二元信号量 binary semaphore，值只能是0或者1

``` c++
struct binary_semaphore{
	enum {zero,one} value;
    queueType queue;
}
void semWaitB(binary_semaphore s){
    if(s.value==one){
        s.value = zero;
    }else{
        /*把当前进程插入队列*/
        /*阻塞当前进程*/       
    }
}
void semSignalB(binary_semaphore s){
    if(s.queue is empty()){
        s.value = one;
    }else{
        /*把进程P从队列移除*/
        /*把进程P插入就绪队列*/       
    }
}
```

计数信号量counting semaphore（一般信号量 general semaphore）

``` c++
struct semaphore{
    int count;
    queueType queue;
}
void semWait(semaphore s){
    s.count--;
    if(s.count<0){
        /*把当前进程插入队列*/
        /*阻塞当前进程*/
    }
}
void semSignal(semaphore s){
    s.count++;
    if(s.count<=0){
        /*把进程P从队列移除*/
        /*把进程P插入就绪队列*/
    }
}
```

信号量解决互斥问题的写法如下

``` c++
const int n= /*进程数*/;
semaphore s = 1;
void p(int i){
    while(true){
        semWait(s);
        /*临界区*/
        semSiganl(s);
        /*其他部分*/
    }
}
void main(){
    parbegin(P(1),P(1),...,P(n));
}
```

信号量的实现

`semWait`和`semSignal`的实现必须是原子原语，任何时候只有一个进程可用`semWait`或者`semSignal`操作控制一个信号量。

可以使用软件方案：`dekker`算法或者`peterson`算法，但这有处理开销

可以使用硬件方案：compare&swap和中断禁用（单处理器系统），因为`semWait`和`semSignal`的操作时间很短，因此忙等待或者中断禁用的时间都分长短，是比较合理的。

实现方法如下（注意important语句，并注意堵塞进程时的处理，因为堵塞进程时进程无法到达最后一句，所以堵塞时就应该执行flag置为0或者允许中断！！！）

``` c++
void semWait(semaphore s){
    while(compare and swap(s.flag,0,1)==1); // important ! 或： 中断禁用
    s.count--;
    if(s.count<0){
        /*把当前进程插入队列*/
        /*阻塞当前进程，并设置flag为0或允许中断*/ // important !
    }
    s.flag=0; // important ! 或： 中断允许
}
void semSignal(semaphore s){
    while(compare and swap(s.flag,0,1)==1); // important !
    s.count++;
    if(s.count<=0){
        /*把进程P从队列移除*/
        /*把进程P插入就绪队列*/
    }
    s.flag=0; // important !
}
```

- PV操作: P操作用于`semWait` V操作用于`semSignal`

- 进程按照什么顺序从队列中移除？FIFO最公平，被堵塞最久的进程最先从队列释放，采用这一策略的信号量是强信号量，没有规定队列移出顺序的信号量为弱信号量。强信号量确保了不会饥饿。

- 二元信号量与互斥锁（mutex）的区别：为互斥量加锁的进程和解锁的进程必须为同一进程，而二元信号量可以由一个进程加锁，而另一个进程解锁

- 信号量本质上处理的是进程进入和移出 阻塞和就绪队列

- 信号量一般初始化为1，这样第一个执行`semWait(s)`的进程可以立即进入临界区，并把s的值置为0，接下来任何试图进入临界区的其他进程都会被堵塞。

  程序也可以公平的处理一次允许多个进程进入临界区的需求，这个需求可以把信号量初始化为某个特定的值来实现。无论何时`s.count`的值可以解释如下

  （count大于1的值的情形例子如哲学家就餐问题，虽然count大于1不能保证临界区互斥，但是没有告诉我们不能再临界区中再加一个信号量来保证互斥，外层count大于1的信号量用于限制临界区进程数量，第二个count等于1的内层信号量用于保证互斥）

  - `s.count>=0`：`s.count`是可以执行`semWait(s)`而不被堵塞的进程数。这种情形允许信号量支持同步和互斥。
  - `s.count<0`：`s.count`的大小是堵塞在`s.queue`队列中的进程数

---

**管程：**

<u>*todo: 未整理完*</u>

使用信号量设计程序是困难的，难点在于`semWait`和`semSignal`操作可能分布在整个程序中，而且很难看出信号量在这些操作上产生的整体效果。

管程是一种结构，可以用管程来锁定对象。

管程是由一个或多个过程（函数、方法）、一个初始化序列和局部数据组成的软件模块。（更加面向对象），管程特点如下

- 局部数据变量只能被管程的过程访问
- 只能调用管程的一个过程来进入管程
- 在任何时间，只能有一个进程在管程中执行，调用管程的任何其他进程都被堵塞，

进程不仅能够在管程中被堵塞，也能够释放这个管程，当条件满足且管程再次可用时，需要恢复该进程并允许它在堵塞点重新进入管程。

管程使用条件变量来支持同步，`cwait(c)`，`csignal(c)`，如果管程中的一个进程发信号，但是没有在这个条件变量c上等待的任务，那么丢弃这个信号

管程优于信号量的地方在于，所有的同步机制都被限制在管程内部，因此不但易于验证同步的正确性，而且易于检测出错误？？？？

- 使用信号的管程 ？？？ 未
- 使用通知广播的管程 ？？？ 未

---

**消息传递：**

<u>*todo: 未整理完*</u>

xx 未

和socket的关系？？？

## 死锁和饥饿

<u>*todo：饥饿的内容？（死锁和饥饿的饥饿，不是饿肚子的饿）*</u>

死锁和饥饿是并发处理的两个基本问题。在这一节主要讲解死锁相关内容，饥饿内容基本不涉及。

---

>  死锁原理

1. 死锁是永久性的。
2. 一组进程中的每个进程都在等待某个事件（典型情况下是等待释放所请求的资源），而仅有这组进程中被堵塞的其他进程才可以触发该事件，这样这组进程就发生了死锁。

**不同资源类型的死锁：**

资源分为两类：可重用资源，可消耗资源。

可重用资源是一次仅供一个进程安全使用并且不会因为使用耗尽的资源，进程会使用并释放资源，可重用资源例子如：处理器、I/O通道、内存和外村、设备，以及诸如文件、数据库和信号量之类的数据结构。可重用资源死锁的例子：

- 两个进程竞争独占访问文件D和T，每个进程都占用一个文件并请求另一个文件从而发生死锁。（设计资源请求顺序的约束可以解决）
- 内存请求，可分配空间为200kb，如果请求顺序为：P1进程请求80kb，P2请求70kb，（此时间点之前p1、p2都完成之前请求且没有释放空间）p1请求60kb，p2请求80kb，那么就会发生死锁，因为都得不到需要的空间。（事先知道请求空间的总量、使用虚存 两个方法可以解决死锁）

可消耗资源可以被创建（生产）和销毁（消耗）的资源。消费进程得到资源后资源将不复存在，例子有：终端、信号、消息和I/O缓冲区。例子如下：,可消耗资源通常为设计错误很难发现，罕见的事件可能导致死锁，可能很长时间才会遇到。

- 每个进程都试图从另一个进程接收消息，p1：receive（p2）... send（p2，m1） p2: receive(p1) ... send (p1,m1)

**死锁有几个条件：**

三个必要条件：

1. 互斥。一次只有一个进程可以使用一个资源。
2. 占有且等待。进程等待其他进程时，继续占有已经分配的资源。
3. 不可抢占。不能强行抢占已占有的资源。

一个充分条件：

1. 循环等待。存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源

上述**四个条件**共同构成死锁的充要条件。第四个条件是前三个条件的潜在结果，前三个条件只是表明死锁可能存在。

**死锁情形示例：**

- A向B转账的500块的时候，B几乎同时向A转账1000块，在两笔交易几乎同时执行的时候， 当交易1执行了step1锁住A账号再去锁B账号的时候，交易2可能正执行step3锁住了B账号然后要请求A账号的资源。 这个时候死锁就出现了。结果就是两笔交易都无法正常往下走，只能等待超时直至对方释放资源。最终的结果可能是这两笔交易都失败， 然后再重新发起交易。

  <u>*todo：该示例的图*</u>

### 死锁解决方案

处理方法：

- 鸵鸟策略：我什么都不知道！
- 死锁预防：运行前
- 死锁避免：运行时
- 死锁检测与死锁恢复：死锁发生时
  - 每种类型一个资源的死锁检测，有向图存在环，也就是检测到死锁的发生
  - 每种类型多个资源的死锁检测，矩阵
  - 死锁恢复
    - 利用抢占恢复
    - 利用回滚恢复
    - 通过杀死进程恢复

处理死锁的方法是根据上面四个条件的，

- **预防：**消除四个条件的某个条件的出现
- **避免：**基于资源分配的当前状态做动态选择
- **检测：**检错死锁的存在并从死锁恢复

死锁预防策略非常保守，通过限制访问资源和在进程上强加约束来解决死锁问题。死锁检测不限制资源访问或约束进程行为。对于死锁检测，只要有可能就会给进程分配其请求的资源。

死锁检测可以频繁的在每个资源请求发生时进行，也可以进行的少一些，在每次请求资源时检查死锁：尽早检测死锁情况，算法简单，但是会耗费很多处理器时间。

---

详细的方法：

> 死锁预防

分为两类：

- 一类是间接死锁预防，即防止前面列出的三个必要条件；

  - 互斥：不可避免

  - 占有且等待：进程一次性请求所有需要的资源。

    这样做有两个问题：

    - 进程可能要被堵塞很长时间，虽然只要有一些资源就可以继续运行。
    - 进程不知道所需要的全部资源

  - 不可抢占：

    - 占有某些资源的进程进一步申请资源若被拒绝，则该进程须**释放已经占有的资源**。

    - 进程请求当前被另一个进程占有的一个资源时，操作系统可以**抢占另一个进程**，要求释放资源（优先级若相同则不可解）。

      只有资源状态可以很容易的保存和恢复的情况下（处理器资源），这种方法才是实用的。

- 一类是直接死锁预防，即防止第四个条件循环等待。

  - 循环等待：**定义**资源类型的先行**顺序**来预防，（会使进程执行速度变慢），即设计机制防止条件的发生

---

> 死锁避免（也可以视为死锁预防的例子）

死锁避免策略并不能确切的预测死锁，它仅是预测死锁的可能性并确保永远不会发生这种可能性（从banker算法可以看出）

- **判断请求，杀死死锁可能性**：

  允许三个必要条件，通过明智的选择，确保永远不会到达死锁点。可允许更多的并发。是否允许资源的分配请求是通过判断该请求是否可能导致死锁来决定的。

两种方法：（均是拒绝将要发生的事情）

- 若进程请求会导致死锁，则不启动该进程
- 若进程增加的资源请求会导致死锁，则不允许分配

经典的方法是银行家算法（banker算法），见下文的经典问题。

死锁避免有限制：

- 事先声明请求的最大资源
- 进程的执行顺序没有同步需求，进程是无关的
- 分配的资源数量固定
- 占有资源时程序不能退出

---

> 死锁检测

死锁检测的步骤可以分为：死锁检测和死锁恢复

**死锁检测：**

死锁检测算法的策略是查找一个进程，使得可用资源能满足该进程的资源请求，然后假设同意这些资源，让该进程运行直到结束，在释放它的所有资源，然后，算法在寻找另一个可以满足资源请求的进程，该算法不能保证防止死锁，是否思索取决于将来同意请求的次序。**他所做的一切事确定当前是否存在死锁**

死锁检测算法：

<u>*todo：写的不好，需要完善*</u>

1. 标记allocation矩阵中一行全为零的进程
2. 初始化一个临时向量w，令w等于available
3. 查找下表i，使得i档期啊那位标记且q的第i行小于等于w，即对所有的1<=k<=m, `Qik<=Wk`,若找不到这样的行，终止算法（满足一个进程的需求）
4. 若找到这样的行，标记进程i，并把allocation矩阵中的相应行加到w中，即对所有1<=k<=m, 令`Wk=Wk+Aik`，返回步骤3（回收上一步3中的进程资源，重复3）

仅当这个算法的最终结果有未标记的进程时，才存在死锁，每个未标记的进程都是死锁的。

**恢复的策略：**

1. 取消所有的死锁进程
2. 把每个死锁进程回滚到前面定义的某些检查点，重启所有进程，需要在系统中构建回滚和重启机制
3. 连续取消死锁进程直到不再存在死锁，取消顺序基于某种最小代价原则。取消进程的顺序应基于某种最小代价原则。
4. 连续抢占资源直到不在存在死锁，需要一种基于代价的选择算法，一个资源被抢占的进程必须回滚到获得这个资源之前的某一状态。

# 经典问题

<u>*todo: 补充其他问题示例*</u> 

<u>*todo: 未整理完*</u>

生产者/消费者问题、读者/写者问题、银行家算法、哲学家就餐问题

**生产者/消费者问题：**

缓冲区无限

二元信号量解决

``` c++
int n;
binary semaphore s=1,delay=0;
void producer(){
    while(true){
        produce();
        semWaitB(s);
        append();
        n++;
        if(n==1) semSignal(delay);
        semSignalB(s);
    }
}
void consumer(){
    int m; // important!
    while(true){
        semWaitB(s);
		take();
        n--;
        m=n; // important!
        semSignal(s);
        comsume();
        if(m==0) semWait(delay);
    }
}
```

信号量解决

``` c++
semaphore n=0,s=1; // n:商品数量 s:操作互斥,s永远小于等于1
void producer(){
    while(true){
        produce();
        semWait(s);
        append();
        semSignal(s);
        semSignal(n);
    }
}
void consumer(){
    while(true){
        semWait(n);
        semWait(s);
        take();
        semSignal(s);
        consume();
    }
}
```

缓冲区有限

``` c++
const int sizeofbuffer = /*缓冲区大小*/;
semphore s=1,n=0,e=sizeofbuffer; // s: 操作互斥 n:数量控制 e:缓冲区大小控制
void producer(){
    while(true){
        produce();
        semWait(e);
        semWait(s);
        append();
        semSignal(s);
        semSignal(n);
    }
}
void consumer(){
    while(true){
        semWait(n);
        semWait(s);
        take();
        semSignal(s);
        semSignal(e);
        consume();
    }
}
```

**读者/写者问题：**

特点

1. 任意数量的读进程可以读文件
2. 一次只有一个写进程可以写文件
3. 若有一个写进程正在写文件，则禁止任何读进程读文件

和一般互斥问题、生产者/消费者问题的区分：

1. 读者/写者 读进程不会写数据

**银行家算法：**

进程请求一组资源时，假设同意该请求，因此改变了系统的状态，然后确定结果是否仍然处于安全状态。如果是，同意这个请求；如果不使，堵塞该进程直到同意该请求后系统状态仍然是安全的。

四种向量或矩阵：

- resource 系统中每种资源的总量
- available 未分配个进程的每种资源的总量
- claim 进程i对资源j的需求矩阵
- allocation 当前分配给进程i的资源j

**哲学家就餐问题：**

1. 信号量控制，每位哲学家先拿起左边，再拿起右边，（会存在饥饿）
2. 再买5把叉子
3. 再增加一个信号量，只允许4位哲学家同时就餐
4. 管程：每个叉子对应一个条件变量？（这个不太懂）

# 不同系统的并发机制

**UNIX 并发机制**

- 进程间传递数据
  - 管道
  - 消息
  - 共享内存
- 触发其他进程的行为
  - 信号量
  - 信号

**Linux 并发机制**

- 包含所有UNIX的机制
- 实时信号机制
  - 支持优先级顺序排列信号
  - 多个信号同时排队
  - 可以随信号发送数值（整数或指针）
- 原子操作
- 自旋锁
- 信号量
- 屏障

**Windows7 并发机制**

- 等待函数
- 分派器对象
- 临界区
- 轻量级读写锁和条件变量
- 所无关同步机制

**Android 进程间通信**

- 连接器

# 参考

>1. 操作系统-精髓与设计原理（第八版）第五章
>2. 码出高效：Java开发手册 第七章
>3. 并发的艺术
>4. JAVA编程思想 第四版 第21章

