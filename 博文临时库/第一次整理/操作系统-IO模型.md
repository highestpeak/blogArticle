# 综述

I/O 问题是任何编程语言都无法回避的问题，可以说 I/O 问题是整个人机交互的核心问题，因为 I/O 是机器获取和交换信息的主要渠道。I/O 问题尤其突出，很容易成为一个性能瓶颈。

要想明白IO，就需要理解几个术语：同步和异步，堵塞和非堵塞。同步和异步是从行为角度描述事物的，而阻塞和非阻塞描述的当前事物的状态（等待调用结果时的状态）。不同IO模型的同步和堵塞情况是不同的，也因此适用于不同的场景。

- 同步IO，是一种用户空间与内核空间的调用发起方式。同步IO是指用户空间线程是主动发起IO请求的一方，内核空间是被动接受方。
- 异步IO则反过来，是指内核kernel是主动发起IO请求的一方，用户线程是被动接受方。
- 同步异步指的是消息通信的机制，堵塞非堵塞指的是程序等待结果时候的状态

IO是和数据打交道，那对数据的处理方式也是需要学习的点：面向流、面向块（缓冲区）处理数据的方式。面向流的 I/O 一次处理一个字节数据，面向块的 I/O 一次处理一个数据块，面向流的 I/O 通常相当慢，按块处理数据比按流处理数据要快得多。

IO的种种模型不同的模型都是为了更好的利用CPU。

# OS层IO原理

无论是Socket的读写还是文件的读写，在Java层面的应用开发或者是Linux系统底层开发，都属于输入input和输出output的处理，简称为IO读写。在原理上和处理流程上，都是一致的。区别在于参数的不同。

用户程序进行IO的读写，基本上会用到read&write两大系统调用。这两大调用都是来操作缓冲区。缓冲区的目的，是为了减少频繁的系统IO调用。等待缓冲区达到一定数量的时候，再进行IO的调用，提升性能。至于什么时候读取和存储则由内核来决定，用户程序不需要关心。

- 可能不同操作系统，系统调用的名称不完全一样，但是功能是一样的
- **注意：** 
  - read系统调用，是把数据从内核缓冲区复制到进程缓冲区；而write系统调用，是把数据从进程缓冲区复制到内核缓冲区。
  - 这个两个系统调用，都不负责数据在内核缓冲区和磁盘之间的交换。底层的读写交换，是由操作系统kernel内核完成的。

所以，用户程序的IO读写程序，大多数情况下，并没有进行实际的IO操作，而是在读写自己的进程缓冲区。

<img src="E:\_data\博文临时库\博文中的图片\NIO网络请求的典型示意图.png" style="zoom:75%;" />

# LINUX的五种IO模型

![](E:\_data\博文临时库\博文中的图片\IO五种模型的对比.jpg)

- 总体上来说，分成两个阶段：等待数据和数据拷贝
- 等待数据是内核空间的事情

5种IO模型：

- 阻塞IO：
  - 阻塞指的是用户空间程序的执行状态，用户空间程序需等到IO操作彻底完成。
  - 阻塞是指用户空间（调用线程）一直在等待IO数据就绪，别的事情什么都不做
- 非阻塞IO：
  - 发起IO操作后内核立即返回给用户一个状态值，用户程序不需要等待内核IO操作完成，用户程序可以执行其他操作，处于非阻塞的状态
  - 非阻塞是指用户空间（调用线程）拿到状态就返回，IO操作可以干就干，不可以干，就去干的事情
  - 但是尽管去干了别的事情，用户程序还是要不断的去轮询内核，查看IO数据是否就绪
- 信号驱动IO
  
  - 相对于非堵塞IO的轮询，信号驱动IO可以不去轮询。内核的IO数据就绪后会通知用户程序。用户程序不需要不断地查看数据是否就绪，可以更“开心”的去做其他事情
- IO多路复用
  - IO多路复用等待多个IO操作，因为IO操作是耗时的，我们可以同时等待多个IO操作，这样我们遇到IO就绪的事件的概率就会大一点，就可以充分利用CPU时间片
  
  - IO多路复用是堵塞的，当任何一个IO数据就绪，堵塞就会解除
  
  - Java中的Selector和Linux中的`epoll`都是这种模型
  
  - Linux提供`select`/`poll`，进程通过将一个或多个`fd`传递给select或poll系统调用，阻塞在select；这样select/poll可以帮我们侦测许多`fd`是否就绪。但是select/poll是顺序扫描`fd`是否就绪，而且支持的`fd`数量有限。Linux还提供了一个`epoll`系统调用，`epoll`是基于事件驱动方式，而不是顺序扫描,当有`fd`就绪时，立即回调函数rollback
  
    - `epoll`的效率更高，优化了select的轮询操作，通过callback事件响应方式。
      `epoll`除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少`epoll_wait`/`epoll_pwait`的调用，提高应用程序效率。
  
    - select的几大缺点：
      （1）每次调用select，都需要把`fd`集合从用户态拷贝到内核态，这个开销在`fd`很多时会很大
  
      （2）同时每次调用select都需要在内核遍历传递进来的所有`fd`，这个开销在`fd`很多时也很大
  
      （3）select支持的文件描述符数量太小了，默认是1024
  
      poll实现
      poll的实现和select非常相似，只是描述`fd`集合的方式不同，poll使用`pollfd`结构而不是select的`fd_set`结构.
  
  <u>*todo：注意这个select、poll和epoll*</u>
- 异步IO
  - 用户空间线程是变成被动接受的，内核空间是主动调用者
  - 内核已经把数据拷贝到了用户空间，而之前的几种IO都是用户程序负责这部分的数据拷贝

---

<u>*todo： windows IOCP、android 的IO机制*</u>

# 内存映射文件

通常情况下，操作系统的一次写操作分为两步： 

- 将数据从用户空间拷贝到系统空间
- 从系统空间往网卡写

同理，读操作也分为两步： 

- 将数据从网卡拷贝到系统空间
- 将数据从系统空间拷贝到用户空间

**<u>*从操作系统层面看Java的NIO：*</u>**

现在 JVM 运行字节码的速率已经接近本地编译代码，借助动态运行时优化。这就意味着，多数 Java 应用程序已不再受 CPU 的束缚（把大量时间用在执行代码上），而更多时候是受 I/O 的束缚（等待数据传输）。然而，在大多数情况下， Java 应用程序并非真的受着 I/O 的束缚。操作系统并非不能快速传送数据，而是JVM自身在I/O方面效率欠佳。操作系统并非不能快速传送操作系统与 Java 基于流的 I/O模型有些不匹配，操作系统要移动的是大块数据（缓冲区），这往往是在硬件直接存储器存取（ DMA）的协助下完成的。而 JVM 的 I/O 类喜欢操作小块数据——单个字节、几行文本。结果操作系统送来整缓冲区的数据， java.io 的流数据类再花大量时间把它们拆成小块，往往拷贝一个小块就要往返于几层对象。操作系统喜欢整卡车地运来数据， java.io 类则喜欢一铲子一铲子地加工数据。

<u>*[todo: 该文章讲的底层DMA、虚拟内存、页面调度写的看待NIO很好](https://blog.csdn.net/fuyuwei2015/article/details/73436544)*</u>

同时这篇文章有个餐厅的例子还可以

NIO采用**内存映射文件**的方式来处理输入输出，NIO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样访问文件了

![](E:\_data\博文临时库\博文中的图片\NIO和DMA.png)

![NIO和DMA缓冲区发散汇聚](E:\_data\博文临时库\博文中的图片\NIO和DMA缓冲区发散汇聚.png)

![NIO和虚拟内存](E:\_data\博文临时库\博文中的图片\NIO和虚拟内存.png)



# 参考

> 1. [LINUX的五种IO模型](https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect)
> 2. [StackOverflow同步异步的一个问题](https://stackoverflow.com/questions/748175/asynchronous-vs-synchronous-execution-what-does-it-really-mean)