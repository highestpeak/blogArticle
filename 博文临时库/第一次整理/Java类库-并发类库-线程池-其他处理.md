# 线程池其他处理

<u>*todo：这部分其实应该当都成文*</u>

## ⭐常用线程池

可以调用工厂Executors来创建常用的线程池：

- `newFixedThreadPool(int nThreads)`
  - 创建有限的线程集，一次性预先执行代价高昂的线程分配，不必为每个任务都固定的付出创建线程的开销。
- `newCachedThreadPool()`
  - 在程序执行过程中通常会创建与所需数量相同的线程，然后在他回收旧线程时停止创建新线程。
- `newSingleThreadExecutor()`
  - 就像是线程数量为1的`FixedThreadPool`
  - 对于希望在另一个线程中连续运行的任何事物（**长期存活的任务**）来说，都是很有用的（例如：策略：监听进入的套接字连接的任务即`serversocket`、运行短任务如更新本地或远程日志的小任务或事件分发线程）
  - 向`SignalThreadExecutor`提交多个任务会**排队**；并且`SignalThreadExecutor`提供了一种重要的并发保证，**其他线程不会被并发调用，这会改变任务的加锁需求**，例如：策略：使用`SignalThreadExecutor`来运行需要访问文件系统的大量线程，在这种方式下， 不需要再共享资源上处理同步（不会过度使用文件系统）

Executors创建每一个类型的线程池，都额外含有一个构造方法，在常用构造方法的基础上添加了一个额外参数，即`ThreadFactory threadFactory`，例如`newSingleThreadExecutor(ThreadFactory threadFactory)`。

此外还有一些有趣的线程池：`newWorkStealingPool()` 、`newSingleThreadScheduledExecutor()` 、`newScheduledThreadPool(int corePoolSize)`

## 配置线程池

要想合理的配置线程池，就必须首先分析任务特性，根据不同类型的任务来选择不同的线程池。另外为了避免撑满系统内存，提高系统稳定性和预警能力，应当使用有界队列（有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千）。

通过采取任务拆分、不同规模的线程池处理不同类型的任务、有界队列来提高效率。

可以从以下几个角度来进行**分析任务特性**：

1. 任务的性质：**CPU密集型**任务，**IO密集型**任务和**混合型**任务。
2. 任务的**优先级**：高，中和低。
3. 任务的**执行时间**：长，中和短。
4. 任务的**依赖性**：是否依赖**其他系统资源**，如**数据库连接**。

针对不同特性的任务，可以**采取的措施**有：

- **CPU密集型**任务配置**尽可能少**的线程数量，如配置Ncpu+1个线程的线程池(Ncpu：cpu个数)。
- **IO密集型**任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置**尽可能多**的线程，如2*Ncpu。
- **混合型**的任务，如果可以拆分，则将其**拆分成一个CPU密集型任务和一个IO密集型任务**
  - **两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率**，
  - 两个任务执行时间相差太大，则没必要进行分解。
- **优先级不同的任务**可以使用**优先级队列**`PriorityBlockingQueue`来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么**优先级低的任务可能永远不能执行**。
- **执行时间不同的任务**可以交给**不同规模的线程池**来处理，或者也可以使用**优先级队列**，让执行时间短的任务先执行。
- **依赖数据库连接池的任务**，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么**线程数应该设置越大**，这样才能更好的利用CPU。

- 如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务
  - 但设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量

<u>*[todo： 在分布式配置中心配置线程池参数](https://zhuanlan.zhihu.com/p/123328822?utm_source=qq&utm_medium=social&utm_oi=644097353620000768)*</u>

`keepAliveTime`（线程活动保持时间）：所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。

`TimeUnit`（线程活动保持时间的单位）：

可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。

`workQueue`（任务队列）：当达到`corePoolSize`的时候，就向该等待队列放入线程信息（默认为一个`LinkedBlockingQueue`），运行中的线程属性为：workers，为一个`HashSet`；我们的Runnable内部被包装了一层；这个队列默认是一个无界队列（你也可以设定一个有界队列），所以在生产者疯狂生产的时候，需要考虑如何控制的问题。

（见下面的任务缓冲小节）



线程池一般核心线程数和最大线程数设为几？需要从哪些方面考虑？ cpu核、当前任务(I/O密集就设置大一些，cpu密集就设小一点)

## 监控线程池

有两种主要的监控方式：通过线程池提供的参数进行监控、通过扩展线程池进行监控

**通过线程池提供的参数进行监控**：

线程池里有一些属性在监控线程池的时候可以使用

- `taskCount`：线程池需要执行的任务数量。
- `completedTaskCount`：线程池在运行过程中已完成的任务数量。小于或等于`taskCount`。
- `largestPoolSize`：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。
- `getPoolSize`:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。
- `getActiveCount`：获取活动的线程数。

**通过扩展线程池进行监控**：（模板方法）

通过继承线程池并重写线程池的`beforeExecute`，`afterExecute`和`terminated`方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法，如：

``` java
protected void beforeExecute(Thread t, Runnable r) { }
```

# 