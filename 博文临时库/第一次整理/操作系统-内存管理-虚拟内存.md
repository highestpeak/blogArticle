使用虚存的话，进程从加载到虚存到执行到结束的完整步骤是什么？

虚存的结构是什么？虚拟地址空间是什么？

进程映像和虚拟内存



# 综述

内存分为两部分：操作系统使用和用户程序使用。虚拟内存让这样的划分后移到虚拟内存中，物理内存好像没有了这样的划分。

内存管理为了让物理内存中尽量有适当地就绪进程来占用处理器时间。内存管理要满足的需求有：重定位、保护、共享、逻辑组织、物理组织。

- 重定位就是寻址；
  - 寻址有很多任务，其中一个重要的任务就是把逻辑地址转为物理地址。重定位会涉及到基址和界限。
- 保护即确保进程只能访问分配给它的内存空间；
- 共享即对内存共享区域地受控访问；
- 逻辑组织即程序自身的内存视图，它们需要模块化，分段最符合这样的需求；
- 物理组织即内存的结构、也有外存的结构，由于内存可能不足，操作系统需要执行一些覆盖和置换。

重定位即寻址是最基本的需求，没有他就不能工作。保护和共享保证了程序能够正确的工作。区分逻辑组织和物理组织是一种更好的方案。

# 内存分区

分区技术需要考虑：内部碎片和外部碎片、内存利用率、放置策略、管理所需的CPU时间和开销。

固定分区、动态分区；简单分页、简单分段；虚存分页、虚存分段。它们都是一个是固定大小一个是可变大小，也由此产生了外部碎片或内部碎片。还有一种分区系统是伙伴系统。

从这个技术的列表中可以看到，分页不只是在虚存中的技术，它可以作为一种简单的分区技术，只涉及在进程和内存之间，而虚存涉及在硬盘、内存、进程之间。

---

分页和分段的区别就在于：大小是否固定，最后的地址是直接组合还是加法运算。

**分页：**内存和进程都划分成大小固定的小块，内存和进程划分的块的大小相等，这样就可以对应的进行分配。这样的转化需要一个页表（page table）

- 线程的块：页（page）；内存的块：页框（frame）
- 每个进程一个页表，页表项：物理地址的高位。
- 页和页框的大小都是2的幂次，这样就可以利用位运算

地址转换：

![](E:\_data\博文临时库\博文中的图片\drawio\操作系统-内存管理-分页.png)

**分段：**段的大小不固定但有最大长度，

- 每个进程有一个段表，段表项：段在内存中起始地址、段长度；
  - 段长度是为了确保不会出现无效地址
- 系统维护一个内存中的空现块列表

地址转换：

![](E:\_data\博文临时库\博文中的图片\drawio\操作系统-内存管理-分段.png)

# 虚拟内存

虚拟内存提供了三个重要的能力：

1. 把主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存了活动区域，并根据需要在磁盘和主存中来回传送数据，高效使用了主存
2. 为每个进程提供了一致的地址空间，并且相对于物理内存来说地址空间更大。进程可以比内存的全部空间还大。
3. 保护每个进程的地址空间不被其他进程破坏

要理解虚拟内存的原因：

- 虚拟内存是操作系统的核心：在硬件异常、汇编器、链接器、共享对象、文件和进程的设计中举足轻重。
- 虚拟内存提供了更强大的能力：创建和销毁内存片、将内存片映射到磁盘文件的某部分
  - 通过读写内存位置来都或者修改一个磁盘文件的内容
  - 加载一个文件的内容到内存，而不需要进行任何的显示复制
- 虚拟内存是一些危险错误的原因：段错误、保护错误
  - 如果一条指令违反了许可条件，CPU就出发一个保护故障，将控制传递给内核的异常处理程序。这样的错误称为段错误。

虚拟内存带来了很多好处：

- 可以有更多的进程常驻内存，因为内存中保存的只是进程的一部分
- 所有进程都认为它独占了内存，这给软件开发带来了便利
- 分页机制使得我们可以充分利用内存空间
- 由于虚存允许更多的进程把它们的块放到内存中，因此它支持更有效的系统并发度。

---

**地址和地址空间：**

- 虚地址（虚拟地址）：好像是主存的一部分，逻辑地址
- 实地址：内存中存储的地址
- 虚拟地址空间：分配给进程的虚拟存储
- 地址空间：某进程的内存地址范围（主存范围）

进程中的所有内存访问都是逻辑地址，逻辑地址会在运行时转换成物理地址，一个进程可划分成许多块（页或段），在运行时这些块不需要连续位于内存中，块可以被换入换出内存，占据不同区域。重要的是地址转换和页表段表。

CPU需要将虚拟地址转换成物理地址，这叫地址翻译。地址翻译需要CPU上的内存管理单元MMU，利用存放在主存的查询表来动态翻译虚拟地址，这个表由操作系统管理

![](E:\_data\博文临时库\博文中的图片\drawio\虚拟内存寻址.png)

---

其他：

- malloc分配的是虚拟内存

- 程序引用的不同页面总数可能超过物理内存总的大小，进程的虚存可能是不一样大的。但是虚拟内存工作得相当好，这主要归功于**局部性**。程序趋向于在一个较小的活动页面集合上工作，这个集合叫做工作集或**常驻集**。

  如果工作集大小超过了物理内存大小。那么程序将会产生抖动。

  - 在虚拟内存机制下，程序在执行过程中会因为所需的进程块没有装入内存而中断，但是局部性原理和一系列算法保证了虚拟内存的效率。
  - 系统抖动：处理器的大部分时间都用于交换块而非执行指令

- 虚拟内存简化了链接、加载、代码、数据共享和内存分配

  - 加载：

    虚拟内存使得向内存加载可执行文件更为容易。要把.text和.data加载到进程中，Linux加载器为代码和数据段分配虚拟页，把他们标记为无效（未被缓存的），将页表条目指向目标文件的适当位置。

    但是，加载器从不从磁盘到内存复制数据。只有在每个页初次被引用时，或者CPU取指令时，或者是指令引用到这个内存位置时，虚拟内存才会调入这个页面

    - 上面这样的将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称为内存映射，Linux提供了一个叫做`mmap`的系统调用做这个事情

  - 内存分配：

    如果调用malloc要求额外堆空间，操作系统分配适当数字个（例如k个）连续虚拟内存页面，并把它们映射到物理内存的任意位置的k个物理页面。

    由于页表工作的方式，操作系统没有必要分配k个连续的物理内存页面，页面随机地分散在物理内存中

[StackOverflow: What are the differences between virtual memory and physical memory?](https://stackoverflow.com/questions/14347206/what-are-the-differences-between-virtual-memory-and-physical-memory) 

---

## 页表

![](E:\_data\博文临时库\博文中的图片\虚拟内存-页表-物理内存.png)

虚拟内存系统需要判断虚拟页的位置在哪里，这样的功能是由软硬件联合提供的，包括：操作系统软件、MMU中的地址翻译硬件、物理内存中的页表，页表就是一个PTE（页表条目）数组。

操作系统为每个进程提供一个独立的页表，因而为每个进程提供一个独立的虚拟地址空间。

- 页表是常驻内存的

- 页表这样的机制也使得多个虚拟页面可以映射到同一个共享物理页面上。

  ![](E:\_data\博文临时库\博文中的图片\多个虚拟页面映射到同一个物理页面.png)

- 页表带来独立地址空间，而独立地地址空间使得区分不同进程的私有内存变得容易，通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。例如添加SUP位表示内核模式还是用户模式、添加READ和WRITE位控制对页面的读和写

- CPU有一个页表基址寄存器（PTBR）指向当前页表。

## 虚拟分页分段

每个进程都有他自己的页表和段表，大多数页表都保存在虚存中而不是实存中，页表同样符从分页管理即页表也会换入换出，此外页表必须至少有一部分唯一内存中。一些处理器采用两级页表。

虚拟内存的分页和分段是在上面的简单分页和简单分段上，每个项还需要：一位表示是否在内存中的存在位，一位表示内容是否修改的修改位

**虚拟分页：**

虚拟地址由页号和偏移量组成，每个进程有一个页表。进程在他的头部存有页表的起始地址，在寻址时，寄存器去除这个起始地址，和虚拟地址的页号部分相加得到页表项，从页表项中取出页框号，和虚拟地址的偏移量组合起来，成为了物理地址，

- 虚拟分页和简单分页的区别在于，简单分页是进程全部加载到内存中，虚拟分页在页号部分还有一个相加的操作，因为页表不知道存在哪里

![](E:\_data\博文临时库\博文中的图片\drawio\操作系统-内存管理-虚拟分页.png)

**TLB转换检测缓冲区（页表的高速缓存）：**

每次虚存访问可能会引起两次物理访问：一次取页表项，另一次取需要的数据。所以为了减少取页表项这个时间，采用了TLB

加上TLB之后，访问过程先去TLB检索页表项，没有找到才回去内存中的页表检索

**虚存和高速缓存：**

<u>*todo：没有画图*</u>

先从TLB或内存页表组合出物理地址，然后去高速缓存查找，不命中则去内存查找。

![](E:\_data\博文临时库\博文中的图片\drawio\操作系统-内存管理-虚拟页表加TLB.png)

**段页式：**

每段划分出固定大小的页，页的长度等于内存中页框的大小，若某段的长度小于一夜，则改段只占据一页。从程序员的角度看，逻辑地址（虚拟地址）仍然由段号和段偏移量组成。从操作系统角度看，段偏移量可视为指定段中的一个页号和页偏移量。最后的物理地址是页框号组合偏移量，也就是说段页式的系统也是按照页来划分内存的。段是一组页。

每个进程都有一个段表和一些页表，每个段有一个页表。段表项包含端的长度和指向它的页表的基址，段表不需要存在位和修改位因为它们在页表项中，但可能也有其他控制位。

![](E:\_data\博文临时库\博文中的图片\drawio\操作系统-内存管理-虚拟段页式.png)

## 缺页处理

缺页处理流程：

1. 触发缺页异常，调用内核中的缺页异常处理程序，该程序会选取一个牺牲页
   - 在这个过程中会涉及到**页面调度/页面置换算法**
2. 内核复制目标虚拟页到内存中的物理页，更新页表项
3. 缺页异常处理程序返回，重新启动导致缺页的指令，该指令把虚拟地址重新发送到地址翻译硬件MMU。这次MMU就能正常翻译地址

缺页异常处理程序：

1. 首先判断虚拟地址A是否合法，即A是否在某个区域结构内

   缺页处理程序搜索`vm_area_structs`链表，把A和每个节点的`vm_start`和`vm_end`作比较，如果不合法，就触发一个段错误，结束进程

   - Linux不会顺序搜索区域结构，他在链表的基础上维护了一棵树，在这棵树上查找

2. 判断内存访问是否合法，判断是否有读写或执行这个区域内页面的权限。

   如果不合法，就触发保护异常终止进程

3. 合法操作：

   选择一个牺牲页面，如果这个页面被修改过，那么久将它换出去，换入新的页面更新页表。

![](E:\_data\博文临时库\博文中的图片\缺页异常处理.png)

## 页面置换算法

<u>*todo：没有详细的看还*</u>

- 最佳（OPT）：置换下次访问据当前时间最长的项。不可能实现，因为需要预测未来，
- 最近最少使用（LRU）：置换内存中最长时间未被使用的页。效果好但实现起来复杂开销大
- 先进先出（FIFO）：置换驻留内存时间最长的页。效果差
- 时钟（Clock）：一个环状
  - 如果需要置换一个页， OS扫描缓冲区。查找使用位为0的页框，每当遇到一个使用位为1的框就置它的使用位为0，选择遇到的第一个使用位为0的页框进行置换

# Linux虚拟内存系统

Linux为每个进程维护了一个单独的地址空间。Linux将虚拟内存组织成一些区域（也叫段）的集合。一个区域就是已经存在的虚拟内存的连续片。

- 代码段、数据段、堆、共享库和用户栈都是不同的区域。
- 每个存在的虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在的
- 区域的概念允许虚拟地址空间有间隙

Linux为每个进程维护了一个任务结构`task_struct`，task_struct的一个条目指向了一个mm_struct，mm_struct描述了当前虚拟内存的状态，mm_struct有两个重要字段：`pgd`和`mmap`，`pgd`指向第一级页表，`mmap`指向一个`vm_area_structs`链表

![](E:\_data\博文临时库\博文中的图片\task_struct.png)

# 内存映射

Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来来初始化这个区域内容，这叫做内存映射。虚拟内存区域可以映射两种类型对象：

- Linux的普通文件：映射这个文件的连续部分，如果区域比文件大，就用零来填充区域剩余部分
- 匿名文件：匿名文件由内核创建，包含的全是二进制零

无论哪种情况，一个虚拟页面一旦被初始化，他就在一个由内核维护的专门的交换文件之间换来换去。交换文件也叫做交换空间。交换空间限制着当前运行着的进程能够分配到的虚拟页面的总数。

---

**共享对象：**

一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们的虚拟内存的其他进程而言，也是可见的。而且，这些变化也会反映到磁盘的原始对象中。

一个映射到共享对象的虚拟内存区域叫做共享区域，类似地也有私有区域。

![](E:\_data\博文临时库\博文中的图片\drawio\内存映射共享对象.png)

因为每个对象都有一个唯一的文件名，内核可以迅速判定进程1已经映射了这个对象，而且可以使进程2中的页表条目指向相应的物理页面。关键点在于即使对象被映射到了多个共享区域，物理内存中也只需要存放共享对象的一个副本。

---

**私有对象写时复制：**

私有对象使用一种叫做写时复制（copy-on-write）的巧妙技术被映射到虚拟内存中。

一个私有对象在开始时和共享对象一样，在物理内存中只保存私有对象的一份副本。对于每个映射私有对象的进程，相应的私有区域的页表条目都会被标记为只读，并且区域结构被标记为私有的写时复制。

只要没有进程试图写这个区域，它们就可以继续共享同一个副本。然而只要有一个进程试图写私有区域的某个页面，那么这个写操作就会触发一个保护故障。然后故障处理程序会创建这个待修改区域的页面的一个新副本，并更新相应的页表条目。然后故障处理程序返回，CPU重新执行写操作。

![](E:\_data\博文临时库\博文中的图片\drawio\内存映射私有对象.png)

Linux进程可以通过`mmap`函数来创建新的虚拟内存区域，并将对象映射到这些区域中。

![](E:\_data\博文临时库\博文中的图片\drawio\mmap内存映射可视化解释.png)

