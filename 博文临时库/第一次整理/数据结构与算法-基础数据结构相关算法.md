数据结构其实就是线性数据结构和空间数据结构。也就是数组和树。

# 数组

- [数组前缀和](https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7.md)：

  ``` java
   for (int i = 0; i < n; i++)
          sum[i + 1] = sum[i] + nums[i];
  ```

- [和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

- 顺时针打印矩阵

- 数组中有一个数字出现的次数超过数组长度的一半，找出这个数字

  摩尔投票法

- 给定两个有序数组arr1和arr2，再给定一个整数k，返回来自arr1和arr2的两个数相加和最大的前k个，两个数必须分别来自两个数组，按照降序输出，时间复杂度为`O(klogk)`。用大顶堆

  https://blog.csdn.net/qq_34342154/article/details/78491408

- 最大值减去最小值小于或等于`num`的子数组数量

- 运用数组的一次遍历、两次便利等获得的辅助数值

  这个在数组前缀和、能看到的高楼数、接雨水中都可以用到，在下面两个题也可以用到

  - 给定一个数组，只有一个数出现了一次，其余出现了两次，怎么找出来
  - 给定一个数组，只有两个数出现了一次，其余出现了两次，怎么找出来

## 哈希

- [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)

  [原地哈希](https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/)

- 

# 链表

- 从尾到头打印链表

  用栈，每次把Node压栈。一次遍历之后while循环弹出打印

- O(1)时间删除链表节点

  如果删除非末尾节点，则把当前节点地值替换为下一个节点地值，next替换为next的next。

  如果是末尾节点就要从头到尾遍历，把倒数第二个的next赋为null

- 反转链表

  ``` java
  public Node reverseList(Node head){
      if(head==null){
  		return null;
      }
      Node tmp=null;
      while(head!=null){ // 注意这个条件
          Node curr=head.next;
          head.next=tmp;
          tmp=head;
          head=curr;
      }
      return tmp; // 注意这个返回值
  }
  ```

- 链表第K个节点

  两个指针，快指针走k步然后慢指针再走

  - 找到链表中点：快指针走两步，慢指针走一步

- 合并两个有序链表，使得合成后链表满足单调不减

  - 递归求解

    ``` java
    public Node merge(Node list1,Node list2){
        if(list1==null){
            return list2;
        }
        if(list2==null){
            return list1;
        }
        
        Node newHead=null;
        if(list1.val<list2.val){
            newHead=list1;
            newHead.next=merge(list1.next,list2);
        }else{
            newHead=list2;
            newHead.next=merge(list1,list2.next);
        }
        
        return newHead;
    }
    ```

  - 非递归求解

    ``` java
    public static ListNode<Integer> merge(ListNode<Integer> list1, ListNode<Integer> list2){
        if(list1==null){
            return list2;
        }
        if(list2==null){
            return list1;
        }
    
        ListNode<Integer> small=null,big=null;
        if(list1.val<list2.val){
            small=list1;
            big=list2;
        }else{
            small=list2;
            big=list1;
        }
    
        ListNode<Integer> walk=small;
        ListNode<Integer> newHead=walk;
        small=small.next;
        while(small!=null && big!=null){
            if(small.val<big.val){
                walk.next=small;
                small=small.next;
            }else{
                walk.next=big;
                big=big.next;
            }
            walk=walk.next;
        }
        walk.next=small==null?big:small;
        return newHead;
    }
    ```

- 如果两个链表可能会相交怎么合并

- n个有序链表合并，内存较小，不能直接加载到内存

- [复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)：每个节点两个指针：random和next

  HashMap记录节点

- 单向链表找中间值（两个指针）

- 相交链表、环形链表

- 计算两个链表的数值之和，结果返回一个链表

  

  







# 栈和队列

- 两个栈模拟队列

  ``` java
  public void push(int node){
      stack1.push(node)
  }
  public int pop(){
      if(stack1.isEmpty() && stack2.isEmpty()){
          throw new Exception("空队列");
      }
      if(stack2.isEmpty()){ // 这里是关键
          while(!stack1.isEmpty()){
              stack2.push(stack1.pop());
          }
      }
      return stack2.pop();
  }
  ```

- 队列模拟一个栈

  - 法1：两个队列

    入栈：将元素进队列A。

    出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列；如果A中元素多于1，则将队列A中的元素以此出队并放入队列B，直到队列A中的元素留下一个，然后队列A出队列；否则，A为空，同理将B转移到A直至剩一个。

  - 法2：一个队列

    不断地执行`queue.push(queue.pop())`，也就是把队列前面地元素再放到队列尾部。入栈直接push，出栈将前n-1出队再push。

- 包含min函数的栈（定义两个栈，一个存放入的值，一个存最小值）

- 判断一个栈是不是另一个栈的弹出序列

  ``` java
  public boolean isPopOrder(int[] push,int[] pop){
      if(push==null || pop==null){
          return false;
      }
      Stack<Integer> stack=new Stack<>();
      
      int popIndex=0;
      for(int i=0;i<push.length;i++){
          stack.push(push[i]);
          while(!stack.isEmpty() && stack.peek()==pop[popIndex]){
              stack.pop();
              popIndex++;
          }
      }
      return stack.isEmpty();
  }
  ```
  
- 

  

# 树

- 重建二叉树

  - 前序和后序不能唯一确认一棵树，但是可以确认树的几种情况。
  - 只要有中序就能唯一确认一棵树，即中序加前序、中序加后序

  前序中序重建二叉树，中序后序重建二叉树
  
  如果是二叉搜索树又是不同的情形
  
- 判断二叉树A是否包含子树B

- 二叉树镜像（递归和非递归左右子树）

- 层次遍历二叉树（队列）

- 判断序列是否是二叉搜索树的后序序列

- 二叉树路径

  - 路径定义为从根节点到叶节点

    打印出节点和为目标值的所有路径

- ⭐二叉树转双向链表，只能改变节点指针指向，不能添加新节点

- 路径不过根节点

  - [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)

  - [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

    ``` sql
    class Solution {
        int max;
        public int maxPathSum(TreeNode root) {
            max=root.val;
            help(root);
            return max;
        }
    
        public int help(TreeNode root) {
            if(root==null){
                return 0;
            }
            int left=Math.max(help(root.left),0);
            int right=Math.max(help(root.right),0);
            max=Math.max(max,left+right+root.val);
            return Math.max(left,right)+root.val;
        }
    }
    ```

- 数组转平衡二叉树

- 二叉树前中后序（非递归）

- 哈夫曼树原理

- 多叉树，求高度 非递归

  ``` c++
  int maxDepth(Node* root) {
      if (!root) return 0;
      queue<Node*>queue;
      queue.push(root);
      int max_depth = 0;
      while (!queue.empty()) {
          max_depth++;			
          for (int size = queue.size(); size; size--) {
              Node* curr = queue.front(); queue.pop();
              for (Node* it : curr->children)
                  queue.push(it);
          }
      }
      return max_depth;
  }
  ```

- 判断一棵树是否是二叉搜索树









