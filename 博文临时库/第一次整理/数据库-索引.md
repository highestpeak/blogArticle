---

---

<u>*todo：索引其实也是一种数据结构的应用，在数据结构课本上的第十章索引技术有大量讲解。大有收获。*</u>

<u>*todo：这一大段一直到索引综述的内容，到底是要放在数据结构下还是要放在数据库下*</u>

# 索引综述

从索引这个词来说，索引是一个过程、也是一种文件结构。

索引设立的原因归于一点就是我们不想去对所有数据进行一遍从头到尾的扫描。具体到场景中：

- 索引很小，可放到主存，可减少磁盘访问：

  表可能因为太大而不能放到主存，而且可能频繁读写磁盘或进行外排序。如果使用索引则由于索引只记录关键码，所以索引很小，可以很大程度减少磁盘访问。

- 查询的特性：许多查询只涉及少量记录和部分记录

  类似“找出物理系的所有教师“或者”找出ID是22201的学生的总学分“的查询，只涉及记录中的一小部分。

  系统不需要低效的读取关系表中的每一个元组并检查是否满足某种条件

索引对查询的速度有着至关重要的影响，索引是进行数据库性能调优的极其重要的方式之一。

索引是在存储引擎中实现的，索引只能创建在表上，不能创建在视图上。通常需要在一个文件上建立多个索引，如果文件具有多个索引，无论何时修改文件，它的每个索引都必须更新。

---

创建索引有很多**好处**：

- 加快数据的检索速度（最主要）
  
  主要是避免了全表扫描，减少了扫描行数
  
  - 加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义
  - 减少分组和排序时间（不使用索引的话可能会创建大量临时表）
  - 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能
  
- 大多数数据库实现会在主码上自动创建一个索引，该索引就可以用来检查没有违反主码约束（即没有重复的主码值，保证唯一性）

- 避免了临时表的创建

- 把随机IO变成顺序IO（B+Tree 索引是有序的，会将相邻的数据都存储在一起）

- 可以直接在索引中存储数据，进而查询在命中索引后就可以直接返回，不需要再去访问记录（覆盖索引）

但是建立索引也不是万能的，他也有**缺点**：

- 表大小的影响：

  - 对于非常小的表，大部分情况下简单的全表扫描更高效
  - 对于中到大型的表，索引就非常有效
  - 对于特大型的表，建立、使用、维护索引的代价将随之增长
    - 可以使用分区技术

- 降低写入速度：

  索引会降低写入数据的速度，因为写入数据后就需要更新索引，对表中的数据进行增加、删除和修改的时候，索引也要动态的维护

- 增加占用空间：

  索引也是需要占据物理空间的，而且创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加，即表越大，索引越大。

---

索引有不同的类别，不同的实现，**对索引的评价需要考虑的因素有**：

- 访问类型：查找特定属性值和某个范围的记录
- 访问时间
- 插入、删除时间：对数据项的操作时间以及对索引结构的操作时间
- 额外空间开销

---

- 辅助索引的例子：

  在StackOverflow上看到一个描述索引的例子，这个例子很好，特别是作为辅助索引的例子很好：

  来自：https://stackoverflow.com/questions/1108/how-does-database-indexing-work

  经典示例“书籍索引”：考虑一本1000页的“书”，分为10章，每节100页。

  现在，假设您想查找包含单词“ Alchemist ” 的特定章节。没有索引页，除了浏览整本书/章节之外，您别无选择。即：1000页。这个类比在数据库世界中被称为“全表扫描”。

  但是有了索引页，您就知道要去哪里！而且，要查找任何重要的特定章节，您只需每次都一次又一次地浏览索引页面。找到匹配的索引后，您可以通过跳过其余部分来有效地跳到该章。

  从上面看出，除了实际的1000页之外，您还需要约10页来显示索引，因此总共需要1010页。

- 稀疏索引的例子：

  考虑一本（印刷好的）字典。每页页眉都顺序地列出了该页中按字母序出现的第一个单词。字典中每页顶部的单词共同构成了字典页内容的稀疏索引。

# 索引类型

索引分类：

1. 存储结构上（索引存储时保存的形式）：

   - 顺序索引
     - B Tree索引（B-Tree或B+Tree索引）
   - 哈希索引
   - Full-text 索引 （全文索引）
   - R-Tree 索引 （空间索引）

2. 物理存储上：

   - 聚集索引 和 非聚集索引 
   - 稠密索引 和 稀疏索引

3. 逻辑上：

   - 主键索引
- 单列索引（普通索引） 和 多列索引（复合索引）（多码索引）（联合索引）
   - 唯一索引 和 非唯一索引
  - 唯一索引的索引列的所有值都只能出现一次，即必须唯一
  
4. 其他：

   - 覆盖索引
   - 多级索引

## 存储结构

### 散列索引

散列索引检索效率非常高，索引的检索往往可以一次定位（需要好的散列函数）。但是如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。

散列索引对于插入、删除、修改一般提供了很好的性能，但对于一些其他情况不能有效支持，这些情况有：

1. 记录的范围查询

   仅仅能满足"=","IN"和"<=>"这类等值查询

2. 按顺序访问记录

   - 找最大最小关键码值的记录

3. 不支持多列联合索引的最左匹配规则 

对于这样的情况就要找其他的解决方案，其实也就是我们要说的线性索引/B+树索引。

哈希索引分类：

- 静态散列：
  - 桶不足和桶偏斜
  - 溢出桶和溢出链
    - 开地址、闭地址
- 动态散列：（可扩充散列）
  - 动态散列比静态散列多了一个附加的间接层
  - 散列前缀
  - 几种动态散列（ dynamic hashing）技术允许散列函数动态改变，以适应数据库增大或缩小的需要

> 自适应哈希索引

InnoDB 引擎有一个特殊的功能叫 “自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找

### 顺序索引

要想明白顺序索引，明白索引的演进是很重要的，或者说看一下自然情况下我们的思考会产生什么样的想法，以及为什么到目前采用了B+树索引居多。

从下面的论述中我们会始终发现我们想要的目标只有一个：降低查找次数，包括但不限于我们不断地利用二分查找的特性，以及一系列的树平衡手段。我们的目标就是尽可能快：最大程度减少磁盘读写。

---

首先我们会自然的想到线性索引：

- 线性索引能够提供对记录高效的检索和随机访问，这是因为它支持**二分检索**。

  但是二分检索可能会需要多次磁盘访问，这样做代价很高，所以就出现了二级线性索引等。

- 使用线性索引读取记录就会设计“两次”磁盘读取：一次读索引文件，一次读数据库文件。

缺点：线性索引不能很好的完成插入、删除操作。

- 从数组和链表的学习中我们可以猜想到线性索引的更新代价很高，因为数组的全部内容都要移动一个位置。
- 线性索引的另一个缺点是可能有大量的重复关键码，这样就很浪费空间。
- 随着文件的增大，索引查找性能和数据顺序扫描性能都会下降。虽然这种性能下降可以通过对文件进行重新组织来弥补，但是我们不希望频繁地进行重组。

针对这样的缺点，我们还可以改进：例如采用二维数组。二维线性索引：每一列列出与某个辅码值相关的主码。

![](E:\_data\博文临时库\博文中的图片\drawio\索引-二维数组索引.png)

上面这样需要固定数组长度，一种更好的方法是有一个辅码值的一维数组，每个辅码值与一个链表关联。如果索引存储在主存中，这样做能工作得很好，但是当索引存储在磁盘就不一样了：关键码的链表可能分散在多个磁盘块中。

![](E:\_data\博文临时库\博文中的图片\drawio\索引-倒排表索引.png)

其他：

- ISAM索引是一个IBM曾经广泛使用的索引，它是一种线性索引的改进形式。

---

如果能把线性索引分成多个快，每次更新之影响其中一部分索引，那么线性索引作为主码索引还是很好的，这种思想就汇集到了今天最广泛使用的索引方法——B+树中。（每次只影响一部分这个想法也贯穿了CS学科本身）

B+Tree 因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。

B+Tree 可以指定多个列作为索引列，多个索引列共同组成键。当前情况下B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。

B+树结构会增加文件插入和删除处理的性能开销，同时会增加空间开销，但是能够减小文件重组的代价

B+树的非叶结点（ `nonleaf node`）形成叶结点上的一个多级（稀疏）索引

树状索引（B树索引）可以有序的访问一些块，这些块很**契合磁盘的的物理结构**（磁盘最小单位是一个一个的**块**），在另一种程度上相当于给磁盘这种结构量身定做的索引结构。（在新的技术下，对于SSD等基于闪存的存储器的定做的数据库是否有？不得而知？换句话说是否有必要这么量身定做？）

<img src="E:\_data\博文临时库\博文中的图片\数据库索引-B+树索引结构图.png" style="zoom:75%;" />

### 其他

> 不唯一的搜索码：

如果两条或者多条记录在索引属性上拥有相同的值，那么该搜索码称为不唯一搜索码（ nonunique search key）。

- 创建复合搜索码：

  不唯一的搜索码在记录删除效率方面，可能有问题，该搜索有可能遍历多个叶结点。一种简单的解决方法是通过创建包含原始搜索码和其他属性的复合搜索码来确保搜索码唯一。

- 搜索码值维护一个记录指针的桶：

  对于不唯一搜索码，一个码值在多少条记录中出现，B'树结构就存储该码值多少次。另外一种方法是在该树中每个码值只存储一次，并且为该搜索码值维护一个记录指针的桶（或者说链表）来解决不唯搜索码问题。因为它只存储码值一次

> 为什么索引结构默认使用B+Tree，而不是B+树，二叉树，红黑树

B树内部节点存数据会增大IO，B+树数据全在叶子节点，局部性更好。B+树这样可以支持范围查询。B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题

红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁（因为同一个节点B+树可以相对于红黑树有更多的子节点，从而降低了树高度减少了磁盘IO）

数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

## 物理存储

首先介绍**稠密索引和稀疏索引：**

- 稠密索引：每个搜索码值都有一个索引项
  - 比稀疏索引更快地定位一条记录
  - 辅助索引必须是稠密索引
  - 稠密聚集索引具有相同搜索码值的记录顺序存储在第一条数据记录之后
- 稀疏索引：只有某些搜索码值有索引项
  - 只有索引是聚集索引时才能使用
  - 相较于稠密索引，占空间较小，并且插入和删除时所需的维护开销也较小
  - 考虑一本（印刷好的）字典。每页页眉都顺序地列出了该页中按字母序出现的第一个单词。字典中每页顶部的单词共同构成了字典页内容的稀疏索引。

**为每个块建一个索引项的稀疏索引是一个较好的折中**。原因在于，处理数据库查询的开销主要由把块从磁盘读到主存中的时间决定。一旦将块放入主存，扫描整个块的时间就是可以忽略的。使用这样的稀疏索引，可以定位包含所要查找记录的块。这样，只要记录不在溢出块中，就能使块访问次数最小，同时能保持索引尽可能小（因而也就减少了空间开销）。

<img src="E:\_data\博文临时库\博文中的图片\数据库索引-稠密索引和稀疏索引.png" style="zoom: 75%;" />

---

然后介绍**聚集索引和辅助索引：**

- 本质区别：聚集索引是最后叶节点存储记录，辅助索引最后是叶节点存储聚集索引的索引值。所以聚集索引表记录的排列顺序和与索引的排列顺序一致。

辅助索引记录聚集索引的键码值外，还有一种实现方式：即间接的指针层

- 可以用一个附加的间接指针层来实现非候选码的搜索码上的非聚集索引。在这样的非聚集索引中指针并不直接指向文件，而是指向一个包含文件指针的桶

  <img src="E:\_data\博文临时库\博文中的图片\数据库索引-辅助索引.png" style="zoom:75%;" />

### 聚集索引

- 顺序：索引中键值的逻辑顺序决定了表中相应行的物理顺序
- 键码类型：常常是主码，但是也可使其他搜索码
  - 一个表只能有一个聚集索引，但该索引可以包含多个列（组合索引）
- 顺序扫描快：按聚集索引顺序对文件进行顺序扫描是非常有效的，因为文件中记录的物理存储顺序和索引顺序一致
- 修改慢：对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排， 降低了执行速度
  - 字符串类型不宜建立聚簇索引，特别是随机字符串，会使得系统进行大量的移动操作，字符串上建立见下面陈述

### 辅助索引

- 辅助索引能够提高使用聚集索引搜索码以外的码的查询性能。

- 更新的开销：辅助索引显著增加了数据库更新的开销。数据库设计者根据对查询和更新相对频率的估计来决定哪些辅助索引是需要的

- 必须是稠密索引

  因为如果非聚集索引只存储部分搜索码值（即采用稀疏索引），两个有索引项的搜索码值之间的搜索码值所对应的记录可能存在于文件中的任何地方，并且我们通常只能通过扫描整个文件才能找到它们

- 常见的实现是：存储主索引搜索码属性的值。这样的话查找一个记录需要进行两次B－TREE查找而不是一次。

  这降低了由文件重组导致的索引更新的代价，尽管它也增加了使用辅助索引访问数据的代价

  （这个过程好像很多人叫他回表）

- 覆盖索引：

  辅助索引上存储的键码值就已经满足了查询需要，不需要再去查询聚集索引。这样就不需要再去查找。（这是个特殊情况，即不需要回表的特殊情况）
  
  在select后写上具体字段可以增加使用覆盖索引的概率

### 其他

> 字符串上的索引：

字符串的存储有几个问题

- 第一个问题是字符串是变长的。
- 第二个问题是字符串可能会很长，导致结点扇出降低以及相应地增加树的高度

使用前缀压缩（prefix compression）技术可以增加结点的扇出。使用前缀压缩技术，不用在非叶结点存储整个搜索码值。只须存储每个搜索码值的一个前缀，使得这个前缀足以将由该搜索码值分开的两棵子树中的码值区分开。

例如，假如我们有一个建立在名字上的索引，非叶结点的码值可以是名字的一个前缀；如果由搜索码分开的两棵子树中跟`“Silberschatz”`最相近的码值分别是`“Silas"`和`“Silver”`，则在非叶结点中存储`“Slib”`就足够了，而不用存储全名`“Silberschatz”`。

> 大数据量类型的索引，前缀索引：

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。前缀长度的选取需要根据索引选择性来确定。

- 对于这样的类型我觉得也可以生成一个键码，例如通过hash算法，或者存储文件路径等

## 多列索引

多列索引又称联合索引

---

最左前缀原则：

多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用

例如在A、B、C三个列上建立多列索引（建立顺序为：(A,B,C)），那么相当于建立了(A,B,C)、(A,B)、(A)三种列组合上的索引

- 最左前缀原则会在遇到范围查询、or查询等时失效
  - 例如：一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的
  - 也就是范围查询最好位于匹配条件的后面，即范围查询的列在联合索引中越靠后越好

- 这个原则就提示我们需要把最常用的，筛选数据最多的字段放在左侧

- 为什么需要最左前缀原则：

  假如我们建立 `(a,b)` 联合索引。那么B+树是按照a来进行排序，在a相等的情况下，才按b来排序。

  因此，我们可以看到a是有序的1，1，2，2，3，3。而b是一种全局无序，局部相对有序状态。这就是原因

----

> 多个列分别建立索引  和  多个列联合建立索引的区别

假设 instructor文件有两个索引，分别建立在 *`dept_name`*和 *`salary`*上。考虑如下查询：“找出金融系中工资为$80000的所有教师。” 我们写作`where dept_name ="Finance"and salary =80000`

处理这个查询可以有三种策略：

1. 利用 *`dept_name`*上的索引，找出属于金融系的所有记录。检查每条记录是否满足 salary=
   80000。
2. 利用 *`salary`*上的索引，找出所有工资等于$80000的记录。检查每条记录是否满足*`dept_name="Finance"`* 
3. 利用 *`dept_name`*上的索引找出指向属于金融系的记录的所有指针。同样，利用*`salary`*上的索引找出指向工资等于880000的记录的所有指针。计算这两个指针集合的交。交集中的那些指针指向金融系中工资等于880000的记录。

上面三种策略中只有第三种利用了存在的多个索引的优势。然而，如果下面所有条件都成立，即使这种策略也可能是很糟糕的选择：

- 属于金融系的记录太多。
- 余额为$80000的记录太多。
- 金融系中工资为$80000的记录只有几个。

如果这些条件成立的话，为了得到一个很小的结果集，我们必须扫描大量指针。

一种称为“位图索引”的索引结构在某些情况下可以加速第三种策略中使用的集合交的操作。

> 多列索引处理范围查询 高效和低效情况

考虑以下的查询:

``` sql
-- 一个范围
select ID from instructor where dept_name="Finance"and salary < 80000;
-- 两个范围
select ID from instructor where dept_name<"Finance"and salary < 80000;
```

我们可以使用建立在搜索码*`（ dept_name, salan）`*上的顺序索引来回答这个查询：对于按字母顺序小于`"Finance"`的每*`dept_name`*值，系统定位 `salary`值为80000的那些记录。然而，由于文件中记录的顺序，每条记录可能位于不同的磁盘块，因此导致大量IO操作。

两个查询的区别在于第一个属性`dept_name`上的条件是比较条件还是等值条件。这个条件不能对应于搜索码上的一个范围查询。

为了加速处理符合搜索码的查询，可以使用特殊的结构：采用位图索引和R树索引（地理数据类型）。两个范围的查询本质上和查找二维地图平面上一个矩形范围内的数据查询相同，因此R树索引是合适的。

## 其他索引

- 覆盖索引

  辅助索引上存储的键码值就已经满足了查询需要，不需要再去查询聚集索引。这样就不需要再去查找。（这是个特殊情况，即不需要回表的特殊情况）

- 多级索引：
  - 如果索引过大而不能放在主存中，那么当需要时，就必须从磁盘中取索引块，因此引入了多级索引（这个和虚拟内存映射的多级页表有异曲同工之处）。
  - 利用多级索引搜索记录与用二分法搜索记录相比需要的IO操作要少得多。
  - 多级索引和树结构紧密相关
  
- 全文索引

  MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE

- 空间数据索引（R-Tree）

  MyISAM 存储引擎支持空间数据索引，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

- 倒排索引

  见上面的顺序索引中的介绍

---

**覆盖索引：**

覆盖索引就是查询字段与条件的数据所需要的值就在索引中，不需要通过索引再去查找记录。当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。

- 包括Select、Join和Where子句

例如student的辅助索引name就包含了name的具体值，不需要我们通过找到name后再去查一遍聚集索引。

- 存储了搜索码和指向记录的指针
- 存储了属性的值（但不是搜索码属性），索引包含满足查询的数据
- 建立多码索引也可以达到相同效果

只需要读取索引而不用读取数据有以下一些优点：

- 索引项通常比记录要小，所以访问更少的数据；

- 索引都按值的大小顺序存储，相对于随机访问记录，需要更少的I/O；

- 大多数据引擎能更好的缓存索引。比如MyISAM只缓存索引。

- 对辅助索引存储聚集索引键码值的实现有大用处：

  覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了

# 准则/优化

这一节从各种各样的索引失效条件入手；分析我们创建和使用索引的准则，也就是最佳实践；这些准则也能知道我们对SQL进行优化。

- 可以使用explain语句查看是否使用索引

- =和in可以乱序，即等值条件可以乱序

  比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序

---

## 失效情况

- 索引参与了运算：

  - 数据类型出现隐式转换的时候也不会使用索引，例如，`where 'age'+10=30`

  - 对索引列进行函数运算

    https://tech.meituan.com/2014/06/30/mysql-index.html

- 最左前缀：

  复合索引的情况下，假如查询条件不包含索引列最左边部分，即不满足最左原则 leftmost，是不会使用复合索引的

- 范围查询：

  - 用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到
  - 使用负向查询（not ，not in， not like ，<> ,!= ,!> ,!< ） 不会使用索引

- 字符串匹配：

  - 模糊匹配：以%开头的 like 查询不能利用 B-Tree 索引
  - 正则表达式不会使用索引
  - 字符串和数据比较不会使用索引

- MySQL优化器：

  如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引

## 创建准则

``` sql
CREATE INDEX indexName ON table_name (column_name)
```

- 经常select搜索、join连接、group by分组、order by排序、WHERE子句使用、distinct、union等集合操作的列

- 作为主键、外键的列

- 经常需要根据范围进行搜索的列

- 索引本身的字段大小应该尽可能小

- 联合索引：

  考虑使用索引覆盖。对数据很少被更新的表，如果用户经常只查询其中的几个字段，可以考虑在这几个字段上建立索引，从而将表的扫描改变为索引的扫描。

- 表大小：

  - 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
  - 对于中到大型的表，索引就非常有效；
  - 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

不应该创建的情况：

- 区分度低、数据重复且分布平均的列：即只有很少数据值的列，如性别列

  区分度的公式是`count(distinct col)/count(*)`，表示字段不重复的比例。

  这个比例越大我们扫描的记录数越少，唯一键的区分度是1。

  而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

- 很少使用的列

- 大数据类型的列：

  定义为text, image和bit数据类型的列

- 经常插入、删除、修改的表

  - 修改远远大于检索时，不应该创建索引

  - 当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引

- 经常和主字段一块查询但主字段索引值比较多的表字段

---

多列索引如何建立索引的习题：

https://zhuanlan.zhihu.com/p/115778804

## 索引优化

- 索引列不能参与运算

  如`from_unixtime(create_time) = '2014-05-29'`。该语句应该写成`create_time = unix_timestamp('2014-05-29')`。

- 最左前缀匹配原则

- 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

- 前缀索引：

  对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

  前缀长度的选取需要根据索引选择性来确定。

- or的两侧要么都索引列，要么都不是索引列啊

# 其他

## 索引的批量加载

关系比主存大得多，索引也比主存大得多，那么这样的话操作的数据或索引可能就不再缓冲区中。

将大量项一次插入到索引中称为索引的批量加载（ bulk loading）。一种有效执行索引批量加载的方式如下：

- 首先，创建一个含有关系索引项的临时文件

- 然后根据构建好的索引的搜索码来排序文件

- 最后扫描排序好的文件并且将项插人到索引中。

  目前存在一些对于大关系的排序算法。假设主存容量够，即便对于一个很大的文件进行排序，该算法需要的IO代价与读几次文件相当

在将项插入到B‘树之前进行排序具有明显的好处。在项按排序进行插入后，所有到特定叶结点的项将会连续出现，并且叶结点只需要写出一次。

# 参考

> 1. [mysql索引之一：索引基础（B-Tree索引、哈希索引、聚簇索引、全文(Full-text)索引区别）（唯一索引、最左前缀索引、前缀索引、多列索引）](https://www.cnblogs.com/duanxz/p/3799045.html)
> 2. [MySQL索引问题](https://segmentfault.com/a/1190000020621056)
> 3. 

