# 事务

数据库事务由一个有限的数据库操作序列构成，通常包含了一个序列的对数据库的读/写操作。(我的一个理解是：一个序列包含一系列的操作，操作可能是原子操作。从整体角度看，可以把事务看成大的“原子操作”[和之前原子操作意义不同]，即事务的原子性)

## 事务为何出现

（事务的目的和目标）

**简化编程模型，为应用服务**：事务的产生，是为了当应用程序访问数据库的时候，事务能够<u>*简化编程模型*</u>，不需要我们去考虑各种各样的潜在错误和并发问题。当使用事务时，要么提交，要么回滚，我们不会去考虑当网络异常，服务器宕机，如何同时更改一个数据？因此事务本质上是<u>*为应用层服务*</u>的，而不是伴随着数据库系统天生就有的.

## 引入ACID

### 事务的执行要求

（其实是很自然的需求）

1. 事务成功：当事务提交后，事务中的所有操作需要都成功完成且其结果被永久保存在数据库中（持久性）
2. 事务失败：如果事务中有的操作没有成功完成，则事务中的所有操作都需要**回滚**，回到事务执行前的状态（原子性）
   1. 序列的失败恢复：为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法
3. 事务之间独立，即事务对数据库或者其他事务的执行无影响（隔离性）
   1. 并发访问的隔离：当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰（隔离性）

### ACID

其实以上的几段已经说明了事务的四大特性（ACID），下面的ACID只是再次提出以来概括和总结。ACID：

- 原子性（Atomicity）：事务作为一个整体，要么全部被执行，要么都不执行
- 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束
  - 一致性就是保证数据是由意义的
- 隔离性（Isolation）：多个事务并发执行时，一个事务不会影响另一个事务。
  - 多个事务并发执行后的状态，和它们串行执行后的状态是等价的。
  - 每个事务感觉不到其他事务，每个事务看到的数据总是一致的，每个事务看到数据就好像没有其他事务执行。
- 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中

# 原子性和持久性

## 事务状态

第14章事务14.4状态图

## 原子性实现

为了实现原子性，需要通过日志：将所有对数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已经执行成功的操作撤销，从而达到“全部操作失败”的目的。最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志进行REDO（重演将所有已经执行成功但尚未写入到磁盘的操作，保证持久性），再对所有到崩溃时尚未成功提交的事务进行UNDO（撤销所有执行了一部分但尚未提交的操作，保证原子性）。crash recovery结束后，数据库恢复到一致性状态，可以继续被使用

回滚

回滚日志（undo log），所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。回滚日志除了能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息，它还能够在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。

回滚日志并不能将数据库物理地恢复到执行语句或者事务之前的样子；它是逻辑日志，当回滚日志被使用时，它只会按照日志逻辑地将数据库中的修改撤销掉看，可以理解为，我们在事务中使用的每一条 INSERT 都对应了一条 DELETE，每一条 UPDATE 也都对应一条相反的 UPDATE 语句。

todo: `redo log`，`undo log`，`bin log`

## 持久性实现

重做日志redo log

重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。

当我们在一个事务中尝试对数据进行修改时，它会先将数据从磁盘读入内存，并更新内存中缓存的数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上，

到现在为止我们了解了 MySQL 中的两种日志，回滚日志（undo log）和重做日志（redo log）；在数据库系统中，事务的原子性和持久性是由事务日志（transaction log）保证的，在实现时也就是上面提到的两种日志，前者用于对事务的影响进行撤销，后者在错误处理时对已经提交的事务进行重做，它们能保证两点：

1. 发生错误或者需要回滚的事务能够成功回滚（原子性）；
2. 在事务提交后，数据没来得及写会磁盘就宕机时，在下次重新启动后能够成功恢复数据（持久性）；

在数据库中，这两种日志经常都是一起工作的，我们**可以**将它们整体看做一条事务日志，其中包含了事务的 ID、修改的行元素以及修改前后的值。

一条事务日志同时包含了修改前后的值，能够非常简单的进行回滚和重做两种操作，在这里我们也不会对重做和回滚日志展开进行介绍，可能会在之后的文章谈一谈数据库系统的恢复机制时提到两种日志的使用。

# 隔离性实现

怎样实现隔离性，已经有很多人回答过了，原则上无非是两种类型的锁

一种是悲观锁，即当前事务将所有涉及操作的对象加锁，操作完成后释放给其它对象使用。为了尽可能提高性能，发明了各种粒度（数据库级/表级/行级……）/各种性质（共享锁/排他锁/共享意向锁/排他意向锁/共享排他意向锁……）的锁。为了解决死锁问题，又发明了两阶段锁协议/死锁检测等一系列的技术。

一种是乐观锁，即不同的事务可以同时看到同一对象（一般是数据行）的不同历史版本。如果有两个事务同时修改了同一数据行，那么在较晚的事务提交时进行冲突检测。实现也有两种，一种是通过日志UNDO的方式来获取数据行的历史版本，一种是简单地在内存中保存同一数据行的多个历史版本，通过时间戳来区分。

单独一节描写隔离性：隔离级别，隔离级别实现

# 复杂的“一致性”

## 一致性的含义

由于AID三个特性，事务就成了构造与数据库的交互的一种理想方式。但是这也使得我们

[^(必须？)]: 在《数据库系统概念》事务一章，14.1节最后，提出的必须，但不甚理解

加强了对事务本身的要求，即由此引出了一致性。

一致性声称：事务作为原子从一个一致的数据库状态开始运行，事务结束时数据库也必须再次是一致的。

这种一致性其实超出了**数据完整性约束**（例如：主码约束、参照完整性、check约束等）（需要注意的是，这部分一致性由AID提供了一定保证）。事务的一致性被赋予更多的责任，很多这种责任不能通过SQL来约束。所以说：**事务的一致性是程序员的责任**。

从上面的描述指出了事务的一致性有两个方面：

1. 数据完整性约束
2. 程序员负责的应用层级别的一致性

这两个方面也可以说一个是语法上的一个是语义上的；也可以说是数据库外部一致性和数据库内部一致性；

下面举例说明：

> 我们约束：账户余额不能小于0
>
> 现有一情况是：A要向B支付100元，而A的账户中只有90元。

如果支付成功，数据库数据就破坏约束，因此事务不能成功。这就是一致性保证。

> 如果没有上述约束，即账户余额不能小于0
>
> 仍然是上述情况：A要向B支付100元，而A的账户中只有90元。

如果支付成功，这样也没有破坏数据库的数据约束，但是破坏了我们应用层的约束。所以我们也不能让他成功，此时就可以让**应用层借助数据库回滚来保证约束**。

这个例子非常简单，但是想一想，假设应用层事务的约束很复杂，以至于用SQL不能写出约束（账户余额不能小于0这种是可以写出来的，但也有复杂的），那么一致性就只能通过应用层来保证了，但这也是事务一致性，是通过回滚实现的。

## 一致性和AID关系

（ACID之间的关系）

有人说，在事务处理的ACID属性中，**一致性是最基本的属性**，其它的三个属性都为了保证一致性而存在的，这样说是有道理的。

为了实现原子性，需要通过日志，原子性保证了一定的一致性。但是如果涉及到并行执行事务，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。

为了保证并发的一致性/原子性引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好象其它并发事务并不存在一样。隔离性是通过锁来实现的。

## 一致性问题

（<u>*todo:这个地方应该只看图，是否应该把四个图合并成一个图，减少文章占用空间*</u>）

- 丢失修改

  <img src="E:\_data\博文临时库\博文中的图片\数据库事务-隔离性-丢失修改.png" style="zoom:50%;" />

- 不可重复读

  <img src="E:\_data\博文临时库\博文中的图片\数据库事务-隔离性-不可重复读.png" style="zoom:50%;" />

  - 幻读

    <img src="E:\_data\博文临时库\博文中的图片\数据库事务-隔离性-幻读.png" style="zoom:50%;" />

- 读出脏数据

  <img src="E:\_data\博文临时库\博文中的图片\数据库事务-隔离性-读脏数据.png" style="zoom:50%;" />

产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

---



级联回滚问题

级联回滚(cascading rollback)是指数据库的一个事务的失败引起多个事务随之失败，都要各自回滚。

回滚特性通常用数据库日志实现，但也可以用多版本并发控制实现。

# 总结

本文各节的关系

从本文能回答什么问题

- 事务是如何实现的
- 事务的两段提交机制
- 事务的并发？事务四种隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？
- 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？
- MVVC并发控制协议，在MVCC并发控制中，读操作可以分成两类

