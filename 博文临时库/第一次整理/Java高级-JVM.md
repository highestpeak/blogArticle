# 综述

新老生代区域，结合区域然后学习垃圾回收（重点）

- 时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于 Android 系统中垃圾回收的不可预知性。不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收

其他问题：

- 观察和解决虚拟机问题
- 参数调优

---

首先，记住这张JVM的图：

![](E:\_data\博文临时库\博文中的图片\drawio\Java高级-JVM-内存区域.png)

从图中可以看到JVM分成几个部分：类加载系统、运行时数据区、执行引擎、本地库。我们也就从这几个方面学习和认识JVM。

最重要的就是学习内存区域这部分。学习内存区域主要的就是学习垃圾回收，另外JVM还有自己的内存模型，这个内存模型在并发类库文章中讲解。

从图中可以看出还有一个直接内存部分（堆外内存），这部分和NIO有关，但这部分内存不属于JVM，例如操作系统打开的文件等，但是JVM可能持有这部分内存区域的引用。通过操作直接内存避免了在堆内存和堆外内存来回拷贝数据。直接内存是所有线程共享的一块内存。

# 类加载系统

类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。

- JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，即并不需要等到某个类被“首次主动使用”时再加载它。
  - 如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时报告错误（`LinkageError`错误）。如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误
  - JVM启动期间，会先加载一部分核心类库，平时最常用的基础类库，比如Object、String、Thread等都在这里，因为这些类使用频率很高，因此预先将它们加载到内存

类声明周期包括七个阶段：加载、验证、准备、解析、初始化、使用、卸载。其中前五个阶段是加载阶段。类最后被加载到了方法区（元空间）。

- 需要注意的是这里的初始化不是指的实例初始化，而是类初始化

![](E:\_data\博文临时库\博文中的图片\drawio\Java高级-JVM-类生命周期.png)

虚拟机规范中并没有对什么情况下虚拟机需要开始加载一个类进行强制约束，但是对何时必须进行初始化做了约束。

## 加载时机

（只有这五种情景会触发）

- 遇到new、`getstatic`、`putstatic`或`invokestatic`这四条字节码指令，生成这四条指令的最常见的Java代码场景是：

  - 使用new关键字实例化对象的时候；
  - 读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；
  - 调用一个类的静态方法的时候。

- 对类进行反射调用的时候，`Class.forName("类名").newInstance()；`

- 初始化某个类的子类的时候，如果父类没有初始化则触发父类初始化

- 虚拟机启动时会先加载设置的程序主类

- 使用JDK 1.7 的动态语言支持的时候

  如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果`REF_getstatic`,`REF_putstatic`,`REF_invokeStatic`的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化

上面这五种场景中的行为称为对一个类进行 **主动引用**。除此之外，所有引用类的方式，都不会触发初始化，称为 **被动引用**。

被动引用常见的例子如：

- （`static`）通过子类引用父类的静态字段，不会导致子类初始化。即只会触发父类的初始化而不会触发子类的初始化

- 通过数组定义来引用类，不会触发此类的初始化

  如Student[] array = new Student[10]; 会初始化一个Student[]类，而不会初始化Student类，Student[]类直接继承自Object，创建动作由字节码指令`newarray`触发。

  - 基本类型数组： int[] array = new int[10]; 会初始化每个元素为0
  - 引用类型数组：Student[] array = new Student[10]; 会初始化每个元素为null

- （`static final`）常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

---

## 类加载过程

在类加载过程中，除了在加载阶段可以通过自定义类加载器实现用户参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码(字节码)。

- 加载：

  类的二进制字节流==>类的静态存储结构转换为方法区的运行时存储结构==>生成一个代表该类的 Class 对象让方法区可访问

  在这个阶段涉及到了加载器和双亲委派模型

- 验证：

  确保字节流中信息符合虚拟机要求，并且该信息的安全性。

  包括验证：

  - class文件格式
  - 元数据验证（是否符合Java语言规范）
  - 字节码验证（分析数据流和控制流确保程序逻辑合理）
  - 符号引用验证(确保解析动作能正确执行)

  验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，可以考虑采用`-Xverifynone`参数来关闭大部分的类验证措施提高加载速度

- 准备：

  初始化变量的值，但不会分配内存，也不会给实例变量赋值引用。

  准备阶段是正式为类变量(**static 成员变量**)**分配内存**并为类变量**设置初始值**（零值）的阶段，这些变量所使用的内存都将在方法区中进行分配。如

  ``` java
      public static int value = 123;
  ```

  在这个阶段只会赋值成0，而不是123。赋值为123将在初始化阶段执行。

  但是特殊情况是 `static final` 会在准备阶段初始化为指定的值，即如果：

  ``` java
      public static final int value = 123;
  ```

  会在这时初始化为123

- 解析：

  将常量池的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

- 初始化：

  包括static语句块

  初始化阶段是执行类构造器`<clinit>()`方法的过程。`<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：

  ```java
  public class Test {
      static {
          i = 0;                // 给变量赋值可以正常编译通过
          System.out.print(i);  // 这句编译器会提示“非法向前引用”
      }
      static int i = 1;
  }
  ```

  （<u>*todo： link：这部分就是static语句块的内容了，初始化顺序好像写到了面向对象里，可以在这里链接过去*</u>）
  
  类构造器`<clinit>()`与实例构造器`<init>()`不同，它不需要程序员进行显式调用，虚拟机会保证在子类类构造器`<clinit>()`执行之前，父类的类构造`<clinit>()`执行完毕。由于父类的构造器`<clinit>()`先执行，也就意味着父类中定义的静态语句块/静态变量的初始化要优先于子类的静态语句块/静态变量的初始化执行。特别地，类构造器`<clinit>()`对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生产类构造器``<clinit>()``。
  
  虚拟机会保证一个类的类构造器`<clinit>()`在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的类构造器`<clinit>()`，其他线程都需要阻塞等待，直到活动线程执行`<clinit>()`方法完毕。特别需要注意的是，在这种情形下，其他线程虽然会被阻塞，但如果执行`<clinit>()`方法的那条线程退出后，其他线程在唤醒之后不会再次进入/执行`<clinit>()`方法，因为 在同一个类加载器下，一个类型只会被初始化一次。

二进制字节流（class文件）可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
- 从网络中获取，最典型的应用是 Applet。
- 运行时计算生成，例如动态代理技术，在 `java.lang.reflect.Proxy` 使用 `ProxyGenerator.generateProxyClass` 的代理类的二进制字节流。
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。

加载和连接阶段：

- 加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。

  但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

其他：

- 内部类不会在其外部类被加载的同时被加载

- 一个习题：

  ``` java
  public class StaticTest {
      public static void main(String[] args) {
          staticFunction();
      }
  
      static StaticTest st = new StaticTest();
  
      static {   //静态代码块
          System.out.println("1");
      }
  
      {       // 实例代码块
          System.out.println("2");
      }
  
      StaticTest() {    // 实例构造器
          System.out.println("3");
          System.out.println("a=" + a + ",b=" + b);
      }
  
      public static void staticFunction() {   // 静态方法
          System.out.println("4");
      }
  
      int a = 110;    // 实例变量
      static int b = 112;     // 静态变量
  }/* Output: 
          2
          3
          a=110,b=0
          1
          4
   *///:~
  ```

  这个习题说明了：实例初始化不一定要在类初始化结束之后才开始初始化。在这个例子中实例初始化被嵌入到了静态初始化流程中，并且在上面的程序中，被嵌入到了静态初始化的起始位置。

## 实例化过程

Java对象的创建过程包括 **类初始化** 和 **类实例化** 两个阶段。类初始化是类加载的步骤，类实例化不是类加载的步骤，而是类加载之后使用的步骤。

类实例化的时机：

- 使用new关键字创建对象
- 反射机制：Class类的`newInstance`方法、使用Constructor类的`newInstance`方法
- Clone方法，（<u>*todo：但是这个过程没有调用任何构造器？？？*</u>）
- 反序列化

实例化过程：

- 分配内存：当一个对象被创建时，虚拟机就会为其**分配内存**来存放对象自己的实例变量及其从父类继承过来的实例变量

- 分配内存的同时赋予默认值：实例变量会被赋予默认值(零值)

- 执行初始化：实例变量初始化、实例代码块初始化 以及 构造函数初始化

  - 赋予零值和执行初始化不同

  - 对实例变量直接赋值或者使用实例代码块赋值，编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后（这三者合并后的代码在虚拟机中叫做`<init>()`）。如：

    ``` java
    //父类
    class Foo {
        int i = 1;
    
        Foo() {
            System.out.println(i);             -----------(1)
            int x = getValue();
            System.out.println(x);             -----------(2)
        }
    
        {
            i = 2;
        }
    
        protected int getValue() {
            return i;
        }
    }
    ```

    相当于

    ``` java
       //Foo类构造函数的等价变换：
        Foo() {
            i = 1;
            i = 2;
            System.out.println(i);
            int x = getValue();
            System.out.println(x);
        }
    ```

注意类构造器和实例构造器：

- 类构造器`<clinit>()`最多会被虚拟机调用一次，而实例构造器`<init>()`则会被虚拟机调用多次，只要程序员还在创建对象

几个问题：

一个实例变量在对象初始化的过程中会被赋值几次？四次赋值

- 第一次赋值：JVM在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个时候实例变量被第一次赋值
- 第二次赋值：如果我们在声明实例变量x的同时对其进行了赋值操作，那么这个时候，这个实例变量就被第二次赋值
- 第三次赋值：如果我们在实例代码块中，又对变量x做了初始化操作，那么这个时候，这个实例变量就被第三次赋值
- 第四次赋值：如果我们在构造函数中，也对变量x做了初始化操作，那么这个时候，变量x就被第四次赋值

## 类加载器

类加载器是 Java 语言的一个创新。它使得动态安装和更新软件组件成为可能。

从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：

- 启动类加载器（`Bootstrap ClassLoader`），使用 C++ 实现，是虚拟机自身的一部分；
- 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 `java.lang.ClassLoader`。

从 Java 开发人员的角度看，类加载器可以划分得更细致一些：

- 启动类加载器（`Bootstrap ClassLoader`）
  - 用来加载 Java 的核心库(`jre/lib/rt.jar`)，即JDK的所有代码，也就是Java doc里面看到的所有的类的class文件。
- 扩展类加载器（`Extension ClassLoader`）
  - 加载 Java 的扩展库(`jre/ext/*.jar`)，如果使用`javafx`，他的类库是在这个文件夹里的：`jfxrt.jar`
  - 它的父加载器是null（因为`BootstrapClassLoader`是使用C++实现的，没有对应的java类）
  - 扩展类加载器只是将`jre\ lib\ ext`中的所有jar添加到JVM类搜索路径。Java在那里保存特定于平台的jar，例如`javafx`等。用户程序依赖的jar最好不要放在这里。
- 应用程序类加载器（`Application ClassLoader`）（也说系统类加载器）
  - 加载用户类路径（`ClassPath`）上指定的类库(也许你就快弄明白Java环境配置是`Classpath`配置不配置的问题了)
- <u>*todo：此外还有一类什么线程上下文加载器？？*</u>

应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。如果要自定义类加载器就需要用到双亲委派模型。

大多数情况下，越基础的类由越上层的加载器进行加载，因为这些基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API。

JVM  需要有不同的类加载器，因为它一方面允许你在一个 JVM 里运行不同的应用程序，另一方面方便你独立的对不同类库进行运行时增强

不同类加载器加载的类不是相同类型：在Java中，一个类的全名（包名+类名）作为其标识，但在JVM中，一个类用其全名+类加载器作为唯一标识，不同类加载器加载的类置于不同的命名空间中

- 为什么是三个常见的类加载器：

  - 核心类库单独一个加载器，扩展类库（本机所有java程序公用的jar，形如`javafx`），加载用户程序的加载器

- 多个类加载器可以区分同名的类：

  假定存在一个应用服务器，上面部署着许多独立的应用，同时他们拥有许多同名却不同版本的类库。试想，这时候 JVM 该怎么加载这些类同时能尽可能的避免掉类加载时对同名类的差异检测呢？当然是不同的应用都拥有自己独立的类加载器了。

- 类加载可以加强类的能力：

  类加载器可以在 load class 时对 class 进行重写和覆盖，在此期间就可以对类进行功能性的增强。比如添加面向切面编程时用到的动态代理，以及 debug 等原理。

  怎么样达到仅修改一个类库而不对其他类库产生影响的效果呢？一个比较方便的模式就是每个类库都可以使用独立的类加载器

- `Class.forName(String name)`默认会使用调用类的类加载器来进行类加载

**双亲委派模型：**

该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。（即持有一个“父”加载器的引用）

我们要自定义类加载器的话，继承`java.lang.ClassLoader`是一个做法。

- `java.lang.ClassLoader` 的 `loadClass()` 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 `findClass()` 方法。

双亲委派模型的特点/优缺点：

- 双亲委派模型可以保证同一个类由同一个加载器加载，避免多层级的加载器重复加载某些类。保证同一个类只能有一份

  - 越多共享的类库越会在高层出现，例如核心类库由启动类加载器加载，这也保证了所有应用程序共享一套核心类库，即一定的兼容性。否则的话每个加载器一套自己的核心类库，程序很可能就不能运行了。

- 双亲委派模型保证了一定的安全性。

  因为如果不采用这种机制，那么系统核心的类就可以被随意替换。

- 基础类回调用户用户代码会破坏双亲委派模型。因为上层的类加载器无法访问由下层类加载器所加载的类：

  如果启动类加载器加载的系统类中提供了一个接口，接口需要在应用中实现。比如 JDBC、XML Parser 等。这些接口由Java核心库提供而它们的实现由第三方提供。

- 下层加载器可能不会执行加载：

  由于父级委托，扩展类加载器具有比普通（即CLASSPATH）加载器更高的优先级，因此可以确保它们被您的应用程序使用，并且单个应用程序无法覆盖`ext`中具有不同版本的库。由于在`ext`中的class被优先加载，在下一级应用程序类加载器或者用户自定义的加载器就可能不会被执行加载（双亲委派导致根本就没有触发下面这些类加载器）

**自定义类加载器：**

- 真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用 `defineClass` 来实现的；而启动类的加载过程是通过调用 `loadClass` 来实现的

  - 尽量不要覆写已有的`loadClass`方法中的委派逻辑

- 自己实现`ClassLoader`时只需要继承`ClassLoader`类，然后覆盖`findClass(String name)`方法即可完成一个带有双亲委派模型的类加载器。

  - 我们不能去继承自`AppClassLoader`和`ExtClassLoader`，因为它们都是静态类，只具有包访问权限

- 为什么需要`o.getClass().getMethod("printVersion").invoke(o);`这样通过反射获取method调用，不能先强转成Test，然后`test.printVersion()`吗？
  我：因为如果你这么写

  ``` java
  Test test = (Test)o;
  o.printVersion();
  ```

  `Test.class`会隐性的被加载当前类的`ClassLoader`加载，当前Main方法默认的`ClassLoader`为`AppClassLoader`，而不是我们自定义的`MyClassLoader`。

  这样会抛出`ClassCastException`，因为一个类，就算包路径完全一致，但是加载他们的`ClassLoader`不一样，那么这两个类也会被认为是两个不同的类。

  （这个例子来自于下面参考的知乎的一篇专栏文章）

- 当自定义类加载器没有指定父类加载器的情况下，默认的父类加载器即为系统类加载器。

- JVM规范中规定如果用户自定义的类加载器将父类加载器强制设置为null，那么会自动将启动类加载器设置为当前用户自定义类加载器的父类加载器

- 用处：

  - 加载从网络上获取的类：

    为了安全性，我们在网络上传输的这些类可能经过了字节码加密，这个时候就需要实现自己的类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证。最后定义出要在 Java 虚拟机中运行的类来。

  - 代码热替换，在不重启服务器的情况下可以修改类的代码并使之生效

 <u>*todo： SPI机制、OSGI 机制、JDBC等具体如何使用加载器实现加载、他们的`serviceLoader`、Spring的SPI机制，热替换和热部署如何实现等、自己编写类加载器的示例代码*</u>

**对象创建流程：**

- 虚拟机遇到 new 指令
- 检查指令的参数是否能在常量池中定位到一个类的符号引用
- 检查符号引用是否已经被加载、解析和初始化。如果没有则进行类加载。
- 虚拟机为新生对象分配内存（对象所需的内存大小在类加载完就可确定）
- 将分配到的内存空间都初始化为零值（不包括对象头）这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值
- 虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能知道类的元数据信息、对象的哈希码、对象的 GC 分代年龄信息等等，这些信息都存放在对象的对象头（Object Header）之中。
- 执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化
- 一个真正可用的对象完全产生出来。

# 运行时数据区

这部分的形如栈帧的和学习系统级编程时的c语言的栈帧逻辑类似（还有PC等也类似），这部分不赘述。

- 堆：
  - 所有对象都在堆里分配内存，堆是垃圾收集的主要区域（又称"GC 堆"）。
  
  - 堆也被继续划分成更细的区域，对不同的区域有不同的垃圾回收算法，算法的执行者即垃圾收集器也有很多不同的地方。
  
  - 默认新生代和老年代比例为`1:2`
  
  - Eden和Survivor 比例为 8:1:1 的原因：
  
    首先为什么需要三个区域：
  
    - 首先明白使用复制法的原因：新生代GC比较频繁、对象存活率低，用复制算法在回收时的效率会更高，也不会产生内存碎片。
  
    - 上面说新生代被回收的资源可能很多，即晋级到存活区和老生代的不太多，所以我们采用较小的Survivor的比例
  
    - 而为了充分利用空间，所以采用这样的比例。这样的比例可以保证Eden区域比较大。
  
    - 为什么需要两个Survivor：
  
      这样的区域划分，加上下面说的回收算法的流程，可以保证：永远有一个survivor space是空的，另一个非空的survivor space无碎片。（因为重新移动到新的Survivor区域肯定会选择连续的存放）
  
      而如果继续增加Survivor的个数会导致每一块Survivor的空间变小，导致每一块Survivor很容易满
- 方法区：
  - 类信息和常量：方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
    - 运行时常量池允许动态生成，运行时常量池可以有：字符串、final常量值、基本类型的值（<u>*todo： Integer等的缓冲区？*</u>）
  - 对方法区进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。
  - 方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。
- 栈：
  - 栈有两种：本地方法栈和虚拟机栈
  - 线程请求的栈深度有最大值
  - 栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机中从入栈到出栈的过程。
    - 局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型）

堆和方法区不需要连续的内存，并且可以动态增加其内存。

## 内存分配

（这样的内存分配方法，其实不是JVM的专利，是我们学习操作系统时，我们已经学习了的操作系统分配内存的策略）

为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，通常有两种方法实现：

- **指针碰撞法**
  假设Java堆中内存时完整的，已分配的内存和空闲内存分别在不同的一侧，通过一个指针作为分界点，需要分配内存时，仅仅需要把指针往空闲的一端移动与对象大小相等的距离。

  <u>*todo：指针碰撞为什么叫碰撞*</u>

- **空闲列表法**
  事实上，Java堆的内存并不是完整的，已分配的内存和空闲内存相互交错（内存碎片），JVM通过维护一个列表，记录可用的内存块信息，当分配操作发生时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录。

对象创建是一个非常频繁的行为，进行堆内存分配时还需要考虑多线程并发问题，可能出现正在给对象A分配内存，指针或记录还未更新，对象B又同时分配到原来的内存，解决这个问题有两种方案：

- 采用CAS保证数据更新操作的原子性；

- 把内存分配的行为按照线程进行划分，在不同的空间中进行，每个线程在Java堆中预先分配一个内存块，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）;

## 垃圾回收

垃圾回收(GC)可以有效的防止内存泄露，有效的使用可以使用的内存。GC并不是全部的GC，他分成了Minor GC和Full GC，即分别对新生代和老生代的GC。

- 垃圾收集行为在方法区比较少出现：

  但并非数据进入方法区后就“永久存在”了。在`HotSpot` 中JDK 1.8 的时候，方法区（`HotSpot` 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

- Minor GC：回收新生代，会频繁进行，速度快

- Full GC：回收新生代和老生代，很少执行，速度很慢

要想进行垃圾回收，首先需要判断对象是否需要被回收，然后垃圾收集器执行垃圾回收算法。垃圾收集器通常是作为一个单独的低优先级的守护线程运行。

- 不同的区域可能有不同的垃圾回收算法。

- 垃圾收集器有单线程和多线程，也有并行和串行实现。

- 判断一个对象是否可被回收：

  - 引用计数（未使用）
  - 可达性分析
  - 方法区类信息的回收
  - ❌~~finalize()~~

- 垃圾回收算法：

  - 标记清除法
  - 标记整理法
  - 复制法
  - 分代式垃圾回收

- 判断对象是否被回收的判断引用是否存在，这个部分和Java的ref包有关联，但这部分在Java的一些专题文章中讲述，不在这里讲解

  <u>*todo： link： Java引用对象*</u>

⭐⭐⭐**对象在内存/堆内存中的移动（垃圾回收的递进过程）**：

整体上采用分代式垃圾回收：新生代Eden-->新生代Survivor-->老生代

1. 对象首先分配在新生代的Eden区域，在第一次对它垃圾回收后会进入Survivor区域（复制法）
2. 对象会在Survivor区域的两个区不断挪动，每次从一个区到另一个区（例如从S1到S2）就会增加一个计数（可以说是他的年龄）。当这个计数到达一个设定阈值就会把这个对象放到老生代（默认为 15 岁）
   - 堆中新生代的两个Survivor区采用了复制法垃圾回收，两个区在同一时刻只有一个处于使用
   - 复制法可以说是两个Survivor之间的复制法，也可以说是Eden、其中一个Survivor和另一个Survivor之间的复制法
3. 老生代会进行Full GC
   - 标记 - 清除 或者 标记 - 整理 算法（取决于具体的垃圾收集器）

凡事都有例外：

- 大对象直接进入老年代，大对象指很长的字符串和数组等

- 动态对象年龄判定：

  虚拟机并不是永远要求对象的年龄必须达到 `MaxTenuringThreshold` 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 `MaxTenuringThreshold` 中要求的年龄。

### 关于Full GC

- **空间分配担保**失败：

  使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC：

  - 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

  - 如果不成立的话虚拟机会查看 `HandlePromotionFailure` 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，
    - 如果大于，将尝试着进行一次 Minor GC；
    - 如果小于，或者 `HandlePromotionFailure` 的值不允许冒险，那么就要进行一次 Full GC

  另外还有一种Concurrent Mode Failure：

  - 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

- 老年代空间不足

- 方法区（永久代）空间不足：

  当系统中**要加载的类、反射的类和调用的方法较多**时,永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。

- 调用 `System.gc()`

---

**判断是否为垃圾较为详细的介绍：**

（<u>*引自CS-Notes*</u>）（上面的那一小部分其实已经概括了这部分内容）

- 引用计数算法

  为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

  在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。

  ```java
  public class Test {
      public Object instance = null;
      public static void main(String[] args) {
          Test a = new Test();
          Test b = new Test();
          a.instance = b;
          b.instance = a;
          a = null;
          b = null;
          doSomething();
      }
  }
  ```

  在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。

- 可达性分析算法

  以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。

  Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：

  - 虚拟机栈中局部变量表中引用的对象
  - 本地方法栈中 JNI 中引用的对象
  - 方法区中类静态属性引用的对象
  - 方法区中的常量引用的对象

  GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。

  类实例创建是在方法中完成的，类的实例就是方法的局部变量。在方法被调用时会分配栈帧，局部变量的引用存放在栈帧中，在方法返回时栈帧被回收，局部变量的引用也被回收。栈中的引用是GC Roots的一种，被其指向的对象不会被回收。

- 方法区的回收

  因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。

  主要是**对常量池的回收和对类的卸载**。

  为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。

  类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：

  - 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
  - 加载该类的 `ClassLoader` 已经被回收。
  - 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

**垃圾回收：**

- 标记清除法

  <img src="E:\_data\博文临时库\博文中的图片\JVM垃圾回收标记清楚法.png" style="zoom:50%;" />

  - 标记和清除过程效率都不高；
  - 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

- 标记整理法

  <img src="E:\_data\博文临时库\博文中的图片\JVM垃圾回收标记整理法.png" style="zoom:50%;" />

  - 不会产生内存碎片

  - 需要移动大量对象，处理效率比较低。
  - 会改变对象的地址

- 复制法

  <img src="E:\_data\博文临时库\博文中的图片\JVM垃圾回收复制法.png" style="zoom:50%;" />

- 分代式垃圾回收

**为什么各区域采用的回收算法是现在这个样子：**

即为什么新生代采用复制法、老年代采用标记清除法，而老年代不能使用标记整理和复制、新生代不用这个标记清除法的原因是什么？

- 新生代GC比较频繁、对象存活率低，用复制算法在回收时的效率会更高，也不会产生内存碎片。
- 老年代中对象的存活时间/存活率有了保证，并且开辟出一个复制区域会浪费空间
- 老年代被其他对象引用，如果采用标记整理在内存中的位置就会移动，而这样就需要更新相应对象的指针指向，不如采用标记清除，没有移动位置的需要。但是标记清除会产生内存碎片。



## 垃圾收集器

<img src="E:\_data\博文临时库\博文中的图片\JVM垃圾回收器.png" style="zoom: 67%;" />

- 新生代的收集器：
  - `Serial` 收集器：单线程，标记-复制算法
  - `ParNew` 收集器：`Serial `的多线程版本
  - `Parallel Scavenge` 收集器：`ParNew` 的升级版本，可控制回收节奏（程序总时间和GC时间比例）
- 老生代的收集器：
  -  `Serial Old` 收集器：单线程，标记-整理法（复制法不划算，因为老生代对象比较多）
  -  `Parallel Old` 收集器：Serial Old的多线程版本
  - `CMS` 收集器：很复杂，不同于上述两个old收集器
- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
- 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要**停顿**用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

---

**`CMS`收集器：**

四个阶段：`Inital Mark` 初始标记、`Concurrent Mark` 并发标记、`Remark` 再标记、`Concurrent Sweep`并行清理

- 初始标记：标记GC Root开始的下级（仅下一级）对象
- 并发标记：从第一步的结果继续向下标识，因为是多线程，其他正在工作的线程不会堵塞
- 再标记：因为第2步并没有阻塞其它工作线程，所以其它线程在标识过程中，很有可能会产生新的垃圾
- 并行清理：清理掉标记的垃圾

不能使用标记整理法替代标记清除法：因为其他工作线程还在使用很多对象，因此不能改变对象的地址，只能使用清除法

---

**G1收集器：**

（为了解决CMS中的碎片问题。）

<img src="E:\_data\博文临时库\博文中的图片\Java垃圾收集器-G1收集器.png" style="zoom: 50%;" />

G1将heap内存区，划分为一个个大小相等（1-32M，2的n次方）、内存连续的Region区域，每个region都对应Eden、Survivor 、Old、Humongous四种角色之一，但是region与region之间不要求连续。

- Humongous，简称H区是专用于存放超大对象的区域，通常>= 1/2 Region Size，且只有Full GC阶段，才会回收H区，避免了频繁扫描、复制/移动大对象。

所有的垃圾回收，都是基于1个个region的。使用G1的场景通常是大内存。为了提高扫描根对象和标记的效率，G1使用了两个新的辅助存储结构：

- Remembered Sets：简称`RSets`，用于根据每个region里的对象，是从哪指向过来的（即：谁引用了我），每个Region都有独立的`RSets`。（Other Region -> Self Region）。
- Collection Sets ：简称`CSets`，记录了等待回收的Region集合，GC时这些Region中的对象会被回收（copied or moved）。

![](E:\_data\博文临时库\博文中的图片\Java垃圾收集器-G1收集器.webp)

`RSets`的引入，在YGC时，将年青代Region的`RSets`做为根对象，可以避免扫描老年代的region，能大大减轻GC的负担。注：在老年代收集Mixed GC时，`RSets`记录了Old->Old的引用，也可以避免扫描所有Old区。

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
- 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

---

<u>*todo： ZGC收集器没有看：*</u>

<u>*todo：G1收集器 https://tech.meituan.com/2016/09/23/g1.html*</u>

<u>*todo： https://crowhawk.github.io/2017/08/15/jvm_3/*</u>

<u>*todo：垃圾收集器用哪个？如何取舍？*</u>

选择GC收集器要看他的吞吐量和暂停时间，吞吐量越高越好，暂停时间越短越好

|        收集器         | 串行、并行or并发 | 新生代/老年代 |        算法        |     目标     |                 适用场景                  |
| :-------------------: | :--------------: | :-----------: | :----------------: | :----------: | :---------------------------------------: |
|      **Serial**       |       串行       |    新生代     |      复制算法      | 响应速度优先 |          单CPU环境下的Client模式          |
|    **Serial Old**     |       串行       |    老年代     |     标记-整理      | 响应速度优先 |  单CPU环境下的Client模式、CMS的后备预案   |
|     **`ParNew`**      |       并行       |    新生代     |      复制算法      | 响应速度优先 |    多CPU环境时在Server模式下与CMS配合     |
| **Parallel Scavenge** |       并行       |    新生代     |      复制算法      |  吞吐量优先  |     在后台运算而不需要太多交互的任务      |
|   **Parallel Old**    |       并行       |    老年代     |     标记-整理      |  吞吐量优先  |     在后台运算而不需要太多交互的任务      |
|        **CMS**        |       并发       |    老年代     |     标记-清除      | 响应速度优先 | 集中在互联网站或B/S系统服务端上的Java应用 |
|        **G1**         |       并发       |     both      | 标记-整理+复制算法 | 响应速度优先 |        面向服务端应用，将来替换CMS        |

# 其他问题

## 方法区和永久代

> 《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 `HotSpot` 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 `HotSpot` 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

永久代 (`PermGen`) 替换为元空间 (`MetaSpace`)： 

![](E:\_data\博文临时库\博文中的图片\JVM jdk1.8的堆区划分.png)

- 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
- 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
- 在 JDK8，合并 `HotSpot` 和 `JRockit` 的代码时, `JRockit` 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了
- 从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中

---

## OOM

OOM即`OutOfMemory`，

- **内存溢出**：通俗理解就是**内存不够**，程序所需要的内存远远超出了你虚拟机分配的内存大小，就叫内存溢出
- **内存泄露**：内存泄漏也称作“存储渗漏”，用动态存储分配函数动态开辟的空间，在**使用完毕后未释放**，结果导致**一直占据该内存单元**。直到程序结束。（其实说白了就是该内存空间使用完毕之后未回收）即所谓内存泄漏

### 泄漏场景

可以不断地拼接字符串，但是不适用`StringBuilder`，来自己模拟一个泄漏场景

> 场景1--长生命周期的对象持有短生命周期对象的引用

Java中，造成内存泄露的原因有很多种。典型的例子是**长生命周期的对象持有短生命周期对象的引用**就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。

通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况，例如，**缓存系统**，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。

> 场景2--内部类和外部类

如果一个**外部类**的实例对象的方法返回了一个**内部类**的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

> 场景3--永久代内存泄露

永久代溢出原因动态**加载了大量Java类**而导致溢出(包括类的名称，字段，方法和字节码)，以及生产**大量的常量**，或者采用`cglib`等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。

以一个部署到应用程序服务器的Java web程序来说，当该应用程序被卸载的时候，你的EAR/WAR包中的所有类都将变得无用。只要应用程序服务器还活着，JVM将继续运行，但是一大堆的类定义将不再使用，理应将它们从永久代（`PermGen`）中移除。如果不移除的话，我们在永久代（`PermGen`）区域就会有内存泄漏。

`java.lang.OutOfMemoryError: PermGen space`

可以：调大永久代空间。设置类卸载。

> 场景4--年老代溢出

年老代溢出原因有 循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存

> HashMap没有重写equals

我们可以非常容易的写出导致内存泄漏的Java代码：

```java
public class KeylessEntry {
    
    static class Key {
        Integer id;
        
        Key(Integer id) {
            this.id = id;
        }
        
        @Override
        public int hashCode() {
            return id.hashCode();
        }
    }

    public static void main(String[] args) {
        Map<Key,String> m = new HashMap<Key,String>();
        while(true) {
            for(int i=0;i<10000;i++) {
                if(!m.containsKey(new Key(i))) {
                    m.put(new Key(i), "Number:" + i);
                }
            }
        }
    }
}
```

代码中`HashMap`为本地缓存，第一次while循环，会将10000个元素添加到缓存中。后面的while循环中，由于key已经存在于缓存中，缓存的大小将一直会维持在10000。但事实真的如此吗？由于`Key`实体没有实现`equals()`方法，导致for循环中每次执行`m.containsKey(new Key(i))`结果均为`false`，其结果就是`HashMap`中的元素将一直增加。

随着时间的推移，越来越多的`Key`对象进入堆空间且不能被垃圾收集器回收（m为局部变量，GC会认为这些对象一直可用，所以不会回收），直到所有的堆空间被占用，最后抛出`java.lang.OutOfMemoryError:Java heap space`。

解决方法也非常简单，只要`Key`实现自己的`equals`方法即可：

```java
Override
public boolean equals(Object o) {
    boolean response = false;
    if (o instanceof Key) {
        response = (((Key)o).id).equals(this.id);
    }
    return response;
}
```

<u>*todo: 这个场景参考的是，但是不能知道到底是不是他写的，这篇文章太长了，留着之后再看  https://www.jianshu.com/p/2fdee831ed03*</u>

> 频繁GC

Java 进程98%的时间在进行垃圾回收，恢复了不到2%的堆空间，最后连续5个（编译时常量）垃圾回收一直如此。

`java.lang.OutOfMemoryError:GC overhead limit exceeded`错误是一个信号，示意你的应用程序在垃圾收集上花费了太多时间但却没有什么卵用。默认超过98%的时间用来做GC却回收了不到2%的内存时将会抛出此错误。那如果没有此限制会发生什么呢？GC进程将被重启，100%的CPU将用于GC，而没有CPU资源用于其他正常的工作。如果一个工作本来只需要几毫秒即可完成，现在却需要几分钟才能完成，我想这种结果谁都没有办法接受。

所以`java.lang.OutOfMemoryError:GC overhead limit exceeded`也可以看做是一个`fail-fast（快速失败）`实战的实例。

- 频繁Full GC排查：

  看是空间不够还是空间够但是频繁GC。

  空间不够就调整大小看一看，空间够看一看有没有内存泄漏。

  分析内存泄漏则可以把堆dump下来（查看GC日志等），然后用一些工具如`jhat`观察数据，查看占用情况（分析哪个类出的问题）。

  - 如果是一次Full GC后，剩余对象不多。那么说明你Eden区设置太小，导致短生命周期的对象进入了old区。

  - 如果一次Full GC后，old区回收率不大，那么说明old区太小。
  - 可能是Eden和old等空间设置不合理，也可能是JVM垃圾回收时间等参数不合理，可能是逻辑里没有释放资源导致内存泄漏，可能是大对象过多等

  <u>*todo： 如https://blog.csdn.net/u012422829/article/details/78154495*</u>

> `Javaheap space` 错误产生的常见原因

1. 请求创建一个超大对象，通常是一个大数组。可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制。
2. 超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。可以考虑添加机器资源，或者做限流降级。
3. 过度使用终结器（Finalizer），该对象没有立即被 GC。
4. 内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收。需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。

<u>*todo: 其他*</u>

- <u>*请求的数组大小超过虚拟机限制*</u>
- <u>*内存不足，无法创建新线程。由于线程在本机内存中创建，报告这个错误表明本机内存空间不足*</u>

### 排查和解决

1. 通过内存映像工具如`jhat`、`jconsole`等对dump出来的堆转存储快照进行分析，重点是**确认是内存泄露还是内存溢出**。然后按照以下方法处理：

2. **内存泄露：**进一步使用工具查看泄露的对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们。掌握泄露对象的信息，以及GC Roots引用链的信息，就可以比较准确定位泄露代码的位置。

3. **如果不存在内存泄露**，那就需要通过`jinfo`、`Jconsole`等工具分析java堆参数与机器物理内存对比是否还可以调大，从代码上检查是否存在某些对象生命周期过长，持有状态过长的情况，尝试减少程序的运行消耗。

检查java中的内存泄露，一定要让程序将**各种分支情况都完整执行到程序结束**，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。

可以对程序日志中的 `OutOfMemoryError` 配置关键字告警，一经发现，立即处理

---

## 参数调优

https://www.zhihu.com/question/268821097

https://tech.meituan.com/2017/12/29/jvm-optimize.html

https://blog.csdn.net/jisuanjiguoba/article/details/80176223

https://juejin.im/post/6844903991713742855

## 逃逸分析

逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。

逃逸分析，是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

Java在Java SE 6u23以及以后的版本中支持并默认开启了逃逸分析的选项。

方法逃逸的几种方式如下：

```java
public class EscapeTest {
    public static Object obj;
    public void globalVariableEscape() {  // 给全局变量赋值，发生逃逸
        obj = new Object();
    }
    public Object methodEscape() {  // 方法返回值，发生逃逸
        return new Object();
    }
    public void instanceEscape() {  // 实例引用发生逃逸
        test(this); 
    }
}
```

利用逃逸分析，编译器可以对代码做如下优化：

1. 同步省略
2. 标量替换
3. 栈上分配

**同步省略**

在 JIT 编译过程中，如果发现一个对象**不会被多线程访问**，那么针对这个对象的同步措施就可以省略掉，即「锁销除」。例如 Vector 和 StringBuffer 这样的类，它们中的很多方法都是有锁的，当某个对象确定是线程安全的情况下，JIT编译器会在编译这段代码时进行锁销除来提升效率

**标量替换**

「标量（Scalar）」是指无法再分解成更小粒度的数据，例如 Java 中的原始数据类型（int，long等），相对如果一个数据可以继续分解，则称之为「聚合量（Aggregate）」，例如 Java对象。在 JIT 编译过程中，经过逃逸分析确定一个对象不会被其他线程或者方法访问，那么会将对象的创建替换成为多个成员变量的创建，称之为「标量替换」。

```java
public class EscapeObject {

    private static void getUser() {
        User user = new User("张三", 18);
        System.out.println("user name is " + user.name + ", age is " + user.age);
    }

    public static void main(String[] args) {
        getUser();
    }
}

class User {
    String name;
    int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

上面这段代码中，对象 user 只会在`getUser()`方法中被调用，那么 JIT动态编译时，不会创建对象 user，而之创建它的两个成员变量 name 和 age，类似：

```java
private static void getUser() {
    String name = "张三";
    int age = 18;

    System.out.println("user name is " + user.name + ", age is " + user.age);

}

public static void main(String[] args) {
    getUser();
}
```

标量替换减少了创建对象需要的堆内存，同时也不用进行 GC。

**栈上分配**

「栈上分配」是指对象和数据不是创建在堆上，而是创建在栈上，随着方法的结束自动销毁。但实际上，JVM 例如常用的「HotSpot」虚拟机并没有实现栈上分配，实际是用「标量替换」代替实现的。

在 JAVA 中，对象只分配在堆中

https://segmentfault.com/a/1190000016803174

## 杂项

- 可能的异常：
  
  - 栈：`StackOverflowError`和`OutOfMemoryError`
  - 堆和方法区：`OutOfMemoryError`
- 直接内存：`OutOfMemoryError`
  
- 线程私有和共享内存：
  - 私有：程序计数器、虚拟机栈、本地方法栈
  - 共享：堆和方法区（元空间）、运行时常量池、直接内存（本地内存）

- 可设定参数：

  - 对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置
  - `-XX:PretenureSizeThreshold`，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

- 老年代空间不足：

  常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。

  为了避免以上原因引起的 Full GC，应当:（即**频繁老年代回收怎么分析解决**）

  - 尽量**不要创建过大的对象以及数组**。
  - 通过 `-Xmn` 虚拟机参数**调大新生代的大小**，让对象尽量在新生代被回收掉，不进入老年代。
  - 通过 `-XX:MaxTenuringThreshold` **调大对象进入老年代的年龄**，让对象在新生代多存活一段时间。

- 栈溢出：

  JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数`-Xss`来设置栈的大小。

  导致栈溢出的事情：

  - 递归调用次数太多，调整JVM参数设置栈深度的数目。
  - 减少局部变量的数目和占用空间（包括基本类型，数组、List、map数据是否过大），因为递归的方法中定义了一些局部变量时会占用线程栈的空间。
  - 栈设置太小
  - 使用DDMS工具进行查找大概出现栈溢出的位置。
  - 是否有大量循环或死循环。

- 其他：

  - Java中Integer缓冲区：

    针对-128和127之间的数据，Java做了一个数据缓冲区，如果数据属于这个范围内，会从缓冲区里面直接去数据，并不会创建新的空间

    - 还有Long的缓冲区 `[-128,127]`，Byte的缓冲区 `[-128,127]`，Character的缓冲区 `[0,127]`

  - Student s= new Student(),在内存中做了那些事情
  
    1. 加载`Student.class` 文件进内存
    2. 在栈内存为s开辟空间
    3. 在堆内存为Student对象开辟空间
    4. 学生对象的成员变量进行显示初始化
  5. 通过构造方法对学生对象变量赋值
    6. 学生对象初始完毕，把对象地址赋值给s变量

  - 对象访问方式有两种：**句柄和直接指针**（<u>*todo：这段话的正确性？*</u>）
  
    - **句柄**：在java堆中会划分出一块内存作为句柄池，reference中存储的对象是句柄地址。**而句柄中包含对象实例数据和类型数据各自的具体地址信息**。最大的好处是如果对象地址发生变化不需要改变reference的值，只需要改变句柄中实例数据指针。
    - **直接指针访问**：reference直接存储对象的地址，最大的好处是**速度更快**。
    
  - main 函数所在的线程就是一个用户线程啊，main 函数启动的同时在 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程。
  
  - Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。

# 参考

> 1. [携程技术：一文看懂JVM内存布局及GC原理](https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&mid=2697268836&idx=1&sn=4c783b7c6541a9df0baf0b9060ff4c08&chksm=8376f150b401784656eef2414311b8a0290e1902fc6ab2665bc12c9d5c9c8ef194b968c7b7cb&scene=27#wechat_redirect)
> 2. [CS-Note](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95)
> 3. [关于Jvm知识看这一篇就够了]( https://zhuanlan.zhihu.com/p/34426768)
> 4. [Java 虚拟机底层原理知识总结](https://github.com/doocs/jvm)
> 5. [note-of-interview](https://github.com/zhengjianglong915/note-of-interview/blob/master/java/jvm.md)
> 6. https://blog.csdn.net/justloveyou_/article/details/72466416
> 7. https://blog.csdn.net/justloveyou_/article/details/72466105
> 8. https://segmentfault.com/q/1010000014745626
> 9. https://developer.ibm.com/zh/articles/j-lo-classloader/
> 10. https://zhuanlan.zhihu.com/p/54693308
> 11. https://juejin.im/post/6844903469908754446
> 12. https://blog.csdn.net/antony9118/article/details/51425581

