# 进程综述

之前我们讲过异常控制流ECF，ECF是允许提供进程这个概念的基本组件。而进程是计算机科学最成功的概念之一。

首先了解什么是进程？为什么需要进程？

进程定义：一组指令、一个当前状态和一组相关系统资源组成的活动单元，可以把进程视为一组元素组成的实体。

- 程序与进程：

  程序是一对代码和数据，程序作为目标文件存在磁盘上，或者作为段存在于地址空间中。

  进程是执行中程序的一个具体的实例，程序总是运行在某个进程的上下文中。

- 进程可以描述为：程序实例、处理器正在执行的实体。

- 进程的两个基本元素是 **程序代码**和与代码相关的**数据集**。

为什么需要进程：

- 进程本身可以说是提供了一种无关硬件平台的编程方式，进程可以提供了一种保护级别的实现，便于对资源的分配管理。
- 进程提供了一种我们独占系统的假象。进程提供的关键抽象：
  - 独立的逻辑控制流：好像我们独占处理器
  - 私有的地址空间：好像我们独占内存

在多线程环境下，进程是资源分配的最小单位，线程是调度的最小单位，资源主要有如下种：

1. **硬件资源**：外设资源（键盘、鼠标、显卡……）；总线资源（PCI/USB……）；CPU资源（时钟、中断、CPU时间……）……
2. **软件资源**：内存、信号量、地址空间、管道、共享内存……

进程有一个关键的控制结构，这也是操作系统最重要的控制结构，即PCB。PCB的信息分为三类：进程标识信息、处理器状态信息、进程控制信息。而下面我对进程相关内容也从这几个部分开始。

# 进程描述

每个进程在执行期间都需要访问系统资源，要控制进程并管理资源，操作系统需要知道哪些信息？这是进程描述要关心的。

---

## OS管理的几种表

操作系统为了管理进程和资源，必须掌握每个**进程和资源**的当前状态。操作系统通常维护4种不同类型的表：**内存、IO、文件和进程**：

- 内存表：分配给进程的**内存**、分配给进程的**外存**、内存块和虚存块的**保护属性**、虚存**管理信息**（页表、段表）
- IO表：IO操作的状态、IO源与目标的内存单元对应、缓冲区管理
- 4种表必须以某种方式链接和交叉引用，内存、IO和文件是代表进程而被管理的，因此进程必须有对这些资源的直接或间接地引用

为了创建这几种表，操作系统必须具有基本环境的信息，如有多少内存空间、IO设备、它们的标识符是什么。这些数据必须在操作系统之外通过人的帮助产生（通过BIOS？）

![](E:\_data\博文临时库\博文中的图片\drawio\OS系统控制表.png)

---

## 地址空间 和 PCB

（进程映像、地址空间和PCB）

操作系统在管理和控制进程的时候，首先要知道进程的位置，其次要知道进程的属性（ID、状态等）。进程的属性集就是进程控制块PCB（process control block），程序、数据、栈和属性集的集合称为进程映像。

- <u>*todo： 进程映像到底是什么？ 进程映像和进程地址空间有什么区别呢？*</u>

  进程映像是对进程执行活动全过程的静态描述（又可称为进程执行的上下文环境），由进程地址空间内容、硬件寄存器内容及与该进程相关的内核数据结构、内核栈组成

  概括起来就是：进程映像 = 程序 + 数据 + 栈(用户栈、内核栈) + PCB

OS管理进程时，进程映像至少有一部分在内存中；OS执行进程时，必须将整个进程映像载入内存或虚存。因此OS需要知道进程在磁盘中的位置、进程在内存中的位置、哪一部分在内存中。而进程表应当记录了每个进程映像中每页的位置。

- PCB存储在内核中，在Linux中他叫`task_struct`

- 进程地址空间，即进程可以寻址的范围。它包括了内核地址空间、进程私有地址空间。

  <u>*todo：进程地址空间和虚拟地址空间的区别*</u>

- 父子进程是独立的进程，它们都有自己的私有地址空间

进程虚拟地址空间结构（在Linux中）：

![](E:\_data\博文临时库\博文中的图片\drawio\进程地址空间.png)

- <u>*todo： 那么这样的话，多线程的其他线程的栈在哪里呢？ 内存映射段嘛？*</u>

---

**PCB**

PCB process control block 进程控制块，PCB的信息分为三类：进程标识信息、处理器状态信息、进程控制信息。

- 重要的包括：标识符、状态、优先级、程序计数器、内存指针、上下文数据、IO状态信息

- 进程标识符：

  - 主进程表的索引项、其他表用来交叉引用进程表的依据、进程通信的依据、父子进程
  - 包括：该进程标识符、父进程标识符、用户标识符

- 处理器状态信息：

  允许一个进程时，进程的信息一定会出现在寄存器种。终端进程时，必须保存该寄存器的所有信息。

  - 控制和状态寄存器：程序计数器PC、中断/禁用/执行的状态信息
  - 栈指针、用户模式下可见的寄存器
  - PSW寄存器会保存是用户模式还是内核模式的状态标识

- 进程控制信息：

  - 调度和状态信息：进程状态、优先级、调度所需信息、事件标识
  - 进程通信信息、进程关联信息、进程特权信息、内存管理信息（页表段表）、资源使用信息（打开的文件、处理器和资源使用历史）

**PCB是操作系统最重要的存储结构**，实际上操作系统的每个模块，包括：调度、资源分配、中断处理、性能监控和分析等都是通过读写PCB实现的。

- 例如创建进程和撤销进程，都是对 PCB 的操作。

# 进程状态

进程的状态也可以说是进程的生命周期，常见的有2状态、5状态、7状态几种状态模型。

- 2状态即非运行和运行态是最基本的模型，5状态进一步考虑了等待事件产生的堵塞态，7状态进一步考虑了虚存等的挂起态

进程的生命周期：从创建===>状态转换/进程通信/进程切换===>进程终止。这几步按理说都包含在上面所说的几个状态模型中。但事实上也不尽然，例如进程创建会在就绪态之前。即使这样，我认为这样描述有助于理解整个过程。

- 进程的切换由一个分派器即调度器负责。切换进程时当前进程会被中断。也就是说进程切换和进程调度是一回事。
- 进程的创建是由操作系统负责的
- 进程是轮流使用处理器的

## 进程创建和终止

**进程的创建**方式：进程派生（父子进程）

进程的创建过程：

- 为新进程分配唯一进程标识符：此使主进程表会添加一个新表项
- 为进程分配空间：为进程映像中的程序、数据、栈等需要的空间进行分配
- 初始化PCB：大多数初始化为0，PC和栈指针除外、优先级和状态初始化、资源初始化
  - 资源可能会已经显式的请求了、可能继承父进程资源
- 设置正确的链接：加入到指定调度队列
- 创建和扩展其他数据结构：例如记账信息等（CPU时间等）

**进程终止**：向操作系统发除一个服务请求，以终止请求的进程。进程可被创建它的进程终止，或在父进程终止时终止。

造成进程终止的原因很多，这些常见原因不要求我们全部记住，但其实也差不多需要你记住全部（令人抓狂的要求）。

- 正常完成、超过时限（时间片不够）、无可用内存
- 操作系统干涉、父进程终止、父进程要求终止进程
- 错误：内存访问超出范围、保护错误（进程试图试图使用不允许的资源或文件）、算术错误、时间超出（等待某一事件的时间）、IO失败（输入输出错误、找不到文件）、无效指令、进程试图使用特权指令、数据误用

---

其他：

- 当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。而是保持在一种已终止的状态中，直到被它的父进程回收。
  - 一个已经终止但是还没有回收的进程叫做**僵死进程**
  - 系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。所以僵尸进程是有危害的。
  - 如果父进程没有回收僵死进程，那么`init`进程会自动成为它们的父进程，然后回收它们
- 如果一个父进程终止，但是子进程还在运行的进程就称为**孤儿进程**
  - 内核会安排`init`进程(进程号为1)作为孤儿进程的养父

## 进程状态模型

**2状态模型：**

未运行的进程必须位于某个队列中，并等待执行时机。对于可运行的进程，处理器以 的方式给每个进程一定的执行时间，然后进程返回队列。

![](E:\_data\博文临时库\博文中的图片\drawio\OS-两状态模型.png)

- 这个队列实际上可以用PCB的链表来实现

两状态的问题：

- 如果使用两状态，即只使用一个队列。则调度器不能只考虑队列中最老的进程，而应当扫描整个列表，查找未堵塞且在队列时间最长的进程。（两状态的问题：处理堵塞需遍历）

**5状态模型：**

- 就绪态、堵塞/等待态、新建态、退出态
- 新建态：
  - 通常是PCB已经创建但是还没有加载到内存的新进程，进程保留在外存通常是磁盘中
  - 操作系统将关于该进程的信息保存在内存中的进程表内
  - 程序代码没有在内存中，没有为程序的数据分配空间
- 就绪到运行态是调度器负责的、运行到堵塞是由于等待事件
- 运行到就绪态：时间片不够、系统抢占、进程释放处理器
- 在支持虚存的系统中，进程从新建态转换到就绪态时，其程序代码和数据被加载到虚存中

此时维护了的是多个队列，包括一个就绪队列，在不同事件上的堵塞队列，还可以有不同优先级的队列。

![](E:\_data\博文临时库\博文中的图片\drawio\OS-五状态模型.png)

- 就绪状态的进程通过**调度算法**从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 **CPU 时间片**用完之后就会转为就绪状态，等待下一次调度
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态

**7状态模型：**

挂起态：

- IO活动远慢与于计算速度，处理器远快于IO，会出现内存中所有进程都在等待IO的现象
- 当内存中不存在就绪进程时，OS把被堵塞的进程换出到磁盘中的挂起队列
- 挂起的意思是被换出内存，挂起可能由很多条件导致，挂起后会释放一些内存空间

<img src="E:\_data\博文临时库\博文中的图片\drawio\OS-七状态模型.png" style="zoom:18%;" />

# 进程控制

进程控制的内容包括了：控制进程创建、终止，状态转换和进程调度，进程切换，进程间通信等的内容。

- 创建和终止在上面一节已经讲述

我们首先需要了解进程的执行模式：用户模式和系统模式。使用两种模式的原因是保护OS和控制表不受用户程序干扰。应用程序在用户模式下如果想变成系统模式，则需要进行系统调用。（系统调用见之前文章的描述）

- 系统模式又称：特权模式、控制模式、内核模式
- Linux提供了一种聪明的机制，叫做`/proc`文件系统，它允许用户模式进程访问内核数据结构内容，即可以使用这个系统得到一般的系统属性

## 进程调度

在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始之前的一个被抢占的进程，这样的决策叫做调度。由调度器负责。

调度使用一种叫做进程切换或者说上下文切换的方式来将控制转移到新的进程。

进程调度涉及到三个方面：一个是如何触发调度，一个是如何调度即调度算法，另一个是调度过程即进程切换的一系列操作。

- 何时调度/切换：中断、陷阱、系统调用
  - 中断：时钟中断、IO中断、内存失效（缺页中断）
  - 陷阱：错误或异常
  - 系统调用
  - 等待事件的堵塞

### 调度算法

<u>*todo: 没有复习书上的*</u>

对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。在选择下一个线程时，系统会考虑**线程的优先级**。

所有现代的桌面和服务器操作系统都采用**抢占式调度策略**，但一些小型设备如手机则可能采用**协作式调度策略**，在这样的系统中，只有当一个线程调用了它的一些方法后才会放弃所占用的资源——也就是必须由该线程主动放弃所占用的资源。

进程调度算法：

**批处理系统**调度算法目标是**保证吞吐量和周转时间**（从提交到终止的时间）

注意是抢占式还是非抢占式

调度算法可能造成一些饥饿、

- 先来先服务 `first-come first-serverd（FCFS）`：非抢占式，按照请求的顺序进行调度。有利于长作业，不利于短作业
- 短作业优先 shortest job first（SJF）：非抢占式，按估计运行时间最短的顺序进行调度，长作业有可能会饿死
- 最短剩余时间优先 shortest remaining time next（SRTN）：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待

**交互式系统**有大量的用户交互操作，在该系统中调度算法的目标是**快速响应**

- 时间片轮转：按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程

  时间片轮转算法的效率和时间片的大小有很大关系：时间片太小则进程切换太频繁，时间片太大则实时性不能保证

- 优先级调度：

  为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级

- 多级反馈队列：（相对于时间片轮转来学习）多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，进程在第一个队列没执行完，就会被移到下一个队列。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

实时系统要求一个请求在一个确定时间内得到响应

### 进程切换

进程切换又叫上下文切换，上下文切换是一种异常控制流。

- 上下文就是内核重新启动一个被抢占的进程所需的状态。

  上下文包括了：通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈、各种内核数据结构，例如页表、进程表、文件表

  总之上下文要包含：

  中断处理程序可能改变的所有信息，恢复被中断程序所需的所有信息。因此必须保存处理器状态信息（包括PC、寄存器、栈指针）

上下文切换包括：

1. 保存当前进程的上下文

   即保存到PCB中

2. 恢复某个先前被抢占的进程被保存的上下文

3. 将控制传递给这个新恢复的进程

   控制的传递过程很简单，控制传递即要加载另一个进程的地址空间，这只需要将另一个进程的页表基址放到CPU的page table寄存器中。

在切换前，处理器会把PC置为上下文切换程序的起始地址，这需要从用户模式切换到内核模式，以便中断处理代码包含特权指令。

## 进程通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息

进程通信方法：

- 管道：包括了读和写，只能单向交替传输，只能在父子进程或者兄弟进程中使用
- FIFO（命名管道）：去除了管道只能在父子进程中使用的限制
- 消息队列：消息队列可以独立于读写进程存在，不需要进程自己提供同步方法，读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收
- 信号量：为多个进程提供对共享数据对象的访问
- 共享存储：多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，需要信号量来保证同步，多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存
- 套接字：也可用于不同机器间的进程通信，这也说明了网络通信最后是进程到进程通信。
- 远程调用RPC

<u>*todo：其他各种OS的进程通信方式：*</u>

# 线程

线程也可以称为轻量级进程。进程中的所有线程共享着该进程的状态和资源，所有线程都驻留在同一块地址空间，并可访问相同的元素。每个线程有自己的线程控制块、用户栈和内核栈

- 线程之间共享的：堆、全局变量、同一个进程的文件等资源、静态变量等
- 线程堵塞不会导致进程堵塞。但是如果一个线程崩溃那么进程也会崩溃。
- 线程可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

使用线程的示例：

- 前台和后台做不同工作
- 异步处理：每隔1分钟备份
- 执行速度：计算上
- 模块化程序
- 文件服务器

线程的优点：

- 创建、终止、切换线程时间少，通信效率高

其他：

- 如果一个进程被换出，由于所有线程都共享该进程的地址空间，因此所有线程都必须被换出
- 通过线程池管理线程获取并发性是一个非常基础的操作
- 线程分为用户级线程和内核级线程（暂且不表）
- 一个线程可以创建和撤销另一个线程。
- 如果一个线程崩溃那么进程也会崩溃。

**线程通信**

- 锁机制
- 信号量机制(Semaphore)
- 信号机制
- 共享内存：全局变量

# 问题

## 进程和线程

- 持有的资源类型：

  - 与进程相关的：虚拟地址空间、资源的保护访问；

  - 与线程相关的：线程状态、线程上下文、执行栈、线程局部变量、共享资源。

- 资源的分配上：

  - 进程是资源分配的基本单位，线程是调度的最小单位。

  - 每个进程都不共享它们自己的内存，因此独立运行；另一方面，线程共享分配给该进程的相同内存。

- 生命周期上/状态转换上/调度上：

  - 多线程环境下，调度和分派基于线程完成，有些活动会影响进程中的所有线程，挂起操作会把一个进程的地址空间换出内存，进程的所有线程于此同时也会都被挂起。进程终止会使得进程中的所有线程都终止。
  - 挂起态仅适用于进程，对于线程没有意义。
  - 线程是独立调度的基本单位。在同一进程中，线程的切换不会引起进程切换；但是从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换；进程的切换会引起线程的切换

- 抽象层次上：

  - 进程相对于线程一个重要的区别是有内核保证的隔离：数据和错误隔离。而线程不利于资源的管理和保护。

    线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，

  - 相对进程而言，线程是一个更加接近于执行体的概念，进程更像一个管理者

- 开销上：

  创建或撤销进程所付出的开销远大于创建或撤销线程时的开销，进程切换和线程切换同样如此。（两者大概差距了100倍，是数量级上的差距）

  - 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小

  - 线程有较轻的上下文切换开销，不用切换地址空间，不用更改寄存器，不用清空TLB。

  - 进程和线程之间的开销，用户级和内核级之间的开销，都是有数量级上的差距。

  - 核心切换开销：

    <u>*todo： 我不知道这个说的对不对*</u>

    现代的体系，一般 CPU 会有多个核心，而多个核心可以同时运行多个不同的线程或者进程。当每个 CPU 核心运行一个进程的时候，由于每个进程的资源都独立，所以 CPU 核心之间切换的时候无需考虑上下文。 

    当每个 CPU 核心运行一个线程的时候，由于每个线程需要共享资源，所以这些资源必须从 CPU 的一个核心被复制到另外一个核心，才能继续运算，这占用了额外的开销。换句话说，在 CPU 为多核的情况下，多线程在性能上不如多进程。

- 通信上：

  - 线程间通过直接读写同一进程中的数据进行通信，进程通信需要借助 IPC

  - 使用线程和共享内存 要比 使用进程和消息传递的速度快。

  - 进程共享复杂、线程共享高效：

    进程之间可以共享数据的方式大多需要复杂的实现（IPC）， 而线程之间代码、地址空间是共享的，共享数据的方式更加高效。（进程要考虑隔离，一个进程没有办法直接访问另一个进程；线程不用隔离，线程之间共享内存）

- 线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

## 适用场景

选择进程还是线程可以提高应用程序表现的答案取决于应用程序的用途。

使用线程场景：

- 进行大量计算的优先使用线程：

  所谓大量计算，就是要耗费很多CPU，切换频繁，这种情况下线程是合适的。这种原则最常见的是图像处理、算法处理。

- 多线程因为在同一个进程里，所以可以共享内存和其他资源，比如迅雷里10个线程一齐下载一个文件，这个文件是由进程打开的，然后10个线程都可以往里写入东西。如果是10个进程就不行了，操作系统不允许一个文件由两个进程同时写入

- 线程池加速：进程创建时间比较长，远远长于线程。

  尽管线程在新建和回收的效率上很高，但它还是一个耗时的操作，所以需要线程池等来加快这一类操作。线程之间的通信可以直接访问内存。

- 多机分布的用进程，多核分布的用线程

  - 进程可以拓展到多机，进程最适合多核

使用进程场景：

- 进程之间相互独立的特点使得他更稳定和安全：

  一个进程崩溃不会让另一个进程也为之崩溃，

  谷歌浏览器采用了多进程架构。考虑到用户打开了几个彼此无关的页面，并且其中一些页面无法正常工作，最好避免对其他页面造成影响。由于采用了这种架构，即使其他页面中断，我们也可以毫无问题地欣赏YouTube视频。也不会出现Flash插件出错崩溃导致整个浏览器崩溃的情况。

- 多机分布的用进程，多核分布的用线程

  - 进程可以拓展到多机，进程最适合多核

- 还应当结合具体的操作系统

  对于 Windows 系统来说，创建进程的开销很大，因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。

  对于 Linux 系统来说，创建进程的开销很小，Linux 下的学习重点大家要学习进程间通讯的方法。
