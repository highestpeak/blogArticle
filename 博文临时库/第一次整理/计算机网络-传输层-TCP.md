TCP可以说一系列规范，其中也有一系列的处理步骤是没有被RFC规定的，这为不同的实现提供了灵活的空间。TCP协议只在端系统中运行，中间路由器对TCP连接视而不见。

# TCP & UDP

TCP、UDP套接字

注意：<u>*todo: 套接字和传输层报文有区别。注意传输层报文（图3-3）、TCP传输层报文、UDP传输层报文（图3-7）的结构!! todo: 图*</u>

**UDP套接字**：**目的IP地址、目的端口号**

**TCP套接字**：**源IP地址、源端口号、目的IP地址、目的端口号**

- UDP套接字源主机通过bind绑定本机的UDP发送端口。

  如果两个UDP报文段有不同的源IP地址和/或源端口号，但有着相同的目的IP地址和目的端口号，这两个报文段将通过相同的目的套接字**被定向到相同的目的进程**。

- IP地址在TCP的传输层是有用的，并不是只是在网络层有用：

  游览器和web服务器建立http连接时都是访问80目的端口，但是服务器能够根据源IP地址和源端口来区分不同客户的报文段

## 区别

**:star:快速记忆：**

- TCP 面向连接、只支持单播；传输可靠、传输字节流、速率低、所需资源多；
- UDP 无连接、支持单播、多播；传输不可靠、传输数据报文段、速率高、所需资源少；

**共同点：**

- TCP UDP的**最基本责任**是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机交付扩展到进程交付被称为传输层的**多路复用和多路分解**。
- TCP UDP都提供进程到进程的**数据交付、差错检查**。

**不同点：**

- UDP**不可靠**，不保证进程发送的数据完整无缺地到达目标进程，可以以**任意速率**发送数据。
  - UDP对差错恢复无能为力
  
  - **UDP基本上差不多就是直接与IP打交道**，最低限度的提供了复用/分解服务，从网络层向应用级进程传递数据
  
    从这一点上我们可以用UDP来实现自己的"TCP"协议，这样可以放弃TCP中的一些不利的因素，例如拥塞控制等，虽然这么做不人道。
- TCP额外提供了可靠数据传输（流量控制、序号、确认、定时器）保证**正确有序**的进程到进程交付；
- TCP还额外提供了拥塞控制（调节发送端的**发送**流量**速率**）。

UDP的特点和**部分应用适合UDP的原因**：
1. **UDP**关于何时、发送什么数据的**应用层控制更为精确**（实时应用一般不希望过分延迟报文段发送，但TCP拥塞控制可能会阻止发送） （这一点即UDP基本上差不多就是直接与IP打交道，可以**在此之上构建其他协议**）
   1. 在应用层是可以构建基于UDP的可靠数据传输，虽然需要大量调试
2. UDP**无需连接建立**（不会引入连接建立过程）
3. UDP**无**连接**状态**（不维护连接状态，一般能支持**更多的活跃用户**）
4. UDP分组**首部开销小**

**TCP、UCP适用场景：**

- TCP：要求数据可靠：文件传输、邮件传输
- UDP：要求速度快：域名解析（DNS服务）

然而出于安全原因，某些机构阻塞UDP流量。并且如果大量的UDP报文发送到同一台路由器，路由器会有大量分组溢出，乃至于没有任何分组到达目的地。

# TCP可靠数据传输

## 可靠数据传输原理

在学习TCP的可靠传输之前，我们需要首先讨论一般通用的可靠数据传输原理。在这一小节的内容适用于一般的计算机网络，而不只是用于因特网传输层。另外的，如果我们要通过例如UDP构造自己的可靠传输协议则这些原理同样可以用到。

可靠数据传输的抽象是：上层数据可以通过可靠信道进行传输。而可靠信道的下层信道是不可靠的。TCP就是在不可靠的IP端到端网络层之上实现的可靠数据传输协议。

- 可靠的意思是：数据比特不会损坏、数据交付顺序正确

现在，我们一步步的研究可靠数据传输协议，从简单到复杂得到一个无错的、可靠的数据传输协议，然后进一步提高我们的效率。

---

可靠指的是解决了：丢失、损坏、延时过大。下面的做法包括：校验和、肯定和否定确认（累积确认、冗余确认）、序号、定时器、流水线（GBN和SR）、窗口和缓存。这些做法的结果动作其实都是重传。

- 比特差错的修复：

  这样的比特差错可能出现在网络的物理部件中。

  基于肯定确认和否定确认的可靠传输协议被称为自动重传请求协议（ARQ），ARQ需要额外的三种协议来帮助处理比特差错：

  - 差错检测：即引入额外比特进行检测（例如**校验和**等）
  - 接收方反馈：肯定确认**ACK**和否定确认**NAK**
  - 重传：有差错则发送方重传

  发送防将不会发送新数据，知道发送方取人接收方已正确接收当前分组。

  这一步构成的协议是停等协议。

- ACK和NAK分组受损的可能性：

  如果一个ACK或NAK分组受损，发送方无法知道接收方是否正确接受了上一块发送的数据。对应的接收方也就不知道当前接收的分组是否正确。

  解决这个问题需要引入**序号**。有了序号接收方就知道当前分组是否是重传的。

- 丢包事件：

  丢包导致需要关注的处理问题：怎样检测丢包以及丢包后该做什么。

  自然的想法是发送方等待足够长时间来确认是否分组已经丢失，即至少：往返时延+接收方处理时间。

  - 如果一个分组经历了一个特别大的实验，发送方可能会重传该分组，即使该数据分组及其ACK都没有丢失，这就导致了冗余分组。但是上一步的序号已经可以解决这个问题。

  重传是由**定时器**来控制的，定时器是倒计数定时器。

- **流水线**提高效率：

  前几步都是停等协议，性能低，可以采用流水线来提高效率。

  流水线考虑到的是信道的利用率：即发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比。

  流水线允许发送方发送多个分组而无需等待确认。

  流水线带来了新的问题：

  - 必须增加**序号范围**：因为现在可能会发送多个分组
  - 发送和接收方可能都要进行对多个分组**缓存**
  - 解决差错恢复的方法：回退N步（GBN）和选择重传（SR）。但是不管是哪个方法都使用了**滑动窗口**。

**回退N步 GBN：**

[计算机网络：自顶向下的方法-回退N步的图/动画](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html)

- 如果窗口满了的话：GBN会缓存上层的待发送数据，或者拒绝接收上层新的待发送数据
- 累计确认：对序号为n的确认意为：序号为n的以前且包括n在内分组都确认
- 超时：定时器
- 接收方只需要维护下一个按序接收的分组的序号
- 窗口长度和带宽时延都很大时，单个分组的差错就会引起GBN重传大量的分组，但是许多分组并没有必要重传

**选择重传 SR：**

[计算机网络：自顶向下的方法-选择重传的图/动画](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html)

- SR的实现要求每个分组都必须用友自己的逻辑定时器
- 如果接受方接收到以前没收到过的分组，则缓存该分组
- 如果接收方接收到的分组序号等于接收窗口的继续好，则该分组以及之前缓存的序号连续的分组交付给上层
- 接收方重新确认（而不是忽略）已收到过的那些序号小于当前窗口基序号的分组
- 发送方和接收方的窗口并不总是一致的
- 对于SR而言，**窗口大小**必须小于或等于**序号空间**大小的一般

---

**序号空间：**

由于序号可以被重新使用，那么必须小心这样的情况。

为了避免出现上面这个情况，需要确保一个序号不被重新使用，知道发送方”确信“任何先前发送的序号为x的分组都不在网络种为止。通过假定一个分组在网络种的”存活“时间不会超过某个固定最大时间量来做导这一点。

**滑动窗口：**

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

## TCP可靠传输

TCP一方面是用了上面可靠数据传输原理的一系列做法，另一方面TCP也有一些自己的特色。

这些特色体现在：TCP使用累计确认、TCP定时器会进行超时时间加倍、TCP快速重传、TCP是GBN和SR的混合体

- 累积确认：即发送方收到确认序号y，表明编号小于y的所有字节都已经正确接收

由于TCP采用累计确认会带来三种微妙的情况：

- 第一种情况：虽然A发出的报文段被B收到，但是B发往A的确认报文丢失了。

  这种情况下A会发生超时事件，然后A会重传相同的报文段，但是B会丢弃这个报文段。

- 第二种情况：A连续发送两个报文段，第一个序号为92长度为8字节，第二个序号为100长度为20字节。两个报文段都被B完整收到，但是B的两个确认都没有到达A。则A会在第一个超时事件到达后重传序号92的报文，然后重启定时器。但是如果这时A收到了B的ACK=120的确认，则A不会重传序号为100的报文段。

- 第三种情况：上面情况的相同报文段，这一次第一个报文段的确认报文在网络中丢失，但是ACK=120的确认报文没有丢失，则A不会重传。

快速重传指的是：

- 如果发送方TCP接收到对相同数据的3个冗余ACK，发送方认为这个已经被确认了3次的报文段之后的报文段丢失。这是执行快速重传
- 快速指的是：当前定时器没有过期，但是在3个冗余ACK后立刻重传

# TCP连接管理

TCP会将上层数据引导到连接的发送缓存，TCP会时不时从发送缓存中取出一块数据，但是TCP规范并没有提及TCP应该何时实际发送缓存的数据。

- TCP的资源包括了：缓存、端口等

TCP从缓存中取出并放入报文段中的数据数量受限于最大报文段长度MSS。MSS受限于本地发送主机发送的最大链路层帧长度（即最大传输单元MTU）。MTU为MSS加上TCP/IP首部字段长度。

- 注意：MSS是指的应用层数据的最大长度。而不是指包括TCP首部的TCP报文段的最大长度。

TCP连接组成包括：一台主机的缓存、变量和进程连接的套接字。

其他：

- TCP报文结构，估计往返时延RTT的算法。（这个不赘述）

  - 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，RTT计算在这里不赘述

- TCP的序号是建立在传送的字节流之上的，而不是报文段的序列置上。也就是说，每个字节都有一个序号。

  例如TCP给一个500 000个字节的文件分配序号，其中MSS为1000。则这样会划分成500个报文段，第一个报文段序号为0，第二个为1000，第三个为2000，以此类推。

- 主机A填充进报文段的确认号是主机A期望从主机B收到的下一个自己的序号

- TCP使用累计确认

- TCP连接双方的初始序号是随机选择的：

  这样可以减少将那些 *仍在网络中存在的来自两台主机之间的先前已经终止的连接的* 报文段，误认为是 *后来这两台主机之间新建连接所产生的* 有效报文段的可能性。（新旧连接碰巧使用了相同端口号）

---

## 连接建立

连接建立又叫三次握手

<u>*todo: 连接建立和终止的示意图*</u>

<img src="E:\_data\博文临时库\博文中的图片\tcp_open_close.jpg" style="zoom:50%;" />

1. SYN报文段：客户端向服务端发送报文：标志位`SYN=1`，`seq=client_isn`随机初始序号
2. SYNACK报文段：分配TCP缓存和变量，服务端向客户端发送报文：标志位`SYN=1`，`seq=server_isn`随机，`ack=client_isn+1`确认号
3. 连接建立：客户端分配缓存和变量，客户端向服务端发送报文，标志位`SYN=0`，`seq=client_isn+1`,`ack=server_isn+1`

注意：

- 为防止SYN攻击，只有第三次握手会携带数据，服务段会在第三次握手后分配资源

- ISN(Initial Sequence Number)不是固定的

  ISN随时间而变化，每个连接都将具有不同的ISN。

  三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

- **为什么需要传回SYN：**

  告诉发送端接收到的是发送端发送的信号，而不是其他信号。

- 第三次握手超时：

  即server端接到了client发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK。

  server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍。

  在第五次也超时后TCP才会把断开这个连接。

---

**为什么需要三次握手，而不是两次或者四次：**

三次握手的过程可以让双方分别确认自己和对方接收发送都正常，指定自己的初始化序列号并为后面的可靠性传送做准备。

- 第一次：server确认对方发送正常，自己接收正常

- 第二次：client确认自己发送、接收正常，对方发送、接收正常；client这时完成所有需要的确认。

  但服务端不能确认自己发送是否正常。

- 第三次：server确认自己发送、接收正常，对方发送、接收正常；server这时完成所有需要的确认。

如果采用两次握手，则不能解决历史旧连接的问题：

- 客户端共发出了两个连接请求报文段，其中第一个在网络中长时间滞留，第二个先到达了服务端。

  第一个连接之后到达了服务端，这让服务器误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接。但是这是错误的连接，并且浪费了服务端资源。

- 只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的：

  采用两次握手的话，发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求。接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接

  - 如果当前连接是历史连接，即 `SEQ` 过期或者超时，那么发送方就会直接发送 `RST` 控制消息中止这一次连接；
  - 如果当前连接不是历史连接，那么发送方就会发送 `ACK` 控制消息，通信双方就会成功建立连接；

- 两次握手让服务器很容易被攻击

使用三次握手是建立连接所需要的最小次数，四次握手降低效率，没有讨论的必要性。

---

**半连接队列：**

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

---

**SYN攻击：**

服务器为了响应TCP三次握手中的一个收到的SYN，需要分配并初始化连接变量和缓存。攻击者发送大量的TCP SYN报文段，而不完成第三次握手的步骤，服务器就会为这些半开连接分配大量的资源。

SYN攻击就是Client在短时间内向Server不断地大量发送SYN包，这些SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。

当在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。

常见的防御 SYN 攻击的方法有如下几种：

（一类是通过防火墙、路由器等过滤网关防护，另一类是通过加固TCP/IP协议栈防范）

- 缩短超时时间，减少服务端发送SYN-ACK的重试次数

- 增加最大半连接数

- 超过半连接队列最大数则直接拒绝连接

- 过滤网关防护

- SYN cookies技术

  服务器生成一个初始TCP序列号，这个学列好是SYN报文段的源和目的IP地址与端口号，以及仅有服务器知道的一个秘密随机数的复杂函数（散列函数）。

  这种初始序列号被称为”cookie“，服务器则发送具有这种特殊初始序列号的SYN ACK分组。服务器并不需要记忆该cookie或任何对应于SYN的其他状态信息。

  如果客户合法，则它会返回一个ACK报文段，并且客户会在返回的报文段对cookie加1，服务器则再吃重复第一步的过程，将结果加1和这个客户的确认值进行比较，如果相同，则客户合法。

## 连接拆除

连接拆除又叫四次挥手

<u>*todo: 连接建立和终止的示意图*</u>

<img src="E:\_data\博文临时库\博文中的图片\tcp_open_close.jpg" style="zoom:50%;" />

1. 客户端发送报文到服务端： FIN=1

2. 服务端发送报文给客户端：ACK

3. 服务端发送终止报文：FIN=1

4. 客户端发送给服务端：ACK
   
   1. 客户端在之后还会等待一般2MSL的时间才会关闭

其他：

- TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

- 客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态

- **为什么要四个步骤：**

  当一方发送完所有数据后，另一方可能还有数据需要发送，因此此时不能终止连接，只有**确保数据发送完毕**，才能发送FIN进行终止

- **为什么客户端最后还要等待2MSL：**

  1. 保证客户端发送的最后一个ACK报文能够到达服务器。

     因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

     是为了让服务器正确的进入关闭连接状态。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

  2. 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。

     客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。
     
     - 2MSL是任何报文段被丢弃前在网络内的最长时间
     - 这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。

- 如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。

  <u>*[todo：这样的情况怎么处理？](https://coolshell.cn/articles/11564.html)*</u>

---

其他问题：

- 已经建立连接，但如果客户端突然出现故障，会怎么样？
  - TCP有一个检测连接是否活跃的计时器

    - 如果出现出现故障并且计时器的到达指定时间（2小时），服务器就会发送探测报文，每隔指定时间（75s）发一次，如果发送超过指定次数（10次）仍没反应就会关闭连接
    - 服务器每次接收到客户端连接都会重新复位这个计时器
- 如果滑动窗口小到了可能比TCP首部字段字节数都小的地步，那么这个包就太小了，为了这么小的包进行一次网络发送，无疑是浪费。所以有些时候不去发送这样的小包，或者禁止大量发送小包。

# TCP流量控制和拥塞控制

流量控制和拥塞控制都是采用降低发送方速率的，但是出发点不同，发送方速率的决定者也不同。

- 出发点：
  - 流量控制是为了保证接收方来得及接收，是速度匹配，削除缓存溢出的可能性

    流量控制相当于设立了**缓冲区**

  - 拥塞控制是为了保护整个网络，为了降低整个网络的拥塞程度。

    如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。

- 速率决定者：

  - 流量控制的发送方速率由接收方决定：

    接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

    接收窗口：`rwnd = rcvbuffer - [ lastbytercvd-lastbyteread];`

  - 拥塞控制的发送方速率由网络拥塞程度决定：

    发送方需要维护一个叫做拥塞窗口（`cwnd`）的状态变量

- 注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

## 拥塞控制

- 慢启动：`cwnd=1 MSS` 开始每次进行翻倍，
  
- 慢启动终止：超时事件则将`cwnd`重置为1，3个冗余ACK执行快速重传，到达`ssthresh`阈值进入拥塞避免
  
- 拥塞避免：`cwnd`在到达上一次`ssthresh`慢启动阈值之后，每次增加1个MSS

- 快速重传/快速恢复：`cwnd=cwmd/2+3`

  - 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

    在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 `ssthresh = cwnd / 2` ，`cwnd=cwmd/2+3`，注意到此时直接进入拥塞避免。

  - 慢开始和快恢复的快慢指的是 `cwnd` 的设定值，而不是 `cwnd` 的增长速率。慢开始 `cwnd` 设定为 1，而快恢复 `cwnd` 设定为 `cwmd/2+3`。

阈值的变化只会在超时事件发生，超时事件后置为当前`cwnd`的一半

# 其他问题

- 沾包

  所谓的“沾包”（注意这是**应用层**的事情）（如何设计应用层协议的问题）

  ”沾包“这个词和TCP本来无关，它应当算是应用层协议的一部分，也不算是一个问题，这个词语可能就是单纯为了面试而出现的问题。但是和TCP总还是藕断丝连，稍做讲解也没有坏处。

  ”沾包“既是指前后两次消息发生了连接没有分隔开而在一次读取中读了出来。”沾包“是由于缓冲区而出现的麻烦，UDP因为有消息边界所以不会出现这一现象。

  为了解决这个麻烦，采取的步骤也很简单：

  - 约定特殊内容表示结束
  - 约定固定的发送长度
  - 把消息长度和消息一起发送
  - 立即发送数据，不进行缓冲（这样做就没有享受缓冲区带来的好处）




todo: https://www.nowcoder.com/discuss/530380

# 参考

> 1. [TCP的三次握手与四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891)
> 2. [CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.md)
> 3. 计算机网络 自顶向下的方法 原书第6版
> 4. https://draveness.me/whys-the-design-tcp-three-way-handshake/
> 5. https://coolshell.cn/articles/11609.html
> 6. https://coolshell.cn/articles/11564.html

