---

---

通过锁可以实现受限制资源的共享，序列化共享资源的访问。java提供了一套用于锁的机制，这套机制里主要的锁就是关键字synchronized和concurrent包中的lock类

虽然程序员不会在明明知道不存在数据竞争的代码块前加上同步。虽然没有显示使用锁，但是在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如**StringBuffer的append()方法，Vector的add()方法**。

# 锁名词

**（请注意：本部分参考了文末参考2，主要图文均来自该文章）**

Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本小节专门论述不同类型的锁和锁现象（介绍名词向的小节），例如：乐观锁、悲观锁；自旋锁、适应性自旋锁；无锁、偏向锁、轻量级锁、重量级锁；公平锁、不公平锁；可重入锁（递归锁）、不可重入锁；共享锁、排他锁（独享锁）（互斥锁）。

- **同步资源是否上锁**：乐观锁、悲观锁
- **是否选择堵塞**：自旋锁、适应性自旋锁
- **锁的状态**：无锁==>偏向锁==>轻量级锁==>重量级锁
- **获取锁的策略：是否需要排队**：公平锁、不公平锁
- 可重入锁（递归锁）、不可重入锁
- 共享锁、排他锁（独享锁）（互斥锁）

<img src="E:\_data\博文临时库\博文中的图片\JAVA锁名词.png" style="zoom: 50%;" />

部分锁的关系：

- 偏向锁、轻量级锁是乐观锁
- 重量级锁是悲观锁。
- synchronized关键字和Lock的实现类都是悲观锁

锁实现的概括：

- Java通过CAS无锁算法来实现乐观锁

---

⭐⭐⭐我尝试使用一个统一的描述来避免概念的割裂：

锁是为了解决资源访问的问题的，在获取同步资源的这个过程中，我们要不要排队：公平和不公平。如果获取到同步资源则对于同步资源的处理有不加锁和加锁（即乐观和悲观），如果没有获取到同步资源则做什么选择：堵塞和非堵塞，堵塞到什么程度：自旋和适应性自旋。当获取到锁之后，我们是否可以共享这把锁：共享锁和排他锁。

（也就是说我认为上面的这段话这些锁的名词以及包括可重入锁和非可重入锁，是每个锁实现都会进行二选一的）

- 对于可重入锁和非可重入锁我觉得是专门面向对象的，锁的持有者是对象而不是方法，这样就可以成为可重入锁（至少是我觉得）。
- 对于无锁、偏向锁、轻量级锁、重量级锁则是Java的synchronized的实现策略

## 乐观锁 & 悲观锁

乐观锁与悲观锁体现了看待资源竞争同步的不同角度，主要区别在**获取资源时是否加锁**：

- 悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
  - synchronized关键字和Lock的实现类都是悲观锁
- 乐观锁：乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。
  - 如果这个数据没有被更新，当前线程将自己修改的数据成功写入
  - 如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）
  - Java通过CAS无锁算法来实现乐观锁，Java原子类中的递增操作就通过CAS自旋实现的

适合的场景：

- **悲观锁**：适合**写操作**多的场景，先加锁可以保证写操作时数据正确。
- **乐观锁**：适合**读操作**多的场景，不加锁的特点能够使其读操作的性能大幅提升。

<img src="E:\_data\博文临时库\博文中的图片\悲观锁和乐观锁.png" style="zoom: 33%;" />

## 自旋锁 & 适应性自旋锁

阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，**线程挂起和恢复现场的花费可能会让系统得不偿失**。

为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

自旋锁的实现原理同样也是CAS。有三种常见的锁形式:`TicketLock`、`CLHlock`和`MCSlock`。

> 自旋锁本身是有缺点的，即它要占用处理器时间：

- 锁被占用的时间很短，自旋等待的效果就会非常好
- 锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源

所以，**自旋等待的时间**必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用`-XX:PreBlockSpin`来更改）没有成功获得锁，就应当挂起线程。

> 适应性自旋锁

自适应意味着**自旋的时间（次数）不再固定**，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：

- 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。

- 如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

<img src="E:\_data\博文临时库\博文中的图片\自旋锁和适应性自旋锁.png" style="zoom:50%;" />

## 公平锁 & 非公平锁

- **公平锁**：
  - 描述：多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁
  - 优点：等待锁的线程**不会饥饿**
  - 缺点：整体**吞吐效率**相对非公平锁要**低**，等待队列中除第一个线程以外的所有线程都会阻塞，CPU**唤醒阻塞线程的开销**比非公平锁**大**
- **非公平锁**：
  - 描述/过程：多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，
  - 优点：可以**减少唤起线程的开销**，整体的**吞吐效率高**，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。
  - 缺点：非公平锁有可能出现后申请锁的线程先获取锁的场景，等待队列中的线程可能饥饿

<img src="E:\_data\博文临时库\博文中的图片\公平锁打水示例.png" style="zoom: 33%;" />

<img src="E:\_data\博文临时库\博文中的图片\非公平锁打水示例.png" style="zoom:33%;" />

## 可重入锁 & 非可重入锁

- **可重入锁**：（递归锁）
  - 描述：线程在持有一个对象或class的锁时，再次尝试获取该对象的其他方法、实例变量等的锁会自动获取锁，不会因为之前已经获取过还没释放而阻塞。（锁计数会加一）
    - 例如线程获取了对象`doSomething`方法上的锁，`doSomething`方法体中需要调用`doOthers`，那么线程可以获得`doOthers`的锁
  - 优点：一定程度避免死锁
- **非可重入锁**：（与可重入锁相反，顾名思义）

<img src="E:\_data\博文临时库\博文中的图片\可重入锁打井示例.png" style="zoom:33%;" />

<img src="E:\_data\博文临时库\博文中的图片\非可重入锁打井示例.png" style="zoom:33%;" />

# synchronized

synchronized可作用于类和实例

synchronized线程执行互斥代码的六个过程：
（1）获得互斥锁；
（2）清空工作内存；
（3）从主内存中拷贝变量的最新值到工作内存；
（4）执行代码；
（5）将更改后的共享变量的值刷新到主内存；
（6）释放互斥锁。

java提供关键字synchronized（该关键词检查锁是否可用、然后获取锁、执行代码、释放锁）

- 可重入锁，对象实例上的锁：
  - 对于某个特定对象来说，其所有 synchronized 方法共享同一个锁，这可以被用来防止多个任务同时访问被编码的对象内存。
  - 一个任务可以多次获得对象的锁，在任务第一次给对象加锁的时候，计数变为1，毎当这个相同的任务在这个对象上获得锁时，计数都会递增，每当任务离开一个 synchronized方法，计数递减，当计数为零的时候，锁被完全释放，此时别的任务就可以使用此资源。
- 类上面的锁：
  - 针对每个类，也有一个锁（作为类的Cas对象的一部分），所以 synchronized static方法可以在类的范围内防止对 static数据的并发访问。
- 访问限制：
  - 注意，在使用井发时，将域设置为 private是非常重要的，否则， synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突。

关于实列锁和类锁的写法：

- 类锁：修饰静态方法、代码块`synchronized(X.class)`
- 实例锁：修饰实例方法、代码块`synchronized(this)`、`synchronized(other object)`

在synchronized的语法中，我们除了要知道在哪里给谁加锁以外，还需要用花括号包围一个临界区。

**临界区构建：**

``` java
synchronized(syncObject){//在进入此段代码之前，必须得到syncObject的锁
    // this code can be accessed by only one task at a time
}
```

- 如果在this上同步即synchronized(this)那么临界区的效果就会直接缩小在同步的范围内。

- 有时必须在另一个对象上同步，但是如果你要这么做，**就必须确保所有相关的任务都是在同一个对象上同步的**（如方法A和方法B都使用了一个list变量域来进行添加删除元素，那么就要使用同一个对象来对其同步）。

  下面的示例演示了两个任务可以同时进入同一个对象，只要这个对象上的方法是在不同的锁上同步的即可。下面的示例中，两个方式在同时运行，因此任何一个方法都不会因为另一个方法的同步而被堵塞。

  ``` java
  class DualSynch {
    private Object syncObject = new Object();
    public synchronized void f() { // sync this
      for(int i = 0; i < 5; i++) {
        print("f()");
        Thread.yield();
      }
    }
    public void g() {
      synchronized(syncObject) { // syncObject
        for(int i = 0; i < 5; i++) {
          print("g()");
          Thread.yield();
        }
      }
    }
  }
  ```


## 实现和优化

（这部分能回答：为什么Synchronized能实现线程同步？）

### 实现

synchronized最初实现同步的方式，依赖于操作系统Mutex Lock所实现，这样的锁为“重量级锁”（这就是JDK 6之前synchronized效率低的原因）。JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。



synchronized作用于方法 和 作用于他包围的语句块 在编译后的字节码来看是不一样的，但是最终都是是用了Monitor对象来实现的。

- 被 synchronized 修饰的同步方法。同步方法 是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的。
- 被 synchronized 修饰的语句块，是由 monitorenter 和 monitorexit 指令来实现同步的。

每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。

monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因(关于这点稍后还会进行分析)，



可重入锁是通过对计数器的计数修改实现的。



监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，



出现几种锁状态，即无锁、偏向锁、轻量级锁、重量级锁的原因：

- 偏向锁：经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得
- 轻量级锁：“对绝大部分的锁，在整个同步周期内都不存在竞争”，轻量级锁所适应的场景是线程交替执行同步块的场合

自旋锁：轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。

自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。





<u>*todo: 这部分对象头什么的是不是应该单独成文*</u>

在一系列的迭代之后，我们再想弄明白synchronized的原理，就需要学习以下Java底层的一些知识，例如“Java对象头”和“Monitor”。

> **对象头：**

![](E:\_data\博文临时库\博文中的图片\synchronized中的对象头.png)

注意看这个对象头的构成，是由两个字组成的。Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间。即锁标志位是00和10相应的左边的30个bit是不同的。

- 如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度



以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。

- **Mark Word**：

  默认存储对象的HashCode，分代年龄、锁信息和GC标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。

- **Klass Point**：

  对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

> **Monitor：**

Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。

Monitor是**线程私有**的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。**每一个被锁住的对象都会和一个monitor关联**，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。

synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。

### 优化

为了让线程获取锁的代价降低，减少切换线程带来的开销，Java采取了一系列措施。

synchronized在jdk6之后的实现一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。

- 锁在大多数情况下不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁
- 重量级锁要切换进程，切换用户态和内核态，开销大，因此使用CAS操作实现轻量级锁。进一步的采用CAS实现的有一定CAS次数限制的自旋锁，适应性自旋锁则取消了次数限制
- 锁有了粗化和削除的一个过程：
  - 锁粗化：偏向锁==>轻量级锁==>重量级锁
  
  - 锁消除：JVM检测到不可能存在共享数据竞争，则JVM会对这些锁进行锁消除。锁消除可以节省毫无意义的请求锁的时间。可以通过逃逸分析来检测是否进行锁削除。
  
    如下面的例子，`StringBuffer` 是局部变量，不可能存在竞争
  
    ``` java
    public void add(String str1, String str2) {
        //StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用
        //因此sb属于不可能共享的资源,JVM会自动消除内部的锁
        StringBuffer sb = new StringBuffer();
        sb.append(str1).append(str2);
    }
    ```
  
    

### 无锁 & 偏向锁 & 轻量级锁 & 重量级锁

<u>*todo：这一部分的内容暂时没有整理完*</u>

通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：

| 锁状态   | 存储内容                                                | 存储内容 |
| :------- | :------------------------------------------------------ | :------- |
| 无锁     | 对象的hashCode、对象分代年龄、是否是偏向锁（0）         | 01       |
| 偏向锁   | 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1） | 01       |
| 轻量级锁 | 指向栈中锁记录的指针                                    | 00       |
| 重量级锁 | 指向互斥量（重量级锁）的指针                            | 10       |

![](E:\_data\博文临时库\博文中的图片\锁膨胀流程.png)

这四种锁是指锁的状态，专门针对synchronized的。锁状态只能升级不能降级.

- **无锁**：
  - 描述：没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功
  - 过程：修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。
  - **CAS原理**及应用即是无锁的实现
- **偏向锁**：
  - 描述：一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。（在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。）
  - 过程：
    - 检查 `mark word` 的`线程 id` 。
    - 如果为空则设置 CAS 替换当前线程 id。如果替换成功则获取锁成功，如果失败则撤销偏向锁。
    - 如果不为空则检查 `线程 id`为是否为本线程。如果是则获取锁成功，如果失败则撤销偏向锁。
  - 偏向锁可以提高带有同步但无竞争的程序性能。
  - 
- **轻量级锁**：
  - 描述：偏向锁升级为轻量级锁后，其他线程会通过**自旋**的形式尝试获取锁，不会阻塞，从而提高性能
  - 过程：过程1==>过程2==>过程2.1、过程1==>过程2==>过程2.2==>过程2==>过程2.2==>......==>过程3
    - 过程1：代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。
    - 过程2：拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word
      - 过程2.1：如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。
      - 过程2.2：如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。
    - 过程3：若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁
  - 加锁过程：
    1. JVM 在当前线程的栈帧中创建 Lock Reocrd，并将对象头中的 Mark Word 复制到 Lock Reocrd 中。（Displaced Mark Word）
    2. 线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向 Lock Reocrd 的指针。如果成功则获得锁，如果失败则先检查对象的 Mark Word 是否指向当前线程的栈帧如果是则说明已经获取锁，否则说明其它线程竞争锁则膨胀为重量级锁。
  - 锁释放：<u>*todo:不知道下面三点对不对*</u>
    - 取出在获取轻量级锁保存在Displaced Mark Word中的数据；
    - 用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行
    - 如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。
  - 解锁
    使用 CAS 操作将 Mark Word 还原
    如果第 1 步执行成功则释放完成
    如果第 1 步执行失败则膨胀为重量级锁。
  - 其性能提升的依据是对于绝大部分的锁在整个生命周期内都是不会存在竞争。在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。
- **重量级锁**：
  - 描述：为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入**阻塞**状态。
  - 通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从**用户态到内核态**的切换，切换成本非常高。
  - 他的代价一方面是因为阻塞了太多的线程，一方面是上面说的可能涉及到的用户态和内核态切换
  - 在重量级锁中没有竞争到锁的对象会 park 被挂起，退出同步块时 unpark 唤醒后续线程。唤醒操作涉及到操作系统调度会有额外的开销
  - `ObjectMonitor` 中包含一个同步队列
  - 重量级锁的原理是管程

从轻量级锁到重量级锁的过程中，或重入时会多次尝试自旋获取锁以避免线程唤醒的开销。

但是自旋它会占用 CPU 的时间因此如果同步代码块执行时间很短自旋等待的效果就很好，反之则浪费了 CPU 资源。默认情况下自旋次数是 10 次用户可以使用参数 `-XX : PreBlockSpin` 来更改。

所以为了降低时间又引入了适应性自旋锁。



> 对比：

- 偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。
- 轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。
- 重量级锁是将除了拥有锁的线程以外的线程都阻塞。
- 引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为**轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换`ThreadID`的时候依赖一次CAS原子指令**即可(<u>*todo: 依然不是很能理解*</u>)

> 状态转换：

- 偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁
- 偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。
- 处于轻量级锁时：若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

![](E:\_data\博文临时库\博文中的图片\JAVA锁状态转换.png)

## 可重入锁实现原理

每一个可重入锁都会关联一个线程ID和一个锁状态status。
当一个线程请求方法时，会去检查锁状态，如果锁状态是0，代表该锁没有被占用，直接进行CAS操作获取锁，将线程ID替换成自己的线程ID。如果锁状态不是0，代表有线程在访问该方法。此时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法。如果是非重入锁，就会进入阻塞队列等待。
释放锁时，可重入锁，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。
释放锁时，非可重入锁，线程退出方法，直接就会释放该锁。

# lock

使用显式的Lock对象。即使用lock.lock()和lock.unlock()来包围住需要加锁的区域。对于某些类型的问题更为灵活。使用lock的示例如下：

``` java
private Lock lock = new ReentrantLock();
public int next() {
    lock.lock();
    try {
        ++currentEvenValue;
        Thread.yield(); // Cause failure faster
        ++currentEvenValue;
        return currentEvenValue;
    } finally {
        lock.unlock();
    }
}
```

- Lock方式来获取锁支持中断、超时不获取、是非阻塞的
- 提高了语义化，哪里加锁，哪里解锁都得写出来
- Lock显式锁可以给我们带来很好的灵活性，但同时我们必须手动释放锁
- 支持Condition条件对象
- 允许多个读线程同时访问共享资源
- ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁
- `ReentrantLock`和`NonReentrantLock`都继承父类AQS

# synchronized & lock

<u>*todo：这部分没怎么整理好*</u>

这个地方有关于synchronized的与mark workds相关的实现原理：[CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%8D%81%E4%BA%8C%E9%94%81%E4%BC%98%E5%8C%96)

ReentrantLock和synchronized都是可重入锁

synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。

synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

一个 ReentrantLock 可以同时绑定多个 Condition 对象。

- **清理资源**上：lock方便清理，synchronized会抛出异常

  如果在使用synchronized关键字时，某些事物失败了，那么就会抛出一个异常。但是你没有机会去做任何清理工作，以维护系统使其处于良好状态。有了显式的Lock对象，你就可以使用 finally子句将系统维护在正确的状态了。

- **易用程度**上：synchronized更易用，代码更少

  当你使用synchronized关键字时，需要写的代码量更少，并且用户错误出现的可能性也会降低，因此通常只有在解决特殊问题时，才使用显式的Lock对象。

  - 例如：用synchronized关键字不能尝试着获取锁且最终获取锁会失败，或者尝试着获取锁一段时间，然后放弃它，要实现这些，你必须使用concurrent类库

- **获取锁**：synchronized是堵塞的，ReentrantLock 可中断锁的获取过程

  这件事上：ReentrantLock允许你尝试着获取但最终未获取锁，这样如果其他人已经获取了这个锁，那你就可以决定离开去执行其他一些事情，而不是等待直至这个锁被释放（而synchronized会一直堵塞在这里）。

- **灵活性**：Lock更灵活

  显式的Lock对象在加锁和释放锁方面，相对于内建的 synchronized锁来说，还赋予了你更细粒度的控制力。这对于实现**专有同步结构**是很有用的，

  - 例如用于遍历链接列表中的节点的节节传递的加锁机制（也称为锁耦合），这种遍历代码必须在释放当前节点的锁之前捕获下一个节点的锁

  - **临界区构建**上：

    - 使用synchronized可以构建临界区。

      ``` java
      synchronized(syncObject){//在进入此段代码之前，必须得到syncObject的锁
          // this code can be accessed by only one task at a time
      }
      ```

    - 也可以使用lock对象`lock.lock()`;和`lock.unlock()`;包围起来一个临界区。不一定在同一个区域。但是这样设计就会增加复杂性，很可能陷入死锁和饥饿

# 参考

> 1. Java 编程思想 第四版 中文版 第十二章
> 2. [美团技术团队：不可不说的Java"锁"事]
> 3. https://blog.csdn.net/javazejian/article/details/72828483
> 4. https://xiaomi-info.github.io/2020/03/24/synchronized/

