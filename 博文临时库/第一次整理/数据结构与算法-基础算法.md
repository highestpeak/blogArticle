我认为在这里的算法，需要达到这样的速度：“不需要思考”，写代码的速度就是打字的速度。并且没有错误。



# 双指针

双指针分为几类：

- 快慢指针
  - 指定步长间隔的指针
- 左右双指针
  - 三指针等

对应的它们典型的解决的问题：

- 快慢指针
  - 判定链表中是否含有环
  - 寻找链表的中点
  - 指定步长间隔的指针：
    - 寻找链表的倒数第 k 个元素
- 左右双指针
  - 二分查找
  - 滑动窗口
  - 两数之和
  - 回文系列
  - 三指针等

---

其他使用双指针的特殊题目：

- [判断子序列](https://leetcode-cn.com/problems/is-subsequence/)
  - [该题目有一种解法可用二分查找](https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E5%AD%90%E5%BA%8F%E5%88%97.md)
- [寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

# 二分查找

二分查找除了我们一般认为的查找之外，还有一种作用：快速的探查。例如开方函数实现的快速探查，贪吃的小Q那道题的快速探查。

二分查找不是简单，而是困难的，因为有很多细节。另外我在 fucking-algorithm 这个系列里看到的用搜索区间来理解二分查找，这样的思路感觉很好。

首先说一下二分查找几个需要注意的地方：

- 计算中值

  - m = (l + h) / 2
  - m = l + (h - l) / 2 防止加法溢出

  进一步的变成右移位运算：m = l + (h - l) >> 1

- 未成功查找的返回值

基本框架：

``` java
int binarySearch(int[] nums, int target) {
    int l = 0, h = ...;
    while(...){
        int mid=l+(h-l)>>1;
        if(nums[mid]==target){
            ...
        }else if(nums[mid] < target){
            l=...
        }else if(nums[mid] > target){
            h=...
        }
    }
}
```

省略部分采用区间的想法来思考，如果我们让 `h=nums.length-1` 那么搜索区间就是 `[l,h]`；如果我们让 `h=nums.length` 那么搜索区间就是 `[l,h)`。

while循环是当搜索区间为空的时候中止，我们采用 `[l,h]`的做法，则 `l>h` 的时候while就应该终止了，也就是while继续的条件是 `l<=h` 。

- 如果采用`[l,h)`的做法，那么就应该是 `l<h`

然后看l和h的更新操作，这个地方有人写 `mid+1` 和 `mid-1` ，也有人就写 `mid`。思考一下，第一个if分支已经判断了mid不是目标值，而且我们的区间是闭区间，那么mid就不应该是下一次搜索要用的值了。

因此得出基本的二分查找算法：

``` java
int binarySearch(int[] nums, int target) {
    int l = 0, h = nums.length-1; // 注意这里
    while(l<=h){ // 注意这里
        int mid=l+(h-l)>>1;
        if(nums[mid]==target){
            return mid;
        }else if(nums[mid] < target){
            l=mid+1; // 注意这里
        }else if(nums[mid] > target){
            h=mid-1; // 注意这里
        }
    }
    return -1;
}
```

## 左侧边界二分查找

（右侧边界的查找同理）

- 可用于在已经排序的数组中找到比target小的数有多少个。（target不一定在数组中）
- 可用于找到一连串重复元素的最左边的那一个

``` java
int binarySearch(int[] nums, int target) {
    int l = 0, h = nums.length-1;
    while(l<=h){
        int mid=l+(h-l)>>1;
        if(nums[mid]==target){
            h=mid-1; // 注意这里
        }else if(nums[mid] < target){
            l=mid+1; // 注意这里
        }else if(nums[mid] > target){
            h=mid-1; // 注意这里
        }
    }
    return l; // 注意这里
}
```

他的想法是，如果mid等于target，则可能左边仍然会有target，那么让h变小。

- 如果左边没有target的话，最终l会一直到这个h，然后l会比h大一，找到最左的target
- 如果左边有target的话，则会继续查找

在这样的查找中，我们可以发现小于和等于的情况可以合并。

---

二分查找相关的题目：

- 求开方
- 贪吃的小Q，N天M块巧克力，每天吃的不少于前一天的一半，每天都要有巧克力吃，求第一天最多吃多少巧克力
  - [爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/) (为什么这只猴子叫这个名字😶)
- 大于给定元素的最小元素（求右边界）
- 有序数组的 Single Element：一个有序数组只有一个数不出现两次，找出这个数。
- 第一个错误的版本
- 旋转数组的最小数字
- 查找区间，Find First and Last Position of Element in Sorted Array，
  - 即找左右边界
- [找出数组中重复的数，数组值在 [1, n] 之间](https://leetcode-cn.com/problems/find-the-duplicate-number/description/)
- 二维有序数组中查找目标值（元素从左到右增大，从上到下增大）

在这些题目中，变化的是 `[l,h]` 这个区间

# 滑动窗口

滑动窗口适合解决找到满足某一条件的区间，他有几个重要的元素：双指针、HashMap计数，所做的工作就是移动left和right指针，判断内部的元素是否满足要求。

滑动窗口算法的思路是这样：

1. 使用双指针中的左右指针，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」
2. 先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的区间符合要求
3. 此时，我们停止增加 right。转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的区间不再符合要求。同时，每次增加 left，都要更新一轮结果。
4. 重复第 2 和第 3 步，直到 right 到达尽头。

``` java
int left = 0, right = 0;

while (right < s.size()) {
    window.add(s[right]);
    right++;
    
    while (valid) {
        window.remove(s[left]);
        left++;
    }
}
```

其中判断符合要求的做法一搬就是HashMap或者HashSet。

---

相关题目：

- 无重复字符的最长子串
- 找到字符串中所有字母异位词
- 最小覆盖子串

# 排序算法

- 冒泡排序和堆排序
- 堆
- 手写快速排序
- 写个冒泡排序（牛客编译通过即可）
- 什么是稳定的排序，冒泡排序是不是稳定的排序，稳定的排序的应用场景

排序算法

- 适合场景和时间复杂度

- ![](E:\_data\博文临时库\博文中的图片\排序算法的比较.jpg)

- ⭐⭐⭐归并排序、快速排序的详细步骤！！！

  堆排序、冒泡排序

- 时间和空间复杂度

- 什么时候用快排什么时候用冒泡？

- 手写快排
- 堆排序时间复杂度，稳定性
- 堆除了用来排序，还能做什么？
- 写一个归并排序