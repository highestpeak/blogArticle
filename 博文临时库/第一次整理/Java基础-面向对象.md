---
title: 
description: 
tags:
- JAVA

create_time: 2020-8-4
---

（很多其他的关于面向对象的知识较为复杂，稍后再进行整理）

<u>*todo：暂时不要发布，因为不完整*</u>

# this & super

- 子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分
- this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块

# 重写和重载

- 重写（override）：父子类，相同点：方法名、参数列表，不同点：返回值、异常、访问修饰符（不同点的类型有限制，父子类必须满足利斯科夫替换原则）
- 重载（overload）：同一个类，相同点：方法名，不同点：参数类型、参数个数、参数顺序；
  - 至少有一个不同点
  - 返回值不同，其它都相同不算是重载，也就是与返回值无关

ride有一个骑的意思，有一个上下的意味，和父子这样的层级关系有点对应。

重写不改变参数，而重载会改变参数。

# 接口和抽象类

接口的字段默认都是 static 和 final 的

从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。

- 从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。
- 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。
- 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
- 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。
- 接口可以继承多个接口

在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。

https://dzone.com/articles/when-to-use-abstract-class-and-intreface

[https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#hashcode](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java 基础.md#hashcode)

抽象类和接口的区别，面向接口编程

相同点：

- 都不能实例化

不同点：

- 只能继承一个抽象类，而可以实现多个接口。这是很大的一个区别。
- 对我而言接口更像是一组行为的集合。而抽象类是类，类表达的是一种是什么的东西，更像是事物的本质。
- 抽象类可以含有状态变量。接口只能声明状态变量
- 抽象类可以声明private方法等，具有更好的隐藏性

---

<u>*todo：*</u>

与接口相关的还有**接口设计**

接口方法的形参其实不是很重要？或者接口形参的设计是需要深思熟虑的，

如果形如回调那么形参可能必要

但是接口的实现必然是由类来实现的（或者lambda和匿名内部类实现），这样的实现方式是可以访问到各自类内部的私有域的，并且这样的访问可能也是必须的，那么这个时候形参就不是必要的了。

---

Java不支持类的多继承，但是一方面可以用实现多个接口来实现多重继承。另一方面可以用组合实现继承，也可以用内部类继承其他类来实现多重继承。

# 面向对象基本原则

面向对象三大特性是：封装,继承,多态。五大基本原则是开闭原则、单一职责原则、依赖倒置原则、`Liskov`替换原则、接口分离原则

- 一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。此外还有对访问级别限制的访问修饰
- 要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现
- 多态就是指一个类实例的相同方法在不同情形有不同表现形式

几个基本原则：

- 依赖倒置原则：把 车依赖于轮子 改成 轮子注入车？？
- 替换原则：子类可以替代父类或出现在父类能够出现的地方

在这几个基本原则中，依赖倒置原则体现在IOC中。