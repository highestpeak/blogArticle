---

---

# HTTP

HTTP全称超文本传输协议（HyperText Transfer Protocol）。HTTP由不同端系统上的**客户**程序和**服务器**程序实现。

**HTTPS**是安全版的HTTP，因为HTTP协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，HTTPS就是为了解决HTTP的不安全而生的。在HTTPS部分，需要重点理解HTTPS如何保证安全，连接建立流程。

HTTP使用**TCP**作为支撑它的传输层协议。HTTP是**无状态**协议，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。无状态指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。此外HTTP的连接也有很多不同类型：

- 非持续连接和持续连接（又称长连接和短连接）

  短链接：访问HTML和访问其中的元素都会建立一个HTTP连接，从 **HTTP/1.1起，默认使用长连接**，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：`Connection:keep-alive`。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。实现长连接要客户端和服务端都支持长连接。

- 串行连接和并行连接

  例如请求HTML中的元素，可以并行请求3个图片的，而不是一个一个请求

- 流水线和非流水线

HTTP的报文分为请求报文和响应报文，报文一般含有四个部分：状态行、首部行、空行、body：

- **请求报文：**
  - 请求行（状态行）：请求方法、URL、HTTP协议版本，空格分隔
  - 请求头部（首部行）：键值对，
    - 例如User-Agent、Accept、Host等
  - 空行
  - 请求体：请求携带的数据
- **响应报文：**
  - 响应行（状态行）：协议版本、状态码、状态码原因短语
  - 响应头（首部行）：响应字段
    - 例如Date、Last-Modified等
  - 空行
  - 响应体（实体entity body）：响应的数据

从报文结构可以看出，请求方法、状态码是一个重要的内容，就我认为请求方法、状态码、首部字段等是一种约定，我们应当尽量去遵守，（你尽管可以让get每天996去做post的工作）

对于一些查表内容，将放到wiki里面，例如：首部字段

- 有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段

## 请求方法 & 状态码

请求方法有：**GET**、**POST**、HEAD、**PUT**、**DELETE**、OPTIONS、PATCH、CONNECT、TRACE。

状态码有五类，分别表示者不同的情况。（注意错误分为客户端错误和服务端错误）

- 信息响应(100–199)
- 成功响应(200–299)：200、204、206 
- 重定向(300–399)：301、302、304 
- 客户端错误(400–499)：400、401、 403、404 
- 服务器错误 (500–599)：500、503

为什么我们需要了解请求方法和状态码：

- 了解请求方法的作用、区别、应用场景，这不仅仅是为了面试什么的，也是帮助我们在编码时做出选择。 
- 了解状态码和了解请求方法的目的大体相同，一方面他帮助我们在编码时选择返回什么状态码，另一方面也帮助我们可以识别一些类库、开源组件的功能。这其实就是约定和规则的好处

## 请求方法之间的区别

主要讲述以下几个的区别

- GET、POST都是常用的数据请求和传输方法，他们有什么区别？
- PUT、POST都是常用的数据修改方法，他们又有什么区别？
- PUT、PATCH都是给服务器发送修改资源，他们又有什么区别？

> **GET、POST区别**

⭐⭐⭐**简单的区别总结：（从数据和有无状态入手）**

- get数据在URL，数据类型只能为ASCII字符，不安全。无状态：不会引起服务器状态变化，幂等
- post数据在body，数据类型无限制，一定安全性。有状态：会引起服务器状态变化，非幂等，不可缓存，

详细的区别：

- 数据传输方式：

  - GET请求通过URL传输数据
  - POST的数据通过请求体传输

- 安全性：

  - GET的数据在URL中，通过历史记录，缓存很容易查到数据信息
  - POST的数据因为在请求主体内，所以有一定的安全性保证
    - 不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看
  - GET不会引起服务器状态变化
  - POST会引起服务器状态变化

- 数据类型：

  - GET只允许 ASCII 字符
    - 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码
  - POST无限制

- 提交上(幂等性上)：

  - **幂等**：同一个请求方法执行多次和仅执行一次的效果完全相同（无副作用）
  - GET幂等、POST非幂等
    - 刷新、后退等浏览器操作GET请求是无害的
    - POST可能重复提交表单，服务器应对此进行校验

- XMLHttpRequest上的区别

  - 为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：

    > XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。

    - 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。
    - 而 GET 方法 Header 和 Data 会一起发送。

> **PUT、POST的区别**

简单的区别总结：

- PUT幂等，指向是具体单一资源
- POST非幂等，指向是资源集合

详细的区别：

- 提交上：
  - PUT方法是幂等的
    - 把『xxx』修改成『yyy』，提交多少次都是修改成『yyy』
  - POST方法是非幂等的
    - 例如POST文章，会创建新的文章，多次提交会创建多个文章
- 资源指向：
  - PUT的URI指向是具体单一资源
  - POST可以指向资源集合

- 『POST表示创建资源，PUT表示更新资源』这种说法是错误的，两个都能创建资源，根本区别就在于幂等性

> **PUT、PATCH区别**

PUT和PATCH都是更新资源，而PATCH用来对已知资源进行**局部更新**。

比如我们有一篇文章的地址`https://www.jianshu.com/articles/820357430`，这篇文章的可以表示为:

```json
article = {
    author: 'dxy',
    creationDate: '2019-6-12',
    content: 'PUT、PATCH区别',
    id: 820357430
}
```

当我们要修改文章的作者时，我们可以直接发送`PUT https://www.xxxx.com/articles/123456`，这个时候的数据应该是:

```json
{
    author:'aaa',
    creationDate: '2019-6-12',
    content: 'PUT、PATCH区别',
    id: 820357430
}
```

这种直接覆盖资源的修改方式应该用put，但是你觉得每次都带有这么多无用的信息，那么可以发送`PATCH https://www.xxxx.com/articles/123456`，这个时候只需要:

```json
{
    author:'aaa',
}
```

# HTTPS算法⭐

由于HTTP有一系列的安全问题，HTTPS便出现了，它使用SSL来进行加密、认证和保护。即通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）的功能。

- HTTP 有以下安全性问题：
  - 使用明文进行通信，内容可能会被窃听
  - 不验证通信方的身份，通信方的身份有可能遭遇伪装
  - 无法证明报文的完整性，报文有可能遭篡改
- HTTPS 的缺点
  - 因为需要进行加密解密等过程，因此速度会更慢；
  - 需要支付证书授权的高额费用

**为了更好的理解HTTPS算法，我们要梳理一下出现的问题和不断地改进：**

- HTTPS首先就要解决加密的问题，这就有了**对称加密和非对称加密**两种方案。为了保证速度和加密安全有效，HTTPS**综合采用**了这两种方案
- 中间人可以劫持公钥，并替换成伪造的公钥，为了解决这个问题就需要一个第三者，即客户端和服务器都认可的机构来验证客户端和服务器的身份，即出现了**证书**
  - 现实生活中，如果想证明某身份证号一定是小明的就需要看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中的证书颁发机构就是给网站颁发一个“身份证”
- 中间人很聪明，它可以篡改证书。为了保证证书的真实性，又引入了**数字签名**技术。即CA机构用自己的私钥进行加密证书
  - 身份证防伪技术

HTTPS在每次请求过程中也不是都会传输密钥，他只会传输一次，用session在服务端为每个请求者例如游览器保存一个ID，之后浏览器每次请求都会携带session ID，这样就不必要每次重新制作、传输密钥。

**完整的过程：**

服务器把证书发送给客户端，客户端用自己游览器或操作系统中已经安装的CA机构的公钥解密证书，证实服务器身份和证书有效性。

浏览器从证书里取出公钥。游览器自己计算对称加密的一个随机值以生成秘钥，使用取出的公钥传递这个对称加密的秘钥，服务器接收到这个对称加密的密钥，双方的HTTPS连接建立。

- 整个过程有两套私钥公钥，一套CA机构的，一套服务器的
- 更为细节的过程到下面的小节去查看

## 对称加密、非对称加密

- 对称密钥加密（Symmetric-Key Encryption）：

  加密和解密使用同一密钥，密钥不应该被第三者知道

  - 优点：运算速度快

  - 缺点：无法安全地将密钥传输给通信方

    <img src="E:\_data\博文临时库\博文中的图片\https对称密钥加密.png" style="zoom:75%;" />

- 非对称密钥加密（公开密钥加密）（Public-Key Encryption）：

  加密和解密使用不同的密钥。用公钥加密的内容必须用私钥才能解开，私钥加密的内容只有公钥能解开。

  - 优点：可以更安全地将公开密钥传输给通信发送方；
  - 缺点：运算速度慢。

  公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

  <img src="E:\_data\博文临时库\博文中的图片\https非对称密钥加密.png" style="zoom:75%;" />

**非对称密钥除了用来加密，还可以用来进行签名**。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

---

## 第三者-CA机构

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

操作系统、浏览器本身会预装一些它们信任的根证书，如果其中有该CA机构的根证书，那就可以拿到它对应的可信公钥。有一些证书没有被预制，这就需要安装证书，安装完之后游览器就会信任该CA机构的证书，这个机构是否值得信任是另一回事。

**CA机构生成证书：**

CA机构有一个它自己的私钥和公钥，CA机构对他即将颁发的证书的明文信息进行hash，对hash后的值使用CA机构自己的私钥进行加密，得到数字签名。**明文和数字签名共同组成数字证书**，这份数字证书就会颁发给申请者，即申请的网站。

数字证书里有签发者、证书用途、使用者公钥、使用者的HASH算法、证书到期时间、域名等信息，证书就如身份证一样，可以证明“该公钥对应该网站”。

- 中间人**不可能篡改**证书，因为证书是被CA机构自己的私钥进行加密的，中间人没有这个私钥就无法得到一致的数字签名

- 中间人也**不可能换掉**证书，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被换掉

- 申请者可以选择申请的HASH算法

  <img src="E:\_data\博文临时库\博文中的图片\https证书.png" style="zoom:75%;" />

**浏览器验证数字证书的过程：**

1. 拿到证书，得到明文T，数字签名S。
2. 用CA机构的公钥对S解密得到S’。（这个公钥是浏览器信任的机构，所以浏览器保有它的公钥）
3. 用证书里说明的hash算法对明文T进行hash得到T’。
4. 比较S’是否等于T’，等于则表明证书可信。

**为什么需要hash过程：**

- hash后得到的是固定长度的信息，这样加密解密就会快很多。
- 也有一些安全原因

---

有的地方会提到信任链这个词：就是我绝对相信你（A>B）；你绝对相信他（B>C）；等于我绝对相信他（A>C）。在这里A就是我，B就是CA机构，C就是证书发送者。

# HTTP建立流程

(这个小节可以回答：从输入URL到页面加载，发生了什么（http/https）)

HTTPS的建立流程就是HTTP的流程加上了一系列的加密操作，所以重点是需要理解HTTP的建立流程。

主要流程很简单：输入域名，DNS查找IP，同该IP开始HTTP交互，服务器接收到请求后进行处理然后返回报文，游览器进行页面的渲染解析。

- HTTP过程首先建立TCP连接，根据HTTP的连接类型进行后续的TCP交互。
  - HTTP的连接类型：
    - 非持续连接和持续连接（又称长连接和短连接）
    - 串行连接和并行连接
    - 流水线和非流水线
- DNS查找和页面渲染解析又有很多流程。

---

**短连接与长连接：**

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

- 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 `Connection : close`；
- 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 `Connection : Keep-Alive`。

**流水线：**

默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。

流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

# Cookie & Session

（Cookie和Session应该说是HTTP的其他问题，也可以说是首部字段的应用，但是他如此重要，我便把它放到了这里讲解）

HTTP 协议是无状态的，但是我们很多情境下需要有状态（例如服务端需要记录用户及其状态），这时就需要用某种机制来识具体的用户，因此引入了Cookie和Session，两者分别在客户端和服务器发挥作用。

- Cookie：客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
- Session：服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；

## Cookie

Cookie分为会话期 Cookie和持久性 Cookie：

- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
- 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。

Cookie可用于：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。

Cookie可以通过Domain标识作用域，通过Secure标识必须使用HTTPS请求发送，通过HttpOnly标记为不能被 JavaScript 脚本调用。浏览器可以通过 `document.cookie` 属性可创建新的 Cookie。

## 建立过程

第一次创建Session的时候，服务端会在HTTP协议的响应报文包含 Set-Cookie 首部字段，这告诉客户端需要在 Cookie 里面记录一个Session ID。

客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。

- 如果客户端的浏览器禁用了 Cookie 怎么办？

  这种情况下使用URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。

## 二者比较

（二者比较，以及为什么要使用两者）

既然session的实现需要借助于cookie，那服务器直接根据cookie来实现会话跟踪，不是能达到一样的效果吗？那么为什么要搞那么复杂，直接用cookie不就行了吗？弄个session还需要借助cookie，不是多此一举吗？

- 那会话时间怎么用cookie控制？
- cookie保存在本地不安全，session存储在服务端，安全性高；
- session支持更多数据类型；
- 传输cookie对带宽有开销
- 终端不只是浏览器

二者比较

- 数据类型：Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
  - cookie：一个cookie只能保存一个key-value值，并且都是String类型
    session：可以保存任何类型
- 安全性：Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 性能开销：对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

## 其他问题

**session 和 session 实现：**

本来 session 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent 和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念。

 而 cookie 是一个实际存在的东西，http 协议中定义在 header 中的字段。可以认为是 session 的一种后端无状态实现。

而我们今天常说的 “session”，是为了绕开 cookie 的各种限制，通常借助 cookie 本身和后端存储实现的，一种更高级的会话状态实现。

所以 cookie 和 session，你可以认为是同一层次的概念，也可以认为是不同层次的概念。具体到实现，session 因为 session id 的存在，通常要借助 cookie 实现，但这并非必要，只能说是通用性较好的一种实现方案。

**Cookie和Session的安全性：**

- 使用HTTPS加密，防止被伪造请求
- 产生一个不容易被猜到的 Session ID 值
- 经常重新生成 Session ID
- 安全性要求极高的场景下，对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式

**分布式Session：**

集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。

假设第一次访问服务A生成一个sessionid并且存入cookie中，第二次却访问服务B客户端会在cookie中读取sessionid加入到请求头中，如果在服务B通过sessionid没有找到对应的数据那么它创建一个新的并且将sessionid返回给客户端,这样并不能共享我们的Session无法达到我们想要的目的。

解决方案：

- 使用cookie来完成（很明显这种不安全的操作并不可靠）
- 使用Nginx中的ip绑定策略，同一个ip只能在指定的同一个机器访问（不支持负载均衡）
- 利用数据库同步session（效率不高）
- 使用tomcat内置的session同步（同步可能会产生延迟）
- 使用token代替session
- 使用spring-session以及集成好的解决方案，存放在redis中

# 其他问题

1. **即使DNS解析域名得到对应的IP后，Request请求里还是会带上host。为什么？：**

   因为域名!=IP。实际上一个IP可以对应多个域名。也就是说一台实体服务器（大铁柜），理论上可以有多个域名（虚拟主机）。实体服务器和网站是两个概念。**IP只是对应实体服务器，而域名对应具体的网站。**

   比如百度服务器，虽然看起来115.239.210.27这个IP完全等同于[http://www.baidu.com](http://www.baidu.com/)，但也有可能这个IP对应的服务器上配置了两个虚拟主机：[www.baidu.com](http://www.baidu.com/)和[tieba.baidu.com](http://tieba.baidu.com/)。所以即使找到了IP对应的服务器实体，Request请求还是要带上host主机名，以确定是哪个虚拟主机
   
2. URL Uri

   URL和URN是Uri的子集，Uri的目的是在某一规则下能把一个资源独一无二地标识出来。URL是用地址locator的方式定位了唯一的资源

3. http1.0 http1.1 http2.0 的区别

   - HTTP1.1相对于HTTP1.0，添加了：缓存处理、长连接和流水线、只请求一部分对象、错误通知、Host头。

     - HTTP1.1是当前是用最广泛的

   - HTTP2.0：新的二进制格式、多路复用、header压缩、服务端推送

     

# 参考

> 1. [http面试题](https://juejin.im/post/5d032b77e51d45777a126183)
> 2. [CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md)
> 3. [知乎：COOKIE和SESSION有什么区别下的系列回答](https://www.zhihu.com/question/19786827)
> 4. [彻底搞懂HTTPS的加密机制](https://zhuanlan.zhihu.com/p/43789231)
> 5. [分布式Session共享解决方案](https://juejin.im/post/5c13bea65188251595128d4b)

