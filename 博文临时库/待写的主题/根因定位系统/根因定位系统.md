# 数据规律

## 拓扑规律

-  （待验证）sys内部的node是分层的，即每一层中的每一个节点都具有相同的入节点和出节点，类似神经网络的全连接，
   例如 sys_4中的 node77 node62
   并且好像是在topology_edges_node中的体现为：所有在同一层的节点，具有相同的后继节点列表
   其实这也是符合常识的

   每个sys内部分为了3层
   我命名为 接收层、中间层、转发层
   接收层：可能接收来自 一个或两个 的其他sys的转发层(存疑)的 信息
   中间层: 为 接收层和转发层之间的桥梁，全连接
   转发层：向 一个另外的sys的接收层(存疑)转发 信息

  - （待验证）如果是这样：其实中间层可以忽略，接收和转发抽象为一个节点
  - sys内部的报警如果传到了外面，基本上可以用sys的拓扑信息，不用考虑node的拓扑信息了

- （待验证）可以根据那个报警文本多的系统筛选出疑似的几个系统，然后和根因系统直接联通的系统必定是疑似系统

  就是1---->2  3---->2  如果2是根因系统，那么2的报警文本必定很多而且1，3的也必定很多

  也就是有根因的系统必定导致和该系统直接相连的系统报警文本很多
  然后和根因系统直接联通的那些系统只会出现两种情况，超时和资源空闲

  而没有根因的报警文本集群，那些含有多个报警文本的系统，这些系统之间要么是1--->2--->3这样联通，要么就没有很明显的联通关系

## 文本规律

**有根因**的csv报警文本集群：

- 总会有系统有较多的报警文本？

  :ballot_box_with_check: 总会有**多个**系统有较多的报警文本

  这几个系统：

  - :ballot_box_with_check: 不确定的个数，可能不是根因所在的系统
  - :ballot_box_with_check: 但总比剩下的其他系统的报警条数**多得多**，只是比L多的多，M处于变化之中

  - :ballot_box_with_check: 这些系统一定包含了根因所在系统，即根因所在系统一定在H分组里❌（有可能在M或者L里，但是基本都在统计数的前半部分），一定在报警较多的一类系统里

  > 进行验证的时候，计算出每个csv中的出现的sys的出现次数，按照出现次数对sys进行聚类，设定参数为分为3类，3-means例如如下：
  >
  > ```csv
  > 22.csv
  > [[ 66. ]
  >  [139.5]
  >  [ 20. ]]
  > [1 1 1 1 0 0 0 0 2 2]
  >       sys  count  label
  > 0   SYS_1    181      1
  > 1   SYS_2    143      1
  > 2   SYS_9    124      1
  > 3  SYS_10    110      1
  > 4   SYS_5     82      0
  > 5   SYS_3     67      0
  > 6   SYS_6     58      0
  > 7   SYS_4     57      0
  > 8   SYS_8     25      2
  > 9   SYS_7     15      2
  > ```
  >
  > 出现情况如下（把三类按照count命名如下：H、M、L）：
  >
  > - H和M 占比均 远大于 L
  >   - 有根因的如：0.csv
  >   - 无根因的如：14.csv
  > - H、M、L 占比大致相同
  >   - 有根因的如：2.csv、5.csv、9.csv
  >   - 无根因的如：23.csv
  > - 其他情况暂且不写（只是暂时懒得写，可能有用）
  >   - 其实这些情况也可以聚类聚出来

- 在上面这些个有较多报警文本的系统中，

  （待验证）有一个系统的报警，是比较杂乱的，就像是a节点的报警导致了b节点的报警，两个报警信息不相同，这就是根源所在系统？

  （待验证）在这些系统里，其它系统的报警文本是相似度很高的嘛？（待验证）而且基本报超时？（待验证）而且基本这些报超时的系统都和出错的系统相连：报超时的系统----->根源系统

  - 上层系统要是报警特多，那么这些上层系统的公共下层节点很大可能是根因系统

- （待验证）根因报警总是固定间隔的重复出现

**没有**根因的csv报警文本集群：

- （待验证）也会出现有较多报警文本的系统，而这些系统的报警文本，一般都高度相似，（待验证）而且很多报警文本是相同的。而报警信息不局限于超时，（待验证）不同节点之间的也是相似的嘛
- 





 先定位sys 再定位 node。定位sys可以不考虑node。

http://m.c114.com.cn/w169-1083917.html

# 训练和测试

- 告警规则挖掘阶段

  是为了实现基于历史告警数据的大数据分析，从历史数据中获得告警之间的关联规则，形成规则数据库；

  （训练集）

- 告警分析处理阶段

  目的是基于所获得的规则数据库中的关联规则，对网络中的当前告警进行分析和处理，获得当前告警中的根源告警及衍生告警。
  
  （测试集）

# 训练过程

训练过程：

（没有系统节点和网络主机节点之间的关系，只有报警文本的关系）

1. **聚类过程：**根据时间信息和连接信息**把不同的根源告警及其衍生告警区分开**，代表不同的报警信息集群，每一类代表一个根源告警及其衍生告警

   例如9点可能产生一大群报警，10点可能产生另外一大群报警

   - 利用告警的开始时间及结束时间，使用DBSCAN算法在时间维度进行聚类？

   例如和A主机紧紧相连的产生了报警，但是和A主机距离很远的也产生了报警，可是他们没有关系，基本就确定了不是一个原因？

   - 利用准确的节点连接信息，对告警数据进行“硬划分”；
   - 聚类过程可能用到多维聚类算法，可能用到数据降维

2. 在这个报警簇内部进行**关联规则**挖掘，挖掘过程如下

   1. 首先对告警文本进行**文本分类？**

      例如把告警文本分类成 异常报警  网络报警  内存不够报警等，就是抛弃文本的具体信息，只使用分类结果的标签

      对告警信息进行分类，类别之间应该可能有一些关联关系，类内信息可以大体抛弃，这其实是类间挖掘？

      - 对告警信息进行进一步筛选的过程

   2. 计算支持度、置信度、后件置信度三个矩阵,（告警计数）

   3. 计算衍生强度derive和后件衍生强度bderive

   4. 得出一颗告警规则树

   5. 保存**规则树**

##  支持度、置信度、后件置信度

- 2个评价指标：支持度和置信度。

  - 支持度指的是有序告警对（a→b）在聚类结果中出现的次数，即关联频次。

  - 置信度指的是在告警a出现的前提下，告警b接着出现的条件概率。
    - 后件置信度的提出是为了解决置信度忽略规则后件中项集的支持度

      前件置信度a→b统计结果100%，则说明有a就一定有b，后件置信度为100%，就说明b前面一定有a，

      当前件置信度很低，但是后件置信度很高时，认为规则a→b也是有效的。所以引入了后件置信度，即在告警b被发现的前提下，告警b由告警a导致的条件概率。

  支持度可以用来衡量有序告警对（a→b）出现是否频繁，而置信度和后件置信度则用来说明有序告警对（a→b）之间的关联强度。置信度和后件置信度越高，说明有序告警对（a→b）之间的关联强度越大

  得到了聚类结果之后，在聚类结果中分别统计支持度、置信度、后件置信度。统计完成之后，可以得到3个告警关联矩阵，在这个方阵中，元素的行代号代表在前的告警，元素的列代号代表在后的告警。如表1红色数字所示，代表的是04告警→02告警的支持度

<img src="E:\Pictures\temp\20190402144111.jpg" style="zoom:50%;" />

告警关联矩阵中信息较多，为了筛选出潜在的规则，定义2个参数：衍生强度derive和后件衍生强度bderive，用来衡量有序告警对（a→b）的衍生强度。衍生强度和后件衍生强度的公式如下。

<img src="E:\Pictures\temp\20190402144239.jpg" style="zoom:50%;" />

衍生强度和后件衍生强度基于的假设是：告警之间不能两两互推，如果存在（a→b），就不存在（b→a）。如果衍生强度或者后件衍生强度大于1，则a→b要比 b→a更加可信，更加符合统计规则。

从式（1）和（2）中可以看出，告警之间的自推是没有的，因为derivea→b和bderivea→b都会等于1，会被过滤掉。根据上述的原则，可以得到潜在的告警关联规则。置信度包括后件置信度说明的是a→b的关联强度，值越大说明关联强度越大。但并不能完全说明a能推导出b，因为在这种情况下b→a的置信度包括后件置信度也有可能很高。为了避免一部分有效的规则被过滤掉，在由告警关联矩阵挖掘潜在高级规则时，算法当中的一些阈值可以设定得低一些，那么得到的潜在规则就会相应地多一些。



## 进一步筛选告警信息

- **告警压缩**[ A , A , …, A ] →A :将多个同时 发生的告警缩减到 1 个告警中
  - 从规则数据库中遍历所有告警规则，对每一簇告警数据进行分析，得到根源告警，实现告警压缩
  - 小范围告警压缩
- 告警替代
  - 例如多个告警可以归结为一个告警信息，其实也就是分类的计数过程
  - 将L中所有报警的Ai值替换为Gi规则树中Ai的父值，通过这一操作不断对报警进行泛化。
- :warning:**告警过滤**[ A , B , C , D ] →A :删除不符合 告警相关性要求的告警;**？？？**
- 报警数量大于min_size的泛化报警
- 决策树中有的可以判断的报警，没有的不能判断的报警如何判断



# 测试过程

- 按照学习训练过程进行测试分析

- 根据聚类后的告警数据，对每一条告警判断其是否与其根源告警并存，若有则该告警被排除，若不是则该告警保留，直至遍历所有告警数据后得到根源告警数据集
- 将被排除的衍生告警添加标记，将根源告警添加标记后上报网管实现进一步过滤
  - 从这些疑似根源告警里随即找出一个根因？



# 报警的问题

- 有**因果关系**的报警和**没有**因果关系的报警

- 根因结点和下方节点形成**环**，可能会导致无法找到根因。

  - 每个节点的值等于与之相连的节点的值(发出警报为1+下层的值，没发出就是0)，最后找到值最大的节点是根因。

    就是没有跟因可能也会判断得出根因，不能很好的聚集数据。效率感觉会很低。

- 告警信息是否集中在少数几种类型中？

  - 判断哪个类型用的是聚类？

- 根因可能找出来多个节点

- 可能没有根因

- 决策树中有的可以判断的报警，没有的不能判断的报警如何判断



# 可视化UI参考

- https://plotly.com/python/network-graphs/ 中的图的UI格式