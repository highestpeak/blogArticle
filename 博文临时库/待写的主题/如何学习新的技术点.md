- 首先了解一个技术出现的背景、原因、演进史、同类技术对比

  - 这个方面，维基百科等综述性站点，是非常有用的，但可能也有更好的方法

- 其次从官方文档学习（如果有详细的教程和友好的文档的话）

  - 但是没有一个文章来告诉我们如何去使用这个文档，如何或者按照什么步骤去学习这个文档，但这却是很重要的

    当然你可以说这是学习者个人的素质，但是为什么没有人来帮助一下大家呢

- 其次是小的使用

- 可以通过查找面试题，查找出现的问题来学习这个技术

- 最深入的了解莫过于阅读源码，但是这个最耗费精力，如果不是很重要很底层的技术，还是尽量不去浪费时间，这个看具体情况，该分析还是要分析



why and what？when and where？how？

一个技术，例如数据库事务为何出现？他是有目的的，有原因的，因此需要了解这个目的。这样也可以便于明确使用场景，在类似的场景下如何思考也会油然而出。面对类似的需求就会想到这个词汇。

一个技术在哪里被使用、何时被使用是他的关键点。

如何被使用？不只是简单的语法和写法，还有各种各样的用法，技巧，各种各样的写法，这也是如何被使用



有一个wiki系统用来记载工具书性质的东西，其实就是doc，不过是把各自各处的文档的官方的，大家的一家之言整理成一个wiki来便于查阅，固然可以说到处都有，但这就和记笔记一样，我不记一遍都不知道在哪里找，自己写一遍/手动敲一遍总会知道在哪里的，久而久之就可以不去看了。（来自实训wiki的感悟）



有一个文章系统，用来记载不是工具书性质的，有一些讨论和思考的东西。



这样一个写作系统用来整理知识。



是若学习新的技术点，必然需要掌握旧的知识点，掌握一个体系，刘备建业仍有荆州为基地，这个体系就是一个基地。

绝世武功非一日可成



一个说法可能有很多类似的说法，比如由五六七八个说法，有的人能从第一个说法就获得感悟，但有的人可能需要第六个或者第七个说法来获得感想，这不是人智力的差别，而是人思考方式的差异。不同的说法也是一种补充，所以也应当指明一个知识的多个说法。这形如 “为何出现这个技术” 可以和“这个技术的目的、目标” 类似



每个文章：

本文各节的关系

从本文能回答什么问题



有时候从问题切入，可以更好地理解一个知识，来组织一个体系。



在学习新的技术点时，需要看书。但是不能一上来就去看大部头。先去看入门书，然后去看大部头。这样看完入门书有一个大体了解，或者可能产生一些问题。



关于技术标准：例如阿里巴巴技术手册、Google开发手册，这样的技术标准往往是带有“陷阱”的，这些陷阱是我们产生一种我受这个公司影响和控制的想法。我们在使用这样的标准的时候应当记住：他们的标准只是一种建议，而不是强制要求，我们不必为他们所束缚：如果他们说的对我们就用，不对就果断不用，并且我们有权利和自信去讨伐和"骂"他们的不对的地方。



如果一本书很经典，以至于我们需要看很多遍，那么其实不必要去看同一本书的好几遍，可以看别人的解释的版本的一遍（即"批注版"的），看该书新旧发行版本的几遍（如：java编程思想第四版、On Java 8），做一遍习题（第一遍不做习题啥的）什么的、看一下书的参考文献什么的



看书，BBS，各大论坛站点的精华帖都下下来看，边看边实践、

看源码，重复实现

这是一个人写的他学习网络协议的学习方法：
网络这东西就是一个靠实践的东西，只靠看书是不行的。当年在学校还上过史美林教授/张公忠教授所讲的计算机网络体系结构课，用的是Tanabaum写的那本，考试还得了九十多分，可实际还是连TCP和UDP有什么区别都分不清，就是死记背，到毕业的时候基本上是忘光了，工作后等于重新来过。
      上班了要在Linux做一些底层的网络处理，不得不从头来学Linux和网络，编程部分主要看Richard Stevens的那几本书：APUE、UNP、TCP/IP Illustraion等，学Linux则看得很杂，市面上各种Linux入门书大都翻了一遍，俺是习惯在书店里看书，爱看书而不爱买书，汗，，然后就是**去各大BBS、论坛把他们的精华区都下载下来狂看**，**边看边实践**，基本上在一个月内**熟悉**了Linux的**操作**。
           学网络协议刚开始也是看书，但看了之后没多少印象，那些东西靠死记真是没法记的，后来找到一个好办法，就是自己写个sniffer，**自己写个协议分析器**，先学怎么抓包，就看tcpdump的源码，然后看libpcap的源码，知道了什么是网卡的混杂模式，很快就能抓到网卡上包的。接下来就是对包进行分析，就看作TCP/IP Illustraion，从以太头、ARP/IP、ICMP/IGMP/TCP/UDP、HTTP/FTP/TELNET/SMTP等这么一点一点、一个字段一个字段分析下来，很快就明白了所谓TCP/IP到底是怎么回事。另外为了学TCP状态转换表，根据所抓的包的TCP标志分析通信双方当前是什么状态，刚开始还只能从头一方发SYN包开始分析，到后来是可从连接中间包如手就能逐渐判断双方的TCP状态，基本上是彻底搞清楚了TCP的状态转移是怎么回事，后来再理解防火墙的状态检测原理就很容易了。另外在分析过程中，为彻底掌握IP碎片，还特地ping大包来抓，把抓上来的包自己重组，搞明白了IP头的碎片offset字段是怎么用的。
          能抓包后进而又开始学如何自己构造包来“干扰”正常通信了，开始是学怎么发TCP的RST包来切断一个正常的TCP连接，就的学会如何计算IP头校验和，TCP校验和，知道了算TCP校验和时必须加IP伪头数据，然后是正确计算序列号和确认号，知道了原来SYN和FIN标志也是算一位的，最重要的是理解了什么是网络序什么是主机序，现在基本把ntohs(l),htons(l)处理都成了一种编程的本能意识了。学会用RST切断TCP后，进一步实现了直接发一个页面信息告诉客户端访问了非法信息，也就是以后实现URL过滤时客户端显示的拒绝画面。后来也学发ARP信息胡乱通告MAC地址，也就是以前写的那篇ARP攻击的由来。
           后来俺写的这个协议分析器逐步完善，能解析的就解析，不能解析的就打印出16进制数，可打印字符也打印出来，对HTTP、FTP、POP3、SMTP这些文本协议几乎就一下看明白了，对于非文本协议，如DNS，也根据协议解析了出来，而且解析DNS时不得不用了我一向不爱用的递归方法来编程。随着网络应用的增加，在用到前都先作协议解析，除了各种TCP、UDP的协议，还增加了BPDU、PPPOE、OSPF、ESP、AH、IKE等的解析处理，现在俺的协议分析器也可以分析上百种协议，平时抓包就只用俺这个，TCPDUMP基本不再用了，毕竟自己写的自己更清楚，如果有不能解析的再现加进去。现在学新协议时，往往先抓包看看协议的基本数据格式，再看RFC了解细节。
              学协议刚开始是看书，到后来要更深入了解或追询最新发展情况就只能看RFC了，毕竟网络的东西变化太快，书的东西只能算入门，说不定很快就出新的了，到现在也看了数百篇的RFC了。
             通过**编程分析来学协议**，慢是慢了点，花了一个多月的时间，但感觉学得扎实，正所谓磨刀不误砍柴功，而且一通百通。到现在虽然已经好几年了，IP头，TCP头有哪些字段还是一下就可以说得出来，对理解各种网络攻击原理从而进行防范更是有帮助，我觉得对我来说这种方法是很有效，如果哪位觉得有更有效的学习方法，可以共同交流一下。



需要数量的掌握一些工具，才能学习的更好：python脚本、bash脚本、正则、JavaScript、git等



学习历史，了解递进过程，为了什么引入什么，学习他的目的

循序渐进最好，不要一口吃成胖子



计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。

计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。**Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。**

第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。

IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。**对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。**



学习必须要做习题练习或者写代码**练习**，查找各方资料，综合各家之言，然后自己思考，整出一个有价值的东西。



这种用类比来解释问题往往就会面临『十个类比九个错』的尴尬局面，如果别人用类比回答你的为什么，你需要仔细想一想它的类比里究竟哪里有漏洞；类比带来的解释往往只能有片面的相似性，我们永远也无法找到绝对正确的类比，它只在我们想要通俗易懂地展示事物的特性时才能发挥较大的作用，



看大量的论坛，把它们的精品文章都扒拉下来，总结学习，然后实践。



比如我现在要学习进程线程，我应该对照多个参考书，先把每本书所有关于进程和线程的内容都看一遍，然后对不熟悉的问题上网查询，总结成文。同时对照多种教学视频来学习这个知识点。



关于看书这件事：我记得之前有个人好像是数据库老师跟我们讲过，读一本书第一遍应该粗略的看一下第一章这样的类似的综述的，然后再看每一章。最后等到读完整本书之后，需要再看一遍第一章这样的综述的。我觉得没有毛病，这是很正确的做法。



----

来自 B站-喜欢历史的程序君 如何学习一门技术

- 我们每天觉得习以为常的事情其实是很美好的（高一的时候的回家睡觉的感慨）
- B站十周年演讲很好？
- 美国铁锈区
- 亚马逊的一个 Mechanical Turk 通过API申请人的资源
- 农业革命==>工业革命==>信息革命（）
- ![](E:\_data\博文临时库\博文中的图片\临时存储\QQ截图20201008224608.png)

![](E:\_data\博文临时库\博文中的图片\临时存储\QQ截图20201008224704.png)

- 让轮子转起来，不能半途而废，



Github 上的各种端的技术路线图



- 结果导向（期望结果）、目的性越强越能更好的学习
- JS和CSS是比C和C++以及Java这种反馈更快的，这在这几天前端的书写也发现了
  
  - 所以需要很快的即时反馈系统
- 从小处，阅读别人的文档代码，抄袭别人的思想（例如Halo）
- 例如学习并发：要学习Java的并发、数据库的并发、GO的并发等等，找到共同点和区别
- 线下请教、教授
- 阅读大量的代码（很重要）
- 刻意练习：不断地实现已有地轮子来学习新的技术，例如写一个 todo list，写一个 git 等等
  - 每一个知识点都要写大量地代码
  - 这样的刻意练习已有的轮子，可以参考已有的实现，然后自己会继续下去。意义是实在不会去写就去抄，但是抄的过程是需要思考的，而不是完全的抄。抄完就学会了
  - 大量要达到万级别的代码!
  - 大量也要广度：并发、加密/安全、数据结构、网络、数据库
- 把所学的知识用到下一个个人项目，不是工作项目
- noise protocl 协议
- 元编程和元协议
- rocksdb
- webAuthn
- clean 架构
- 构建知识体系
- 每个技术分成几个层次：表现层、应用层、IO层（网络）、协议层
- ![](E:\_data\博文临时库\博文中的图片\临时存储\QQ截图20201008230506.png)

- 学习要形成高效的反馈环

  learn=>build（写应用0=>measure(看自己学的怎么样)=>learn

  希望更快更高效

- ![](E:\_data\博文临时库\博文中的图片\临时存储\QQ截图20201008230716.png)

- 不是整个repo而是感兴趣的部分
- 好的repo：文档、wiki、博客文章
- 先读著名的repo，因为有人回答问题，社区活跃
- 学习系统构建就需要学习 linux kernal ？
- notion
- 个人项目的灵感来源：看的太多（各种站点），用软件会去想怎么实现的，思考用的软件的未来发展，思考很多产品之间的联系（功能上、使用的技术的联系）
- keybase 
- 学到多深？要看个人兴趣和需要，这其实是废话但又有用。工作用的要学很深，个人用的要依据兴趣，依据要用什么就学什么
- 看到什么就先抄下来，之后有时间再组织
- tubi
- meetup
- redis的skiplist结构，数据结构也是很复杂的，

blockchain

学习了，之前总觉得一个技术点如果有很详细的文章解释的话自己就没必要再去写了，但其实别人写的始终是别人的。自己写文章或者说写总结的初衷应该是通过这种形式去帮助自己更好的理解这个技术点，所以自己写总结和这个技术点有没有其他优秀文章并没有冲突。

一般我都会去看最终的代码；只有对某些实现有疑惑的时候，才会去看 commit / pull request。

按照commit方式去看：便于发现他的优化历程，并且也便于思考他为啥这么做？但是如果代码写了很多，就会有很多commit，消耗的时间是一个弊端
如果直接看最终的代码会存在问题就是不知道从哪里看起？根据业务去调试也不知道有啥章法



- 有人肯定会这样问：Git 官方的文档已经很清楚了，为什么要写这样的一篇 wiki 呢？

  我认为这样做虽然是一种重复，但是这不一样，这是我自己的整理，处于我自己的知识体系，能够让我更好的理解和学习。

  另外，互联网并不缺少写这个的存储空间，有大量的垃圾信息充斥着整个网络，真的，不差我这一个。

- 如果这个图在别的地方出现过，但是我仍然在这里重新画了一遍，目的不是为了去掉抄袭的痕迹，而是因为感觉这样做可能会使得图形符合我整体图片的风格

- 有的时候同一句话可能会用不同的说辞写好几遍，这样做不是因为我粘贴时候没有动脑子，而是说我认为某种描述才会使得某一刻的某一人领悟这个内容，即只写一种描述可能不会使得人明白，这些人当然也包括我自己



什么是子程序----什么是高质量子程序----什么是低质量子程序

- 这是一个学习过程！
- 不明白什么是高质量，就去看什么是低质量



当我们学习新的工具、框架时，我们应该学习他们可以自定义的内容，他们hack的内容



虽然你在不同地方进行搬运内容，但是因为你按照了不同的方式组织这些内容，就会看到不一样的风景，给人不同的启发；并且它会固化到你自己的体系里。所以哪怕一句话和其他地方完全一样，但是它出现在不同的地方，那他也是有用的