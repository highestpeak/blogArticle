# 适配器模式

适配器模式(Adapter Pattern) ，别名为包装器(Wrapper)

使用情况：

- 适配器模式允许创建一个**中间层类**，使得不同的、不兼容的接口能够互相合作

  举例如：

  - 旧版本接口和新版本接口的适配（**遗留类**）
  - 不同SDK的实现和系统内的调用适配（进行数据格式转换、不同名称的函数调用）（**第三方类**）
  - **提供怪异接口的类**之间的转换器
  - 不同标准和实现的适配

- 甚至可以创建一个**双向**适配器来实现双向转换调用

- 同一继承体系中不同类之间的部分共性，**将缺失功能添加到一个适配器类**：

  如果您需要复用这样一些类，他们处于同一个继承体系，并且他们又有了额外的一些共同的方法，但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性，所以不能把这些方法抽取到父类中

  - 你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码，然后变身成为伟大的码农
  - 你也可以为这些类创建一个公共的父类，这个父类继承原来体系中的最近父类，但是如果这些具有共性的类不处在同一继承层次这样就不能起作用，而且这样一个新的中间层可能让人难以理解

  将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。（如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。和装饰模式就非常相似了）（这样可以进行很多次封装缺少功能的操作）

- 通过使用配置文件，可以很方便地更换适配器

  适配器其实也可以看作对不同硬编码实现的灵活调用，通过这样避免了 `switch/case` 语句。通过读取配置文件可以动态的配置适配器对象创建时传入的适配者对象实例类型



分为两类：对象适配器、类适配器

对象适配器

- 实现：

  使用了**组成**原则： 适配器实现了其中一个对象的接口， 并对另一个对象进行封装。 所有流行的编程语言都可以实现对象适配器

  - 有些实现是：实现`client interface`，继承`Service`，这在必须扩展Service的时候比较适用
  - 有些实现是：实现`client interface`，成员变量引用`Service`

- 一个对象适配器可以把多个不同的适配者适配到同一个目标；
- 可以适配一个适配者的子类，

![](E:\_data\博文临时库\博文中的图片\适配器模式-对象适配器类图.png)

类适配器

- 实现：

  这一实现使用了**继承**机制： 适配器同时继承两个对象的接口。 请注意， 这种方式仅能在支持多重继承的编程语言中实现， 例如 C++

  - （按照JAVA的说法是）同时继承两个类，只能在支持多重继承的语言中实现
  - （按照JAVA的说法是）同时实现两个不同的接口，就是类适配器

  ![](E:\_data\博文临时库\博文中的图片\适配器模式-类适配器类图.png)

特点/实现要点：

适配器实现了一方的接口，看起来好像适配器就是一方的成员，但是适配器同时持有了另一方的实例，进而在适配器实现的接口的方法中，适配器做的实现既是接口和数据格式的转换，然后调用实例的方法，只是一个中介

- 适配器的一个特点在于，适配器类中添加**一个成员变量用于保存对于服务对象的引用**。 

  通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。

- 依次实现适配器类`client`接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换

- `client`必须通过`client interface`使用适配器。 这样一来， 就可以在不影响`client`代码的情况下修改或扩展适配器

适配器模式包含如下角色：

- Target：目标抽象类
- Adapter：适配器类
- Adaptee：适配者类
- Client：客户类



默认适配器（缺省适配器）（单接口适配器）

当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。因此也称为单接口适配器模式





优缺点：

- 满足开闭原则（可以在不修改client的代码情况下在程序中添加新的类型适配器）
- 满足单一职责原则（将数据转换代码从业务逻辑分离）

- 代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单



## 常见实例

- 数据格式转换：

  例如在开发过程中， 你决定在程序中整合一个第三方智能分析函数库。 但是遇到了一个问题， 那就是分析函数库只兼容 JSON 格式的数据，

  - 可能需要修改部分依赖该程序库的现有代码，但可能你根本没有程序库的源代码
  - 所以这个时候需要编写一个适配器

- 电源插头和插座标准：

  例如不同国家的电源插头和插座标准不同。 美国插头和德国插座不匹配。 同时提供美国标准插座和欧洲标准插头的电源适配器可以解决你的难题

- 避免switch/case，对同一件事不同实现：

  [圆孔、圆钉、方钉](https://refactoringguru.cn/design-patterns/adapter)是个很好的例子，这个情况是如何确定圆孔是否可以容纳下钉子（园钉和方钉），园钉可以直接调用自身的获取半径`getRadius`，但是方钉没有获取半径`getRadius`的方法，

  在这个例子中没有选择重写、没有选择加上switch/case这样的语句、没有选择实现共同的接口，而是直接包装了一个类！

- 每一个具体数据库引擎（如SQL Server、Oracle、MySQL等）的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件。抽象的JDBC接口和各个数据库引擎API之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的驱动程序



Java中的适配器模式

适配器模式在 Java 代码中很常见。 基于一些遗留代码的系统常常会使用该模式。 在这种情况下， 适配器让遗留代码与现代的类得以相互合作。

Java 核心程序库中有一些标准的适配器：

- [`java.util.Arrays#asList()`](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-)
- [`java.util.Collections#list()`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-)
- [`java.util.Collections#enumeration()`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-)
- [`java.io.InputStreamReader(InputStream)`](https://docs.oracle.com/javase/8/docs/api/java/io/InputStreamReader.html#InputStreamReader-java.io.InputStream-) （返回 `Reader` 对象）
- [`java.io.OutputStreamWriter(OutputStream)`](https://docs.oracle.com/javase/8/docs/api/java/io/OutputStreamWriter.html#OutputStreamWriter-java.io.OutputStream-) （返回 `Writer` 对象）
- [`javax.xml.bind.annotation.adapters.XmlAdapter#marshal()`](https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-) 和 `#unmarshal()`

**识别方法：** 适配器可以通过以不同抽象或接口类型实例为参数的构造函数来识别。 当适配器的任何方法被调用时， 它会将参数转换为合适的格式， 然后将调用定向到其封装对象中的一个或多个方法。





spring AOP中的适配器模式

在Spring的Aop中，使用的 `Advice（通知）` 来增强被代理类的功能。

```
Advice`的类型有：`MethodBeforeAdvice`、`AfterReturningAdvice`、`ThrowsAdvice
```

在每个类型 `Advice` 都有对应的拦截器，`MethodBeforeAdviceInterceptor`、`AfterReturningAdviceInterceptor`、`ThrowsAdviceInterceptor`

Spring需要将每个 `Advice` **都封装成对应的拦截器类型**，返回给容器，所以需要使用适配器模式对 `Advice` 进行转换

![](E:\_data\博文临时库\博文中的图片\Spring中的适配器模式.jpg)



spring JPA中的适配器模式

在Spring的ORM包中，对于JPA的支持也是采用了适配器模式，首先定义了一个接口的 `JpaVendorAdapter`，然后不同的持久层框架都实现此接口。

jpaVendorAdapter：用于设置实现厂商JPA实现的特定属性，如设置Hibernate的是否自动生成DDL的属性generateDdl；这些属性是厂商特定的，因此最好在这里设置；目前Spring提供 `HibernateJpaVendorAdapter`、`OpenJpaVendorAdapter`、`EclipseLinkJpaVendorAdapter`、`TopLinkJpaVendorAdapter` 四个实现。其中最重要的属性是 database，用来指定使用的数据库类型，从而能**根据数据库类型来决定比如如何将数据库特定异常转换为Spring的一致性异常**，目前支持如下数据库（DB2、DERBY、H2、HSQL、INFORMIX、MYSQL、ORACLE、POSTGRESQL、SQL_SERVER、SYBASE）



spring MVC中的适配器模式

Spring MVC中的适配器模式主要用于执行目标 `Controller` 中的请求处理方法。

在Spring MVC中，`DispatcherServlet` 作为用户，`HandlerAdapter` 作为期望接口，具体的适配器实现类用于对目标类进行适配，`Controller` 作为需要适配的类。

为什么要在 Spring MVC 中使用适配器模式？Spring MVC 中的 `Controller` 种类众多，不同类型的 `Controller` 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，`DispatcherServlet` 直接获取对应类型的 `Controller`，需要的自行来判断，


这几个spring的例子来源为
[掘金: 设计模式 | 适配器模式及典型应用](https://juejin.im/post/5ba28986f265da0abc2b6084)



# 参考

> 1. [refactoringguru: adapter pattern](https://refactoringguru.cn/design-patterns/adapter)
> 2. [StackOverflow: adapter-any-real-example-of-adapter-pattern](https://stackoverflow.com/questions/11079605/adapter-any-real-example-of-adapter-pattern/13323703)
> 3. 

